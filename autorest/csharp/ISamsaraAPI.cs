// <auto-generated>
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.
// </auto-generated>

namespace Swagger
{
    using Microsoft.Rest;
    using Models;
    using Newtonsoft.Json;
    using System.Collections;
    using System.Collections.Generic;
    using System.Threading;
    using System.Threading.Tasks;

    /// <summary>
    /// # Introduction
    ///
    /// Samsara provides API endpoints for interacting with Samsara Cloud, so
    /// that you can build powerful applications and custom solutions with
    /// sensor data. Samsara has endpoints available to track and analyze
    /// sensors, vehicles, and entire fleets.
    ///
    /// The Samsara Cloud API is a [RESTful
    /// API](https://en.wikipedia.org/wiki/Representational_state_transfer)
    /// accessed by an
    /// [HTTP](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol)
    /// client such as wget or curl, or HTTP libraries of most modern
    /// programming languages including python, ruby, java. We use built-in
    /// HTTP features, like HTTP authentication and HTTP verbs, which are
    /// understood by off-the-shelf HTTP clients. We allow you to interact
    /// securely with our API from a client-side web application (though you
    /// should never expose your secret API key). [JSON](http://www.json.org/)
    /// is returned by all API responses, including errors. If you’re familiar
    /// with what you can build with a REST API, the following API reference
    /// guide will be your go-to resource.
    ///
    /// API access to the Samsara cloud is available to all Samsara
    /// administrators. To start developing with Samsara APIs you will need to
    /// [obtain your API keys](#section/Authentication) to authenticate your
    /// API requests.
    ///
    /// If you have any questions you can reach out to us on
    /// [support@samsara.com](mailto:support@samsara.com)
    ///
    /// # Endpoints
    ///
    /// All our APIs can be accessed through HTTP requests to URLs like:
    ///
    /// ```curl
    /// https://api.samsara.com/&lt;version&gt;/&lt;endpoint&gt;
    /// ```
    ///
    /// All our APIs are [versioned](#section/Versioning). If we intend to make
    /// breaking changes to an API which either changes the response format or
    /// request parameter, we will increment the version.
    ///
    /// # Authentication
    ///
    /// To authenticate your API request you will need to include your secret
    /// token. You can manage your API tokens in the
    /// [Dashboard](https://cloud.samsara.com). They are visible under
    /// `Settings-&gt;Organization-&gt;API Tokens`.
    ///
    /// Your API tokens carry many privileges, so be sure to keep them secure.
    /// Do not share your secret API tokens in publicly accessible areas such
    /// as GitHub, client-side code, and so on.
    ///
    /// Authentication to the API is performed via [HTTP Basic
    /// Auth](https://en.wikipedia.org/wiki/Basic_access_authentication).
    /// Provide your API token as the basic access_token value in the URL. You
    /// do not need to provide a password.
    ///
    /// ```curl
    /// https://api.samsara.com/&lt;version&gt;/&lt;endpoint&gt;?access_token={access_token}
    /// ```
    ///
    /// All API requests must be made over
    /// [HTTPS](https://en.wikipedia.org/wiki/HTTPS). Calls made over plain
    /// HTTP or without authentication will fail.
    ///
    /// # Request Methods
    ///
    /// Our API endpoints use [HTTP request
    /// methods](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Request_methods)
    /// to specify the desired operation to be performed. The documentation
    /// below specified request method supported by each endpoint and the
    /// resulting action.
    ///
    /// ## GET
    ///
    /// GET requests are typically used for fetching data (like data for a
    /// particular driver).
    ///
    /// ## POST
    ///
    /// POST requests are typically used for creating or updating a record
    /// (like adding new tags to the system). With that being said, a few of
    /// our POST requests can be used for fetching data (like current location
    /// data of your fleet).
    ///
    /// ## PUT
    ///
    /// PUT requests are typically used for updating an existing record (like
    /// updating all devices associated with a particular tag).
    ///
    /// ## PATCH
    ///
    /// PATCH requests are typically used for modifying an existing record
    /// (like modifying a few devices associated with a particular tag).
    ///
    /// ## DELETE
    ///
    /// DELETE requests are used for deleting a record (like deleting a tag
    /// from the system).
    ///
    /// # Response Codes
    ///
    /// All API requests will respond with appropriate [HTTP status
    /// code](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes). Your
    /// API client should handle each response class differently.
    ///
    /// ## 2XX
    ///
    /// These are successful responses and indicate that the API request
    /// returned the expected response.
    ///
    /// ## 4XX
    ///
    /// These indicate that there was a problem with the request like a missing
    /// parameter or invalid values. Check the response for specific [error
    /// details](#section/Error-Responses). Requests that respond with a 4XX
    /// status code, should be modified before retrying.
    ///
    /// ## 5XX
    ///
    /// These indicate server errors when the server is unreachable or is
    /// misconfigured. In this case, you should retry the API request after
    /// some delay.
    ///
    /// # Error Responses
    ///
    /// In case of a 4XX status code, the body of the response will contain
    /// information to briefly explain the error reported. To help debugging
    /// the error, you can refer to the following table for understanding the
    /// error message.
    ///
    /// | Status Code | Message | Description |
    /// |-------------|----------------|-------------------------------------------------------------------|
    /// | 401 | Invalid token | The API token is invalid and could not be
    /// authenticated. Please refer to the [authentication
    /// section](#section/Authentication). |
    /// | 404 | Page not found | The API endpoint being accessed is invalid. |
    /// | 400 | Bad request | Default response for an invalid request. Please
    /// check the request to make sure it follows the format specified in the
    /// documentation. |
    ///
    /// # Versioning
    ///
    /// All our APIs are versioned. Our current API version is `v1` and we are
    /// continuously working on improving it further and provide additional
    /// endpoints. If we intend to make breaking changes to an API which either
    /// changes the response format or request parameter, we will increment the
    /// version. Thus, you can use our current API version worry free.
    ///
    /// # FAQs
    ///
    /// Check out our [responses to FAQs
    /// here](https://kb.samsara.com/hc/en-us/sections/360000538054-APIs).
    /// Don’t see an answer to your question? Reach out to us on
    /// [support@samsara.com](mailto:support@samsara.com).
    /// </summary>
    public partial interface ISamsaraAPI : System.IDisposable
    {
        /// <summary>
        /// The base URI of the service.
        /// </summary>
        System.Uri BaseUri { get; set; }

        /// <summary>
        /// Gets or sets json serialization settings.
        /// </summary>
        JsonSerializerSettings SerializationSettings { get; }

        /// <summary>
        /// Gets or sets json deserialization settings.
        /// </summary>
        JsonSerializerSettings DeserializationSettings { get; }

        /// <summary>
        /// Samsara API access token.
        /// </summary>
        string AccessToken { get; set; }

        /// <summary>
        /// Timestamp in milliseconds representing the end of the period to
        /// fetch, inclusive. Used in combination with startMs.
        /// </summary>
        long EndMs { get; set; }

        /// <summary>
        /// Timestamp in milliseconds representing the start of the period to
        /// fetch, inclusive. Used in combination with endMs.
        /// </summary>
        long StartMs { get; set; }

        /// <summary>
        /// ID of the asset
        /// </summary>
        long AssetId { get; set; }

        /// <summary>
        /// Timestamp in unix milliseconds representing the end of the period
        /// to fetch, inclusive. Used in combination with startMs. Defaults to
        /// nowMs.
        /// </summary>
        long? EndMs1 { get; set; }

        /// <summary>
        /// ID of the data input
        /// </summary>
        long DataInputId { get; set; }

        /// <summary>
        /// Timestamp in unix milliseconds representing the start of the period
        /// to fetch, inclusive. Used in combination with endMs. defaults to
        /// nowMs.
        /// </summary>
        long? StartMs1 { get; set; }

        /// <summary>
        /// Time in milliseconds that represents the duration before endMs to
        /// query. Defaults to 24 hours.
        /// </summary>
        long? DurationMs { get; set; }

        /// <summary>
        /// Time in unix milliseconds that represents the oldest documents to
        /// return. Used in combination with durationMs. Defaults to now.
        /// </summary>
        long? EndMs2 { get; set; }

        /// <summary>
        /// ID of the driver.  This must be either the numeric ID generated by
        /// Samsara or the external ID of the driver.  External IDs are
        /// customer specified key-value pairs.
        /// </summary>
        string DriverIdOrExternalId { get; set; }

        /// <summary>
        /// Optional group ID if the organization has multiple groups
        /// (uncommon).
        /// </summary>
        long? GroupId { get; set; }

        /// <summary>
        /// Timestamp in milliseconds representing the timestamp of a harsh
        /// event.
        /// </summary>
        long Timestamp { get; set; }

        /// <summary>
        /// Optionally set include=route to include route object in response
        /// payload.
        /// </summary>
        string Include { get; set; }

        /// <summary>
        /// Sequence ID from the response payload of the last request. Defaults
        /// to fetching updates from last 24 hours.
        /// </summary>
        string SequenceId { get; set; }

        /// <summary>
        /// Pagination parameter indicating the cursor position to return
        /// results before. Used in conjunction with the 'limit' parameter.
        /// Mutually exclusive with 'startingAfter' parameter.
        /// </summary>
        string EndingBefore { get; set; }

        /// <summary>
        /// Pagination parameter indicating the number of results to return in
        /// this request. Used in conjunction with either 'startingAfter' or
        /// 'endingBefore'.
        /// </summary>
        double? Limit { get; set; }

        /// <summary>
        /// Pagination parameter indicating the cursor position to continue
        /// returning results after. Used in conjunction with the 'limit'
        /// parameter. Mutually exclusive with 'endingBefore' parameter.
        /// </summary>
        string StartingAfter { get; set; }

        /// <summary>
        /// Time in milliseconds that represents the duration before end_time
        /// to query. Defaults to 24 hours.
        /// </summary>
        long? Duration { get; set; }

        /// <summary>
        /// Time in unix milliseconds that represents the oldest routes to
        /// return. Used in combination with duration. Defaults to now.
        /// </summary>
        long? EndTime { get; set; }

        /// <summary>
        /// Timestamp representing the end of the period to fetch, inclusive.
        /// Used in combination with start_time. Defaults to nowMs.
        /// </summary>
        long? EndTime1 { get; set; }

        /// <summary>
        /// Timestamp representing the start of the period to fetch, inclusive.
        /// Used in combination with end_time. Defaults to 0.
        /// </summary>
        long? StartTime { get; set; }

        /// <summary>
        /// Timestamp in milliseconds representing the end of the period to
        /// fetch, inclusive. Used in combination with startMs.
        /// </summary>
        long EndMs3 { get; set; }

        /// <summary>
        /// Timestamp in milliseconds representing the start of the period to
        /// fetch, inclusive. Used in combination with endMs.
        /// </summary>
        long StartMs2 { get; set; }

        /// <summary>
        /// ID of the tag.
        /// </summary>
        long TagId { get; set; }

        /// <summary>
        /// ID of the vehicle.  This must be either the numeric ID generated by
        /// Samsara or the external ID of the vehicle.  External IDs are
        /// customer specified key-value pairs.
        /// </summary>
        string VehicleIdOrExternalId { get; set; }


        /// <summary>
        /// Gets the IAdd.
        /// </summary>
        IAdd Add { get; }

        /// <summary>
        /// Gets the IGet.
        /// </summary>
        IGet Get { get; }

        /// <summary>
        /// Gets the IList.
        /// </summary>
        IList List { get; }

        /// <summary>
        /// Gets the ICreate.
        /// </summary>
        ICreate Create { get; }

        /// <summary>
        /// Gets the IUpdate.
        /// </summary>
        IUpdate Update { get; }

        /// <summary>
        /// /addresses
        /// </summary>
        /// <remarks>
        /// Fetch all addresses/geofences for the organization. An address
        /// contains either a circle or polygon geofence describing the address
        /// boundaries.
        /// </remarks>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<IList<Address>>> GetOrganizationAddressesWithHttpMessagesAsync(Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// /addresses
        /// </summary>
        /// <remarks>
        /// Add one or more addresses to the organization
        /// </remarks>
        /// <param name='addresses'>
        /// List of addresses/geofences to add. Geofences can be circular or a
        /// polygon.
        /// For each address, only one of 'circle' or 'polygon' should be
        /// provided. If both are provided, the geofence will be saved as a
        /// polygon.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<IList<Address>>> AddOrganizationAddressesWithHttpMessagesAsync(Addresses addresses, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// /addresses/{addressId}
        /// </summary>
        /// <remarks>
        /// Fetch an address by its id.
        /// </remarks>
        /// <param name='addressId'>
        /// ID of the address/geofence
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<Address>> GetOrganizationAddressWithHttpMessagesAsync(long addressId, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// /addresses/{addressId}
        /// </summary>
        /// <remarks>
        /// Delete an address.
        /// </remarks>
        /// <param name='addressId'>
        /// ID of the address/geofence
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse> DeleteOrganizationAddressWithHttpMessagesAsync(long addressId, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// /addresses/{addressId}
        /// </summary>
        /// <remarks>
        /// Update the name, formatted address, geofence, notes, or tag and
        /// contact Ids for an address. The set of tags or contacts associated
        /// with this address will be updated to exactly match the list of IDs
        /// passed in. To remove all tags or contacts from an address, pass an
        /// empty list; to remove notes, pass an empty string.
        /// </remarks>
        /// <param name='address'>
        /// Update parts of an address's value. If the geofence 'circle' or
        /// 'polygon' key is specified, the update will change the type of
        /// geofence accordingly.
        /// </param>
        /// <param name='addressId'>
        /// ID of the address/geofence
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse> UpdateOrganizationAddressWithHttpMessagesAsync(AddressModel address, long addressId, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// /contacts
        /// </summary>
        /// <remarks>
        /// Fetch all contacts for the organization.
        /// </remarks>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<IList<Contact>>> ListContactsWithHttpMessagesAsync(Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// /contacts/{contact_id}
        /// </summary>
        /// <remarks>
        /// Fetch a contact by its id.
        /// </remarks>
        /// <param name='contactId'>
        /// ID of the contact
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<Contact>> GetOrganizationContactWithHttpMessagesAsync(long contactId, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// /fleet/assets
        /// </summary>
        /// <remarks>
        /// Fetch all of the assets for the group.
        /// </remarks>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<GetAllAssetsOKResponse>> GetAllAssetsWithHttpMessagesAsync(Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// /fleet/assets/locations
        /// </summary>
        /// <remarks>
        /// Fetch current locations of all assets for the group.
        /// </remarks>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<GetAllAssetCurrentLocationsOKResponse>> GetAllAssetCurrentLocationsWithHttpMessagesAsync(Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// /fleet/assets/{assetId:[0-9]+}/locations
        /// </summary>
        /// <remarks>
        /// Fetch the historical locations for the asset.
        /// </remarks>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<IList<AssetLocationResponseItem>>> GetAssetLocationWithHttpMessagesAsync(Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// /fleet/assets/{assetId:[0-9]+}/reefer
        /// </summary>
        /// <remarks>
        /// Fetch the reefer-specific stats of an asset.
        /// </remarks>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<AssetReeferResponse>> GetAssetReeferWithHttpMessagesAsync(Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// /fleet/dispatch/routes
        /// </summary>
        /// <remarks>
        /// Fetch all of the dispatch routes for the group.
        /// </remarks>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<IList<DispatchRoute>>> FetchAllDispatchRoutesWithHttpMessagesAsync(Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// /fleet/dispatch/routes
        /// </summary>
        /// <remarks>
        /// Create a new dispatch route.
        /// </remarks>
        /// <param name='createDispatchRouteParams'>
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<DispatchRoute>> CreateDispatchRouteWithHttpMessagesAsync(DispatchRouteCreate createDispatchRouteParams, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// /fleet/dispatch/routes/job_updates
        /// </summary>
        /// <remarks>
        /// Fetch all updates to a job including route data in the last 24
        /// hours or subsequent to an sequence ID
        /// </remarks>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<AllRouteJobUpdates>> FetchAllRouteJobUpdatesWithHttpMessagesAsync(Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// /fleet/dispatch/routes/{route_id:[0-9]+}
        /// </summary>
        /// <remarks>
        /// Fetch a dispatch route by id.
        /// </remarks>
        /// <param name='routeId'>
        /// ID of the dispatch route.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<DispatchRoute>> GetDispatchRouteByIdWithHttpMessagesAsync(long routeId, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// /fleet/dispatch/routes/{route_id:[0-9]+}/
        /// </summary>
        /// <remarks>
        /// Update a dispatch route and its associated jobs.
        /// </remarks>
        /// <param name='updateDispatchRouteParams'>
        /// </param>
        /// <param name='routeId'>
        /// ID of the dispatch route.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<DispatchRoute>> UpdateDispatchRouteByIdWithHttpMessagesAsync(DispatchRoute updateDispatchRouteParams, long routeId, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// /fleet/dispatch/routes/{route_id:[0-9]+}/
        /// </summary>
        /// <remarks>
        /// Delete a dispatch route and its associated jobs.
        /// </remarks>
        /// <param name='routeId'>
        /// ID of the dispatch route.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse> DeleteDispatchRouteByIdWithHttpMessagesAsync(long routeId, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// /fleet/dispatch/routes/{route_id:[0-9]+}/history
        /// </summary>
        /// <remarks>
        /// Fetch the history of a dispatch route.
        /// </remarks>
        /// <param name='routeId'>
        /// ID of the route with history.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<DispatchRouteHistory>> GetDispatchRouteHistoryWithHttpMessagesAsync(long routeId, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// /fleet/drivers/create
        /// </summary>
        /// <remarks>
        /// Create a new driver.
        /// </remarks>
        /// <param name='createDriverParam'>
        /// Driver creation body
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<CurrentDriver>> CreateDriverWithHttpMessagesAsync(DriverForCreate createDriverParam, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// /fleet/drivers/document_types
        /// </summary>
        /// <remarks>
        /// Fetch all of the document types.
        /// </remarks>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<IList<DocumentType>>> GetDriverDocumentTypesByOrgIdWithHttpMessagesAsync(Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// /fleet/drivers/documents
        /// </summary>
        /// <remarks>
        /// Fetch all of the documents.
        /// </remarks>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<IList<Document>>> GetDriverDocumentsByOrgIdWithHttpMessagesAsync(Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// /fleet/drivers/inactive
        /// </summary>
        /// <remarks>
        /// Fetch all deactivated drivers for the group.
        /// </remarks>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<IList<CurrentDriver>>> GetAllDeactivatedDriversWithHttpMessagesAsync(Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// /fleet/drivers/inactive/{driver_id:[0-9]+ |
        /// external_id:[a-zA-Z0-9]+}
        /// </summary>
        /// <remarks>
        /// Fetch deactivated driver by id.
        /// </remarks>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<CurrentDriver>> GetDeactivatedDriverByIdWithHttpMessagesAsync(Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// /fleet/drivers/inactive/{driver_id:[0-9]+ |
        /// external_id:[a-zA-Z0-9]+}
        /// </summary>
        /// <remarks>
        /// Reactivate the inactive driver having id.
        /// </remarks>
        /// <param name='reactivateDriverParam'>
        /// Driver reactivation body
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<CurrentDriver>> ReactivateDriverByIdWithHttpMessagesAsync(ReactivateDriverParam reactivateDriverParam, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// /fleet/drivers/{driverId:[0-9]+}/safety/score
        /// </summary>
        /// <remarks>
        /// Fetch the safety score for the driver.
        /// </remarks>
        /// <param name='driverId'>
        /// ID of the driver
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<DriverSafetyScoreResponse>> GetDriverSafetyScoreWithHttpMessagesAsync(long driverId, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// /fleet/drivers/{driver_id:[0-9]+ | external_id:[a-zA-Z0-9]+}
        /// </summary>
        /// <remarks>
        /// Fetch driver by id.
        /// </remarks>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<CurrentDriver>> GetDriverByIdWithHttpMessagesAsync(Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// /fleet/drivers/{driver_id:[0-9]+ | external_id:[a-zA-Z0-9]+}
        /// </summary>
        /// <remarks>
        /// Deactivate a driver with the given id.
        /// </remarks>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse> DeactivateDriverWithHttpMessagesAsync(Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// /fleet/drivers/{driver_id:[0-9]+}/dispatch/routes
        /// </summary>
        /// <remarks>
        /// Fetch all of the dispatch routes for a given driver.
        /// </remarks>
        /// <param name='driverId'>
        /// ID of the driver with the associated routes.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<IList<DispatchRoute>>> GetDispatchRoutesByDriverIdWithHttpMessagesAsync(long driverId, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// /fleet/drivers/{driver_id:[0-9]+}/dispatch/routes
        /// </summary>
        /// <remarks>
        /// Create a new dispatch route for the driver with driver_id.
        /// </remarks>
        /// <param name='createDispatchRouteParams'>
        /// </param>
        /// <param name='driverId'>
        /// ID of the driver with the associated routes.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<DispatchRoute>> CreateDriverDispatchRouteWithHttpMessagesAsync(DispatchRouteCreate createDispatchRouteParams, long driverId, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// /fleet/drivers/{driver_id:[0-9]+}/documents
        /// </summary>
        /// <remarks>
        /// Create a driver document for the given driver.
        /// </remarks>
        /// <param name='createDocumentParams'>
        /// To create a document for a given document type, the document type's
        /// uuid needs to be passed in to documentTypeUuid. The list of fields
        /// passed in should match the document type’s list of field types in
        /// the correct order. In other words, a field's valueType and value
        /// (i.e. only one of: stringValue, numberValue, or photoValue) at
        /// index _i_ should match with the document field type’s valueType at
        /// index _i_.
        /// </param>
        /// <param name='driverId'>
        /// ID of the driver for whom the document is created.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<Document>> CreateDriverDocumentWithHttpMessagesAsync(DocumentCreate createDocumentParams, long driverId, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// /fleet/vehicles/locations
        /// </summary>
        /// <remarks>
        /// Fetch locations for a given vehicle between a start/end time. The
        /// maximum query duration is 30 minutes.
        /// </remarks>
        /// <param name='startMs'>
        /// Time in Unix epoch milliseconds for the start of the query (cannot
        /// exceed 30 minutes)
        /// </param>
        /// <param name='endMs'>
        /// Time in Unix epoch milliseconds for the end of the query (cannot
        /// exceed 30 minutes)
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<IList<FleetVehiclesLocationsItem>>> GetVehiclesLocationsWithHttpMessagesAsync(int startMs, int endMs, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// /fleet/vehicles/stats
        /// </summary>
        /// <remarks>
        /// Fetch engine state and aux input data for all vehicles in the group
        /// between a start/end time. Data returned may be affected by device
        /// connectivity and processing time.
        /// </remarks>
        /// <param name='startMs'>
        /// Time in Unix epoch milliseconds for the start of the query.
        /// </param>
        /// <param name='endMs'>
        /// Time in Unix epoch milliseconds for the end of the query.
        /// </param>
        /// <param name='series'>
        /// Comma-separated list of stat types. Options are engineState,
        /// auxInput1, and auxInput2. If this parameter is excluded, all 3 stat
        /// types will be returned. Example: series=engineState,auxInput2.
        /// Possible values include: 'engineState', 'auxInput1', 'auxInput2'
        /// </param>
        /// <param name='tagIds'>
        /// Comma-separated list of tag ids. Example: tagIds=1,2,3
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<GetVehicleStatsOKResponse>> GetVehicleStatsWithHttpMessagesAsync(int startMs, int endMs, string series = default(string), string tagIds = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// /fleet/vehicles/{vehicleId:[0-9]+}/safety/harsh_event
        /// </summary>
        /// <remarks>
        /// Fetch harsh event details for a vehicle.
        /// </remarks>
        /// <param name='vehicleId'>
        /// ID of the vehicle
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<VehicleHarshEventResponse>> GetVehicleHarshEventWithHttpMessagesAsync(long vehicleId, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// /fleet/vehicles/{vehicleId:[0-9]+}/safety/score
        /// </summary>
        /// <remarks>
        /// Fetch the safety score for the vehicle.
        /// </remarks>
        /// <param name='vehicleId'>
        /// ID of the vehicle
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<VehicleSafetyScoreResponse>> GetVehicleSafetyScoreWithHttpMessagesAsync(long vehicleId, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// /fleet/vehicles/{vehicle_id:[0-9]+ | external_id:[a-zA-Z0-9]+}
        /// </summary>
        /// <remarks>
        /// Gets a specific vehicle.
        /// </remarks>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<FleetVehicleResponse>> GetFleetVehicleWithHttpMessagesAsync(Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// /fleet/vehicles/{vehicle_id:[0-9]+ | external_id:[a-zA-Z0-9]+}
        /// </summary>
        /// <remarks>
        /// Updates the specified vehicle using JSON merge patch format. See
        /// IETF RFC 7396: https://tools.ietf.org/html/rfc7396.
        /// </remarks>
        /// <param name='data'>
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<FleetVehicleResponse>> PatchFleetVehicleWithHttpMessagesAsync(Data data, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// /fleet/vehicles/{vehicle_id:[0-9]+}/dispatch/routes
        /// </summary>
        /// <remarks>
        /// Fetch all of the dispatch routes for a given vehicle.
        /// </remarks>
        /// <param name='vehicleId'>
        /// ID of the vehicle with the associated routes.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<IList<DispatchRoute>>> GetDispatchRoutesByVehicleIdWithHttpMessagesAsync(long vehicleId, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// /fleet/vehicles/{vehicle_id:[0-9]+}/dispatch/routes
        /// </summary>
        /// <remarks>
        /// Create a new dispatch route for the vehicle with vehicle_id.
        /// </remarks>
        /// <param name='createDispatchRouteParams'>
        /// </param>
        /// <param name='vehicleId'>
        /// ID of the vehicle with the associated routes.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<DispatchRoute>> CreateVehicleDispatchRouteWithHttpMessagesAsync(DispatchRouteCreate createDispatchRouteParams, long vehicleId, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// /fleet/vehicles/{vehicle_id:[0-9]+}/locations
        /// </summary>
        /// <remarks>
        /// Fetch locations for a given vehicle between a start/end time. The
        /// maximum query duration is one hour.
        /// </remarks>
        /// <param name='vehicleId'>
        /// ID of the vehicle with the associated routes.
        /// </param>
        /// <param name='startMs'>
        /// Time in Unix epoch milliseconds for the start of the query (cannot
        /// exceed 1 hour)
        /// </param>
        /// <param name='endMs'>
        /// Time in Unix epoch milliseconds for the end of the query (cannot
        /// exceed 1 hour)
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<IList<FleetVehicleLocation>>> GetVehicleLocationsWithHttpMessagesAsync(long vehicleId, long startMs, long endMs, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// /industrial/data
        /// </summary>
        /// <remarks>
        /// Fetch all of the data inputs for a group.
        /// </remarks>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<GetAllDataInputsOKResponse>> GetAllDataInputsWithHttpMessagesAsync(Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// /industrial/data/{data_input_id:[0-9]+}
        /// </summary>
        /// <remarks>
        /// Fetch datapoints from a given data input.
        /// </remarks>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<DataInputHistoryResponse>> GetDataInputWithHttpMessagesAsync(Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// /tags
        /// </summary>
        /// <remarks>
        /// Fetch all of the tags for a group.
        /// </remarks>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<GetAllTagsOKResponse>> GetAllTagsWithHttpMessagesAsync(Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// /tags
        /// </summary>
        /// <remarks>
        /// Create a new tag for the group.
        /// </remarks>
        /// <param name='tagCreateParams'>
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<Tag>> CreateTagWithHttpMessagesAsync(TagCreate tagCreateParams, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// /tags/{tag_id:[0-9]+}
        /// </summary>
        /// <remarks>
        /// Fetch a tag by id.
        /// </remarks>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<Tag>> GetTagByIdWithHttpMessagesAsync(Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// /tags/{tag_id:[0-9]+}
        /// </summary>
        /// <remarks>
        /// Update a tag with a new name and new members. This API call would
        /// replace all old members of a tag with new members specified in the
        /// request body. To modify only a few devices associated with a tag
        /// use the PATCH endpoint.
        /// </remarks>
        /// <param name='updateTagParams'>
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<Tag>> UpdateTagByIdWithHttpMessagesAsync(TagUpdate updateTagParams, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// /tags/{tag_id:[0-9]+}
        /// </summary>
        /// <remarks>
        /// Permanently deletes a tag.
        /// </remarks>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse> DeleteTagByIdWithHttpMessagesAsync(Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// /tags/{tag_id:[0-9]+}
        /// </summary>
        /// <remarks>
        /// Add or delete specific members from a tag, or modify the name of a
        /// tag.
        /// </remarks>
        /// <param name='tagModifyParams'>
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<Tag>> ModifyTagByIdWithHttpMessagesAsync(TagModify tagModifyParams, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// /user_roles
        /// </summary>
        /// <remarks>
        /// Get all roles in the organization.
        /// </remarks>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<IList<UserRole>>> ListUserRolesWithHttpMessagesAsync(Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// /users/{userId:[0-9]+}
        /// </summary>
        /// <remarks>
        /// Get a user.
        /// </remarks>
        /// <param name='userId'>
        /// ID of the user.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse<User>> GetUserByIdWithHttpMessagesAsync(long userId, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// /users/{userId:[0-9]+}
        /// </summary>
        /// <remarks>
        /// Remove a user from the organization.
        /// </remarks>
        /// <param name='userId'>
        /// ID of the user.
        /// </param>
        /// <param name='customHeaders'>
        /// The headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        Task<HttpOperationResponse> DeleteUserByIdWithHttpMessagesAsync(long userId, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken));

    }
}
