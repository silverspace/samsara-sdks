package

// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

import (
    "github.com/Azure/go-autorest/autorest"
    "github.com/Azure/go-autorest/autorest/azure"
    "net/http"
    "context"
    "github.com/Azure/go-autorest/tracing"
    "github.com/Azure/go-autorest/autorest/validation"
)

// GetClient is the # Introduction
//
// Samsara provides API endpoints for interacting with Samsara Cloud, so that you can build powerful applications and
// custom solutions with sensor data. Samsara has endpoints available to track and analyze sensors, vehicles, and
// entire fleets.
//
// The Samsara Cloud API is a [RESTful API](https://en.wikipedia.org/wiki/Representational_state_transfer) accessed by
// an [HTTP](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol) client such as wget or curl, or HTTP libraries
// of most modern programming languages including python, ruby, java. We use built-in HTTP features, like HTTP
// authentication and HTTP verbs, which are understood by off-the-shelf HTTP clients. We allow you to interact securely
// with our API from a client-side web application (though you should never expose your secret API key).
// [JSON](http://www.json.org/) is returned by all API responses, including errors. If you’re familiar with what you
// can build with a REST API, the following API reference guide will be your go-to resource.
//
// API access to the Samsara cloud is available to all Samsara administrators. To start developing with Samsara APIs
// you will need to [obtain your API keys](#section/Authentication) to authenticate your API requests.
//
// If you have any questions you can reach out to us on [support@samsara.com](mailto:support@samsara.com)
//
// # Endpoints
//
// All our APIs can be accessed through HTTP requests to URLs like:
//
// ```curl
// https://api.samsara.com/<version>/<endpoint>
// ```
//
// All our APIs are [versioned](#section/Versioning). If we intend to make breaking changes to an API which either
// changes the response format or request parameter, we will increment the version.
//
// # Authentication
//
// To authenticate your API request you will need to include your secret token. You can manage your API tokens in the
// [Dashboard](https://cloud.samsara.com). They are visible under `Settings->Organization->API Tokens`.
//
// Your API tokens carry many privileges, so be sure to keep them secure. Do not share your secret API tokens in
// publicly accessible areas such as GitHub, client-side code, and so on.
//
// Authentication to the API is performed via [HTTP Basic
// Auth](https://en.wikipedia.org/wiki/Basic_access_authentication). Provide your API token as the basic access_token
// value in the URL. You do not need to provide a password.
//
// ```curl
// https://api.samsara.com/<version>/<endpoint>?access_token={access_token}
// ```
//
// All API requests must be made over [HTTPS](https://en.wikipedia.org/wiki/HTTPS). Calls made over plain HTTP or
// without authentication will fail.
//
// # Request Methods
//
// Our API endpoints use [HTTP request
// methods](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Request_methods) to specify the desired operation
// to be performed. The documentation below specified request method supported by each endpoint and the resulting
// action.
//
// ## GET
//
// GET requests are typically used for fetching data (like data for a particular driver).
//
// ## POST
//
// POST requests are typically used for creating or updating a record (like adding new tags to the system). With that
// being said, a few of our POST requests can be used for fetching data (like current location data of your fleet).
//
// ## PUT
//
// PUT requests are typically used for updating an existing record (like updating all devices associated with a
// particular tag).
//
// ## PATCH
//
// PATCH requests are typically used for modifying an existing record (like modifying a few devices associated with a
// particular tag).
//
// ## DELETE
//
// DELETE requests are used for deleting a record (like deleting a tag from the system).
//
// # Response Codes
//
// All API requests will respond with appropriate [HTTP status
// code](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes). Your API client should handle each response class
// differently.
//
// ## 2XX
//
// These are successful responses and indicate that the API request returned the expected response.
//
// ## 4XX
//
// These indicate that there was a problem with the request like a missing parameter or invalid values. Check the
// response for specific [error details](#section/Error-Responses). Requests that respond with a 4XX status code,
// should be modified before retrying.
//
// ## 5XX
//
// These indicate server errors when the server is unreachable or is misconfigured. In this case, you should retry the
// API request after some delay.
//
// # Error Responses
//
// In case of a 4XX status code, the body of the response will contain information to briefly explain the error
// reported. To help debugging the error, you can refer to the following table for understanding the error message.
//
// | Status Code | Message | Description |
// |-------------|----------------|-------------------------------------------------------------------|
// | 401 | Invalid token | The API token is invalid and could not be authenticated. Please refer to the [authentication
// section](#section/Authentication). |
// | 404 | Page not found | The API endpoint being accessed is invalid. |
// | 400 | Bad request | Default response for an invalid request. Please check the request to make sure it follows the
// format specified in the documentation. |
//
// # Versioning
//
// All our APIs are versioned. Our current API version is `v1` and we are continuously working on improving it further
// and provide additional endpoints. If we intend to make breaking changes to an API which either changes the response
// format or request parameter, we will increment the version. Thus, you can use our current API version worry free.
//
// # FAQs
//
// Check out our [responses to FAQs here](https://kb.samsara.com/hc/en-us/sections/360000538054-APIs). Don’t see an
// answer to your question? Reach out to us on [support@samsara.com](mailto:support@samsara.com).
type GetClient struct {
    BaseClient
}
// NewGetClient creates an instance of the GetClient client.
func NewGetClient(accessToken string, endMs int64, startMs int64, assetID int64, endMs1 *int64, dataInputID int64, startMs1 *int64, durationMs *int64, endMs2 *int64, driverIDOrExternalID string, groupID *int64, timestamp int64, include string, sequenceID string, endingBefore string, limit *float64, startingAfter string, duration *int64, endTime *int64, endTime1 *int64, startTime *int64, endMs3 int64, startMs2 int64, tagID int64, vehicleIDOrExternalID string) GetClient {
    return NewGetClientWithBaseURI(DefaultBaseURI, accessToken, endMs, startMs, assetID, endMs1, dataInputID, startMs1, durationMs, endMs2, driverIDOrExternalID, groupID, timestamp, include, sequenceID, endingBefore, limit, startingAfter, duration, endTime, endTime1, startTime, endMs3, startMs2, tagID, vehicleIDOrExternalID)
}

// NewGetClientWithBaseURI creates an instance of the GetClient client.
    func NewGetClientWithBaseURI(baseURI string, accessToken string, endMs int64, startMs int64, assetID int64, endMs1 *int64, dataInputID int64, startMs1 *int64, durationMs *int64, endMs2 *int64, driverIDOrExternalID string, groupID *int64, timestamp int64, include string, sequenceID string, endingBefore string, limit *float64, startingAfter string, duration *int64, endTime *int64, endTime1 *int64, startTime *int64, endMs3 int64, startMs2 int64, tagID int64, vehicleIDOrExternalID string) GetClient {
        return GetClient{ NewWithBaseURI(baseURI, accessToken, endMs, startMs, assetID, endMs1, dataInputID, startMs1, durationMs, endMs2, driverIDOrExternalID, groupID, timestamp, include, sequenceID, endingBefore, limit, startingAfter, duration, endTime, endTime1, startTime, endMs3, startMs2, tagID, vehicleIDOrExternalID)}
    }

// CargoMethod get cargo monitor status (empty / full) for requested sensors.
    // Parameters:
        // sensorParam - group ID and list of sensor IDs to query.
func (client GetClient) CargoMethod(ctx context.Context, sensorParam BodyModelModelType) (result CargoResponseType, err error) {
    if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/GetClient.CargoMethod")
        defer func() {
            sc := -1
            if result.Response.Response != nil {
                sc = result.Response.Response.StatusCode
            }
            tracing.EndSpan(ctx, sc, err)
        }()
    }
            if err := validation.Validate([]validation.Validation{
            { TargetValue: sensorParam,
             Constraints: []validation.Constraint{	{Target: "sensorParam.GroupID", Name: validation.Null, Rule: true, Chain: nil },
            	{Target: "sensorParam.Sensors", Name: validation.Null, Rule: true, Chain: nil }}}}); err != nil {
            return result, validation.NewError(".GetClient", "CargoMethod", err.Error())
            }

                req, err := client.CargoMethodPreparer(ctx, sensorParam)
    if err != nil {
    err = autorest.NewErrorWithError(err, ".GetClient", "CargoMethod", nil , "Failure preparing request")
    return
    }

            resp, err := client.CargoMethodSender(req)
            if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, ".GetClient", "CargoMethod", resp, "Failure sending request")
            return
            }

            result, err = client.CargoMethodResponder(resp)
            if err != nil {
            err = autorest.NewErrorWithError(err, ".GetClient", "CargoMethod", resp, "Failure responding to request")
            }

    return
    }

    // CargoMethodPreparer prepares the CargoMethod request.
    func (client GetClient) CargoMethodPreparer(ctx context.Context, sensorParam BodyModelModelType) (*http.Request, error) {
                queryParameters := map[string]interface{} {
        "access_token": autorest.Encode("query",client.AccessToken),
        }

    preparer := autorest.CreatePreparer(
    autorest.AsContentType("application/json; charset=utf-8"),
    autorest.AsPost(),
    autorest.WithBaseURL(client.BaseURI),
    autorest.WithPath("/sensors/cargo"),
    autorest.WithJSON(sensorParam),
    autorest.WithQueryParameters(queryParameters))
    return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // CargoMethodSender sends the CargoMethod request. The method will close the
    // http.Response Body if it receives an error.
    func (client GetClient) CargoMethodSender(req *http.Request) (*http.Response, error) {
            return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
            }

// CargoMethodResponder handles the response to the CargoMethod request. The method always
// closes the http.Response Body.
func (client GetClient) CargoMethodResponder(resp *http.Response) (result CargoResponseType, err error) {
    err = autorest.Respond(
    resp,
    client.ByInspecting(),
    azure.WithErrorUnlessStatusCode(http.StatusOK),
    autorest.ByUnmarshallingJSON(&result),
    autorest.ByClosing())
    result.Response = autorest.Response{Response: resp}
        return
    }

// DoorMethod get door monitor status (closed / open) for requested sensors.
    // Parameters:
        // sensorParam - group ID and list of sensor IDs to query.
func (client GetClient) DoorMethod(ctx context.Context, sensorParam BodyModelModelType) (result DoorResponseType, err error) {
    if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/GetClient.DoorMethod")
        defer func() {
            sc := -1
            if result.Response.Response != nil {
                sc = result.Response.Response.StatusCode
            }
            tracing.EndSpan(ctx, sc, err)
        }()
    }
            if err := validation.Validate([]validation.Validation{
            { TargetValue: sensorParam,
             Constraints: []validation.Constraint{	{Target: "sensorParam.GroupID", Name: validation.Null, Rule: true, Chain: nil },
            	{Target: "sensorParam.Sensors", Name: validation.Null, Rule: true, Chain: nil }}}}); err != nil {
            return result, validation.NewError(".GetClient", "DoorMethod", err.Error())
            }

                req, err := client.DoorMethodPreparer(ctx, sensorParam)
    if err != nil {
    err = autorest.NewErrorWithError(err, ".GetClient", "DoorMethod", nil , "Failure preparing request")
    return
    }

            resp, err := client.DoorMethodSender(req)
            if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, ".GetClient", "DoorMethod", resp, "Failure sending request")
            return
            }

            result, err = client.DoorMethodResponder(resp)
            if err != nil {
            err = autorest.NewErrorWithError(err, ".GetClient", "DoorMethod", resp, "Failure responding to request")
            }

    return
    }

    // DoorMethodPreparer prepares the DoorMethod request.
    func (client GetClient) DoorMethodPreparer(ctx context.Context, sensorParam BodyModelModelType) (*http.Request, error) {
                queryParameters := map[string]interface{} {
        "access_token": autorest.Encode("query",client.AccessToken),
        }

    preparer := autorest.CreatePreparer(
    autorest.AsContentType("application/json; charset=utf-8"),
    autorest.AsPost(),
    autorest.WithBaseURL(client.BaseURI),
    autorest.WithPath("/sensors/door"),
    autorest.WithJSON(sensorParam),
    autorest.WithQueryParameters(queryParameters))
    return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // DoorMethodSender sends the DoorMethod request. The method will close the
    // http.Response Body if it receives an error.
    func (client GetClient) DoorMethodSender(req *http.Request) (*http.Response, error) {
            return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
            }

// DoorMethodResponder handles the response to the DoorMethod request. The method always
// closes the http.Response Body.
func (client GetClient) DoorMethodResponder(resp *http.Response) (result DoorResponseType, err error) {
    err = autorest.Respond(
    resp,
    client.ByInspecting(),
    azure.WithErrorUnlessStatusCode(http.StatusOK),
    autorest.ByUnmarshallingJSON(&result),
    autorest.ByClosing())
    result.Response = autorest.Response{Response: resp}
        return
    }

// DriversMethod get all the drivers for the specified group.
func (client GetClient) DriversMethod(ctx context.Context, groupDriversParam GroupDriversParamType) (result DriversResponseType, err error) {
    if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/GetClient.DriversMethod")
        defer func() {
            sc := -1
            if result.Response.Response != nil {
                sc = result.Response.Response.StatusCode
            }
            tracing.EndSpan(ctx, sc, err)
        }()
    }
            if err := validation.Validate([]validation.Validation{
            { TargetValue: groupDriversParam,
             Constraints: []validation.Constraint{	{Target: "groupDriversParam.GroupID", Name: validation.Null, Rule: true, Chain: nil }}}}); err != nil {
            return result, validation.NewError(".GetClient", "DriversMethod", err.Error())
            }

                req, err := client.DriversMethodPreparer(ctx, groupDriversParam)
    if err != nil {
    err = autorest.NewErrorWithError(err, ".GetClient", "DriversMethod", nil , "Failure preparing request")
    return
    }

            resp, err := client.DriversMethodSender(req)
            if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, ".GetClient", "DriversMethod", resp, "Failure sending request")
            return
            }

            result, err = client.DriversMethodResponder(resp)
            if err != nil {
            err = autorest.NewErrorWithError(err, ".GetClient", "DriversMethod", resp, "Failure responding to request")
            }

    return
    }

    // DriversMethodPreparer prepares the DriversMethod request.
    func (client GetClient) DriversMethodPreparer(ctx context.Context, groupDriversParam GroupDriversParamType) (*http.Request, error) {
                queryParameters := map[string]interface{} {
        "access_token": autorest.Encode("query",client.AccessToken),
        }

    preparer := autorest.CreatePreparer(
    autorest.AsContentType("application/json; charset=utf-8"),
    autorest.AsPost(),
    autorest.WithBaseURL(client.BaseURI),
    autorest.WithPath("/fleet/drivers"),
    autorest.WithJSON(groupDriversParam),
    autorest.WithQueryParameters(queryParameters))
    return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // DriversMethodSender sends the DriversMethod request. The method will close the
    // http.Response Body if it receives an error.
    func (client GetClient) DriversMethodSender(req *http.Request) (*http.Response, error) {
            return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
            }

// DriversMethodResponder handles the response to the DriversMethod request. The method always
// closes the http.Response Body.
func (client GetClient) DriversMethodResponder(resp *http.Response) (result DriversResponseType, err error) {
    err = autorest.Respond(
    resp,
    client.ByInspecting(),
    azure.WithErrorUnlessStatusCode(http.StatusOK),
    autorest.ByUnmarshallingJSON(&result),
    autorest.ByClosing())
    result.Response = autorest.Response{Response: resp}
        return
    }

// DvirsMethod get DVIRs for the org within provided time constraints
    // Parameters:
        // endMs - time in millis until the last dvir log.
        // durationMs - time in millis which corresponds to the duration before the end_ms.
        // groupID - group ID to query.
func (client GetClient) DvirsMethod(ctx context.Context, endMs int32, durationMs int32, groupID *int32) (result DvirListResponseType, err error) {
    if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/GetClient.DvirsMethod")
        defer func() {
            sc := -1
            if result.Response.Response != nil {
                sc = result.Response.Response.StatusCode
            }
            tracing.EndSpan(ctx, sc, err)
        }()
    }
        req, err := client.DvirsMethodPreparer(ctx, endMs, durationMs, groupID)
    if err != nil {
    err = autorest.NewErrorWithError(err, ".GetClient", "DvirsMethod", nil , "Failure preparing request")
    return
    }

            resp, err := client.DvirsMethodSender(req)
            if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, ".GetClient", "DvirsMethod", resp, "Failure sending request")
            return
            }

            result, err = client.DvirsMethodResponder(resp)
            if err != nil {
            err = autorest.NewErrorWithError(err, ".GetClient", "DvirsMethod", resp, "Failure responding to request")
            }

    return
    }

    // DvirsMethodPreparer prepares the DvirsMethod request.
    func (client GetClient) DvirsMethodPreparer(ctx context.Context, endMs int32, durationMs int32, groupID *int32) (*http.Request, error) {
                queryParameters := map[string]interface{} {
        "access_token": autorest.Encode("query",client.AccessToken),
        "duration_ms": autorest.Encode("query",durationMs),
        "end_ms": autorest.Encode("query",endMs),
        }
            if groupID != nil {
            queryParameters["group_id"] = autorest.Encode("query",*groupID)
            }

    preparer := autorest.CreatePreparer(
    autorest.AsGet(),
    autorest.WithBaseURL(client.BaseURI),
    autorest.WithPath("/fleet/maintenance/dvirs"),
    autorest.WithQueryParameters(queryParameters))
    return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // DvirsMethodSender sends the DvirsMethod request. The method will close the
    // http.Response Body if it receives an error.
    func (client GetClient) DvirsMethodSender(req *http.Request) (*http.Response, error) {
            return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
            }

// DvirsMethodResponder handles the response to the DvirsMethod request. The method always
// closes the http.Response Body.
func (client GetClient) DvirsMethodResponder(resp *http.Response) (result DvirListResponseType, err error) {
    err = autorest.Respond(
    resp,
    client.ByInspecting(),
    azure.WithErrorUnlessStatusCode(http.StatusOK),
    autorest.ByUnmarshallingJSON(&result),
    autorest.ByClosing())
    result.Response = autorest.Response{Response: resp}
        return
    }

// History1Method get historical data for specified sensors. This method returns a set of historical data for the
// specified sensors in the specified time range and at the specified time resolution.
    // Parameters:
        // historyParam - group ID, time range and resolution, and list of sensor ID, field pairs to query.
func (client GetClient) History1Method(ctx context.Context, historyParam HistoryParamModelType) (result SensorHistoryResponseType, err error) {
    if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/GetClient.History1Method")
        defer func() {
            sc := -1
            if result.Response.Response != nil {
                sc = result.Response.Response.StatusCode
            }
            tracing.EndSpan(ctx, sc, err)
        }()
    }
            if err := validation.Validate([]validation.Validation{
            { TargetValue: historyParam,
             Constraints: []validation.Constraint{	{Target: "historyParam.EndMs", Name: validation.Null, Rule: true, Chain: nil },
            	{Target: "historyParam.GroupID", Name: validation.Null, Rule: true, Chain: nil },
            	{Target: "historyParam.Series", Name: validation.Null, Rule: true, Chain: nil },
            	{Target: "historyParam.StartMs", Name: validation.Null, Rule: true, Chain: nil },
            	{Target: "historyParam.StepMs", Name: validation.Null, Rule: true, Chain: nil }}}}); err != nil {
            return result, validation.NewError(".GetClient", "History1Method", err.Error())
            }

                req, err := client.History1MethodPreparer(ctx, historyParam)
    if err != nil {
    err = autorest.NewErrorWithError(err, ".GetClient", "History1Method", nil , "Failure preparing request")
    return
    }

            resp, err := client.History1MethodSender(req)
            if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, ".GetClient", "History1Method", resp, "Failure sending request")
            return
            }

            result, err = client.History1MethodResponder(resp)
            if err != nil {
            err = autorest.NewErrorWithError(err, ".GetClient", "History1Method", resp, "Failure responding to request")
            }

    return
    }

    // History1MethodPreparer prepares the History1Method request.
    func (client GetClient) History1MethodPreparer(ctx context.Context, historyParam HistoryParamModelType) (*http.Request, error) {
                queryParameters := map[string]interface{} {
        "access_token": autorest.Encode("query",client.AccessToken),
        }

    preparer := autorest.CreatePreparer(
    autorest.AsContentType("application/json; charset=utf-8"),
    autorest.AsPost(),
    autorest.WithBaseURL(client.BaseURI),
    autorest.WithPath("/sensors/history"),
    autorest.WithJSON(historyParam),
    autorest.WithQueryParameters(queryParameters))
    return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // History1MethodSender sends the History1Method request. The method will close the
    // http.Response Body if it receives an error.
    func (client GetClient) History1MethodSender(req *http.Request) (*http.Response, error) {
            return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
            }

// History1MethodResponder handles the response to the History1Method request. The method always
// closes the http.Response Body.
func (client GetClient) History1MethodResponder(resp *http.Response) (result SensorHistoryResponseType, err error) {
    err = autorest.Respond(
    resp,
    client.ByInspecting(),
    azure.WithErrorUnlessStatusCode(http.StatusOK),
    autorest.ByUnmarshallingJSON(&result),
    autorest.ByClosing())
    result.Response = autorest.Response{Response: resp}
        return
    }

// HistoryMethod get historical data for machine objects. This method returns a set of historical data for all machines
// in a group
    // Parameters:
        // historyParam - group ID and time range to query for events
func (client GetClient) HistoryMethod(ctx context.Context, historyParam HistoryParamType) (result MachineHistoryResponseType, err error) {
    if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/GetClient.HistoryMethod")
        defer func() {
            sc := -1
            if result.Response.Response != nil {
                sc = result.Response.Response.StatusCode
            }
            tracing.EndSpan(ctx, sc, err)
        }()
    }
            if err := validation.Validate([]validation.Validation{
            { TargetValue: historyParam,
             Constraints: []validation.Constraint{	{Target: "historyParam.EndMs", Name: validation.Null, Rule: true, Chain: nil },
            	{Target: "historyParam.GroupID", Name: validation.Null, Rule: true, Chain: nil },
            	{Target: "historyParam.StartMs", Name: validation.Null, Rule: true, Chain: nil }}}}); err != nil {
            return result, validation.NewError(".GetClient", "HistoryMethod", err.Error())
            }

                req, err := client.HistoryMethodPreparer(ctx, historyParam)
    if err != nil {
    err = autorest.NewErrorWithError(err, ".GetClient", "HistoryMethod", nil , "Failure preparing request")
    return
    }

            resp, err := client.HistoryMethodSender(req)
            if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, ".GetClient", "HistoryMethod", resp, "Failure sending request")
            return
            }

            result, err = client.HistoryMethodResponder(resp)
            if err != nil {
            err = autorest.NewErrorWithError(err, ".GetClient", "HistoryMethod", resp, "Failure responding to request")
            }

    return
    }

    // HistoryMethodPreparer prepares the HistoryMethod request.
    func (client GetClient) HistoryMethodPreparer(ctx context.Context, historyParam HistoryParamType) (*http.Request, error) {
                queryParameters := map[string]interface{} {
        "access_token": autorest.Encode("query",client.AccessToken),
        }

    preparer := autorest.CreatePreparer(
    autorest.AsContentType("application/json; charset=utf-8"),
    autorest.AsPost(),
    autorest.WithBaseURL(client.BaseURI),
    autorest.WithPath("/machines/history"),
    autorest.WithJSON(historyParam),
    autorest.WithQueryParameters(queryParameters))
    return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // HistoryMethodSender sends the HistoryMethod request. The method will close the
    // http.Response Body if it receives an error.
    func (client GetClient) HistoryMethodSender(req *http.Request) (*http.Response, error) {
            return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
            }

// HistoryMethodResponder handles the response to the HistoryMethod request. The method always
// closes the http.Response Body.
func (client GetClient) HistoryMethodResponder(resp *http.Response) (result MachineHistoryResponseType, err error) {
    err = autorest.Respond(
    resp,
    client.ByInspecting(),
    azure.WithErrorUnlessStatusCode(http.StatusOK),
    autorest.ByUnmarshallingJSON(&result),
    autorest.ByClosing())
    result.Response = autorest.Response{Response: resp}
        return
    }

// HumidityMethod get humidity for requested sensors. This method returns the current relative humidity for the
// requested sensors.
    // Parameters:
        // sensorParam - group ID and list of sensor IDs to query.
func (client GetClient) HumidityMethod(ctx context.Context, sensorParam BodyModelModelType) (result HumidityResponseType, err error) {
    if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/GetClient.HumidityMethod")
        defer func() {
            sc := -1
            if result.Response.Response != nil {
                sc = result.Response.Response.StatusCode
            }
            tracing.EndSpan(ctx, sc, err)
        }()
    }
            if err := validation.Validate([]validation.Validation{
            { TargetValue: sensorParam,
             Constraints: []validation.Constraint{	{Target: "sensorParam.GroupID", Name: validation.Null, Rule: true, Chain: nil },
            	{Target: "sensorParam.Sensors", Name: validation.Null, Rule: true, Chain: nil }}}}); err != nil {
            return result, validation.NewError(".GetClient", "HumidityMethod", err.Error())
            }

                req, err := client.HumidityMethodPreparer(ctx, sensorParam)
    if err != nil {
    err = autorest.NewErrorWithError(err, ".GetClient", "HumidityMethod", nil , "Failure preparing request")
    return
    }

            resp, err := client.HumidityMethodSender(req)
            if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, ".GetClient", "HumidityMethod", resp, "Failure sending request")
            return
            }

            result, err = client.HumidityMethodResponder(resp)
            if err != nil {
            err = autorest.NewErrorWithError(err, ".GetClient", "HumidityMethod", resp, "Failure responding to request")
            }

    return
    }

    // HumidityMethodPreparer prepares the HumidityMethod request.
    func (client GetClient) HumidityMethodPreparer(ctx context.Context, sensorParam BodyModelModelType) (*http.Request, error) {
                queryParameters := map[string]interface{} {
        "access_token": autorest.Encode("query",client.AccessToken),
        }

    preparer := autorest.CreatePreparer(
    autorest.AsContentType("application/json; charset=utf-8"),
    autorest.AsPost(),
    autorest.WithBaseURL(client.BaseURI),
    autorest.WithPath("/sensors/humidity"),
    autorest.WithJSON(sensorParam),
    autorest.WithQueryParameters(queryParameters))
    return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // HumidityMethodSender sends the HumidityMethod request. The method will close the
    // http.Response Body if it receives an error.
    func (client GetClient) HumidityMethodSender(req *http.Request) (*http.Response, error) {
            return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
            }

// HumidityMethodResponder handles the response to the HumidityMethod request. The method always
// closes the http.Response Body.
func (client GetClient) HumidityMethodResponder(resp *http.Response) (result HumidityResponseType, err error) {
    err = autorest.Respond(
    resp,
    client.ByInspecting(),
    azure.WithErrorUnlessStatusCode(http.StatusOK),
    autorest.ByUnmarshallingJSON(&result),
    autorest.ByClosing())
    result.Response = autorest.Response{Response: resp}
        return
    }

// ListMethodMethod get list of the vehicles with any engine faults or check light data.
    // Parameters:
        // groupParam - group ID to query.
func (client GetClient) ListMethodMethod(ctx context.Context, groupParam BodyModelType) (result ListOKResponseType, err error) {
    if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/GetClient.ListMethodMethod")
        defer func() {
            sc := -1
            if result.Response.Response != nil {
                sc = result.Response.Response.StatusCode
            }
            tracing.EndSpan(ctx, sc, err)
        }()
    }
            if err := validation.Validate([]validation.Validation{
            { TargetValue: groupParam,
             Constraints: []validation.Constraint{	{Target: "groupParam.GroupID", Name: validation.Null, Rule: true, Chain: nil }}}}); err != nil {
            return result, validation.NewError(".GetClient", "ListMethodMethod", err.Error())
            }

                req, err := client.ListMethodMethodPreparer(ctx, groupParam)
    if err != nil {
    err = autorest.NewErrorWithError(err, ".GetClient", "ListMethodMethod", nil , "Failure preparing request")
    return
    }

            resp, err := client.ListMethodMethodSender(req)
            if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, ".GetClient", "ListMethodMethod", resp, "Failure sending request")
            return
            }

            result, err = client.ListMethodMethodResponder(resp)
            if err != nil {
            err = autorest.NewErrorWithError(err, ".GetClient", "ListMethodMethod", resp, "Failure responding to request")
            }

    return
    }

    // ListMethodMethodPreparer prepares the ListMethodMethod request.
    func (client GetClient) ListMethodMethodPreparer(ctx context.Context, groupParam BodyModelType) (*http.Request, error) {
                queryParameters := map[string]interface{} {
        "access_token": autorest.Encode("query",client.AccessToken),
        }

    preparer := autorest.CreatePreparer(
    autorest.AsContentType("application/json; charset=utf-8"),
    autorest.AsPost(),
    autorest.WithBaseURL(client.BaseURI),
    autorest.WithPath("/fleet/maintenance/list"),
    autorest.WithJSON(groupParam),
    autorest.WithQueryParameters(queryParameters))
    return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // ListMethodMethodSender sends the ListMethodMethod request. The method will close the
    // http.Response Body if it receives an error.
    func (client GetClient) ListMethodMethodSender(req *http.Request) (*http.Response, error) {
            return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
            }

// ListMethodMethodResponder handles the response to the ListMethodMethod request. The method always
// closes the http.Response Body.
func (client GetClient) ListMethodMethodResponder(resp *http.Response) (result ListOKResponseType, err error) {
    err = autorest.Respond(
    resp,
    client.ByInspecting(),
    azure.WithErrorUnlessStatusCode(http.StatusOK),
    autorest.ByUnmarshallingJSON(&result),
    autorest.ByClosing())
    result.Response = autorest.Response{Response: resp}
        return
    }

// LocationsMethod get current location of vehicles in a group. This method returns the current location in latitude
// and longitude of all vehicles in a requested group.
    // Parameters:
        // groupParam - group ID to query.
func (client GetClient) LocationsMethod(ctx context.Context, groupParam BodyModelType) (result LocationsOKResponseType, err error) {
    if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/GetClient.LocationsMethod")
        defer func() {
            sc := -1
            if result.Response.Response != nil {
                sc = result.Response.Response.StatusCode
            }
            tracing.EndSpan(ctx, sc, err)
        }()
    }
            if err := validation.Validate([]validation.Validation{
            { TargetValue: groupParam,
             Constraints: []validation.Constraint{	{Target: "groupParam.GroupID", Name: validation.Null, Rule: true, Chain: nil }}}}); err != nil {
            return result, validation.NewError(".GetClient", "LocationsMethod", err.Error())
            }

                req, err := client.LocationsMethodPreparer(ctx, groupParam)
    if err != nil {
    err = autorest.NewErrorWithError(err, ".GetClient", "LocationsMethod", nil , "Failure preparing request")
    return
    }

            resp, err := client.LocationsMethodSender(req)
            if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, ".GetClient", "LocationsMethod", resp, "Failure sending request")
            return
            }

            result, err = client.LocationsMethodResponder(resp)
            if err != nil {
            err = autorest.NewErrorWithError(err, ".GetClient", "LocationsMethod", resp, "Failure responding to request")
            }

    return
    }

    // LocationsMethodPreparer prepares the LocationsMethod request.
    func (client GetClient) LocationsMethodPreparer(ctx context.Context, groupParam BodyModelType) (*http.Request, error) {
                queryParameters := map[string]interface{} {
        "access_token": autorest.Encode("query",client.AccessToken),
        }

    preparer := autorest.CreatePreparer(
    autorest.AsContentType("application/json; charset=utf-8"),
    autorest.AsPost(),
    autorest.WithBaseURL(client.BaseURI),
    autorest.WithPath("/fleet/locations"),
    autorest.WithJSON(groupParam),
    autorest.WithQueryParameters(queryParameters))
    return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // LocationsMethodSender sends the LocationsMethod request. The method will close the
    // http.Response Body if it receives an error.
    func (client GetClient) LocationsMethodSender(req *http.Request) (*http.Response, error) {
            return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
            }

// LocationsMethodResponder handles the response to the LocationsMethod request. The method always
// closes the http.Response Body.
func (client GetClient) LocationsMethodResponder(resp *http.Response) (result LocationsOKResponseType, err error) {
    err = autorest.Respond(
    resp,
    client.ByInspecting(),
    azure.WithErrorUnlessStatusCode(http.StatusOK),
    autorest.ByUnmarshallingJSON(&result),
    autorest.ByClosing())
    result.Response = autorest.Response{Response: resp}
        return
    }

// Logs1Method get the HOS (hours of service) signin and signout logs for the specified driver. Only signout logs
// include location information.
func (client GetClient) Logs1Method(ctx context.Context, hosAuthenticationLogsParam HosAuthenticationLogsParamType) (result HosAuthenticationLogsResponseType, err error) {
    if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/GetClient.Logs1Method")
        defer func() {
            sc := -1
            if result.Response.Response != nil {
                sc = result.Response.Response.StatusCode
            }
            tracing.EndSpan(ctx, sc, err)
        }()
    }
            if err := validation.Validate([]validation.Validation{
            { TargetValue: hosAuthenticationLogsParam,
             Constraints: []validation.Constraint{	{Target: "hosAuthenticationLogsParam.DriverID", Name: validation.Null, Rule: true, Chain: nil },
            	{Target: "hosAuthenticationLogsParam.EndMs", Name: validation.Null, Rule: true, Chain: nil },
            	{Target: "hosAuthenticationLogsParam.GroupID", Name: validation.Null, Rule: true, Chain: nil },
            	{Target: "hosAuthenticationLogsParam.StartMs", Name: validation.Null, Rule: true, Chain: nil }}}}); err != nil {
            return result, validation.NewError(".GetClient", "Logs1Method", err.Error())
            }

                req, err := client.Logs1MethodPreparer(ctx, hosAuthenticationLogsParam)
    if err != nil {
    err = autorest.NewErrorWithError(err, ".GetClient", "Logs1Method", nil , "Failure preparing request")
    return
    }

            resp, err := client.Logs1MethodSender(req)
            if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, ".GetClient", "Logs1Method", resp, "Failure sending request")
            return
            }

            result, err = client.Logs1MethodResponder(resp)
            if err != nil {
            err = autorest.NewErrorWithError(err, ".GetClient", "Logs1Method", resp, "Failure responding to request")
            }

    return
    }

    // Logs1MethodPreparer prepares the Logs1Method request.
    func (client GetClient) Logs1MethodPreparer(ctx context.Context, hosAuthenticationLogsParam HosAuthenticationLogsParamType) (*http.Request, error) {
                queryParameters := map[string]interface{} {
        "access_token": autorest.Encode("query",client.AccessToken),
        }

    preparer := autorest.CreatePreparer(
    autorest.AsContentType("application/json; charset=utf-8"),
    autorest.AsPost(),
    autorest.WithBaseURL(client.BaseURI),
    autorest.WithPath("/fleet/hos_authentication_logs"),
    autorest.WithJSON(hosAuthenticationLogsParam),
    autorest.WithQueryParameters(queryParameters))
    return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // Logs1MethodSender sends the Logs1Method request. The method will close the
    // http.Response Body if it receives an error.
    func (client GetClient) Logs1MethodSender(req *http.Request) (*http.Response, error) {
            return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
            }

// Logs1MethodResponder handles the response to the Logs1Method request. The method always
// closes the http.Response Body.
func (client GetClient) Logs1MethodResponder(resp *http.Response) (result HosAuthenticationLogsResponseType, err error) {
    err = autorest.Respond(
    resp,
    client.ByInspecting(),
    azure.WithErrorUnlessStatusCode(http.StatusOK),
    autorest.ByUnmarshallingJSON(&result),
    autorest.ByClosing())
    result.Response = autorest.Response{Response: resp}
        return
    }

// Logs2Method get the HOS (hours of service) logs for the specified driver. This method returns all the HOS statuses
// that the driver was in during this time period.
func (client GetClient) Logs2Method(ctx context.Context, hosLogsParam BodyType) (result HosLogsResponseType, err error) {
    if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/GetClient.Logs2Method")
        defer func() {
            sc := -1
            if result.Response.Response != nil {
                sc = result.Response.Response.StatusCode
            }
            tracing.EndSpan(ctx, sc, err)
        }()
    }
            if err := validation.Validate([]validation.Validation{
            { TargetValue: hosLogsParam,
             Constraints: []validation.Constraint{	{Target: "hosLogsParam.DriverID", Name: validation.Null, Rule: true, Chain: nil },
            	{Target: "hosLogsParam.EndMs", Name: validation.Null, Rule: true, Chain: nil },
            	{Target: "hosLogsParam.GroupID", Name: validation.Null, Rule: true, Chain: nil },
            	{Target: "hosLogsParam.StartMs", Name: validation.Null, Rule: true, Chain: nil }}}}); err != nil {
            return result, validation.NewError(".GetClient", "Logs2Method", err.Error())
            }

                req, err := client.Logs2MethodPreparer(ctx, hosLogsParam)
    if err != nil {
    err = autorest.NewErrorWithError(err, ".GetClient", "Logs2Method", nil , "Failure preparing request")
    return
    }

            resp, err := client.Logs2MethodSender(req)
            if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, ".GetClient", "Logs2Method", resp, "Failure sending request")
            return
            }

            result, err = client.Logs2MethodResponder(resp)
            if err != nil {
            err = autorest.NewErrorWithError(err, ".GetClient", "Logs2Method", resp, "Failure responding to request")
            }

    return
    }

    // Logs2MethodPreparer prepares the Logs2Method request.
    func (client GetClient) Logs2MethodPreparer(ctx context.Context, hosLogsParam BodyType) (*http.Request, error) {
                queryParameters := map[string]interface{} {
        "access_token": autorest.Encode("query",client.AccessToken),
        }

    preparer := autorest.CreatePreparer(
    autorest.AsContentType("application/json; charset=utf-8"),
    autorest.AsPost(),
    autorest.WithBaseURL(client.BaseURI),
    autorest.WithPath("/fleet/hos_logs"),
    autorest.WithJSON(hosLogsParam),
    autorest.WithQueryParameters(queryParameters))
    return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // Logs2MethodSender sends the Logs2Method request. The method will close the
    // http.Response Body if it receives an error.
    func (client GetClient) Logs2MethodSender(req *http.Request) (*http.Response, error) {
            return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
            }

// Logs2MethodResponder handles the response to the Logs2Method request. The method always
// closes the http.Response Body.
func (client GetClient) Logs2MethodResponder(resp *http.Response) (result HosLogsResponseType, err error) {
    err = autorest.Respond(
    resp,
    client.ByInspecting(),
    azure.WithErrorUnlessStatusCode(http.StatusOK),
    autorest.ByUnmarshallingJSON(&result),
    autorest.ByClosing())
    result.Response = autorest.Response{Response: resp}
        return
    }

// LogsMethod get summarized daily HOS charts for a specified driver.
    // Parameters:
        // driverID - ID of the driver with HOS logs.
func (client GetClient) LogsMethod(ctx context.Context, driverID int64, hosLogsParam BodyType) (result DriverDailyLogResponseType, err error) {
    if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/GetClient.LogsMethod")
        defer func() {
            sc := -1
            if result.Response.Response != nil {
                sc = result.Response.Response.StatusCode
            }
            tracing.EndSpan(ctx, sc, err)
        }()
    }
            if err := validation.Validate([]validation.Validation{
            { TargetValue: hosLogsParam,
             Constraints: []validation.Constraint{	{Target: "hosLogsParam.DriverID", Name: validation.Null, Rule: true, Chain: nil },
            	{Target: "hosLogsParam.EndMs", Name: validation.Null, Rule: true, Chain: nil },
            	{Target: "hosLogsParam.GroupID", Name: validation.Null, Rule: true, Chain: nil },
            	{Target: "hosLogsParam.StartMs", Name: validation.Null, Rule: true, Chain: nil }}}}); err != nil {
            return result, validation.NewError(".GetClient", "LogsMethod", err.Error())
            }

                req, err := client.LogsMethodPreparer(ctx, driverID, hosLogsParam)
    if err != nil {
    err = autorest.NewErrorWithError(err, ".GetClient", "LogsMethod", nil , "Failure preparing request")
    return
    }

            resp, err := client.LogsMethodSender(req)
            if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, ".GetClient", "LogsMethod", resp, "Failure sending request")
            return
            }

            result, err = client.LogsMethodResponder(resp)
            if err != nil {
            err = autorest.NewErrorWithError(err, ".GetClient", "LogsMethod", resp, "Failure responding to request")
            }

    return
    }

    // LogsMethodPreparer prepares the LogsMethod request.
    func (client GetClient) LogsMethodPreparer(ctx context.Context, driverID int64, hosLogsParam BodyType) (*http.Request, error) {
            pathParameters := map[string]interface{} {
            "driver_id": autorest.Encode("path",driverID),
            }

                    queryParameters := map[string]interface{} {
        "access_token": autorest.Encode("query",client.AccessToken),
        }

    preparer := autorest.CreatePreparer(
    autorest.AsContentType("application/json; charset=utf-8"),
    autorest.AsPost(),
    autorest.WithBaseURL(client.BaseURI),
    autorest.WithPathParameters("/fleet/drivers/{driver_id}/hos_daily_logs",pathParameters),
    autorest.WithJSON(hosLogsParam),
    autorest.WithQueryParameters(queryParameters))
    return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // LogsMethodSender sends the LogsMethod request. The method will close the
    // http.Response Body if it receives an error.
    func (client GetClient) LogsMethodSender(req *http.Request) (*http.Response, error) {
            return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
            }

// LogsMethodResponder handles the response to the LogsMethod request. The method always
// closes the http.Response Body.
func (client GetClient) LogsMethodResponder(resp *http.Response) (result DriverDailyLogResponseType, err error) {
    err = autorest.Respond(
    resp,
    client.ByInspecting(),
    azure.WithErrorUnlessStatusCode(http.StatusOK),
    autorest.ByUnmarshallingJSON(&result),
    autorest.ByClosing())
    result.Response = autorest.Response{Response: resp}
        return
    }

// MachinesMethod get machine objects. This method returns a list of the machine objects in the Samsara Cloud and
// information about them.
    // Parameters:
        // groupParam - group ID to query.
func (client GetClient) MachinesMethod(ctx context.Context, groupParam BodyModelType) (result MachinesOKResponseType, err error) {
    if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/GetClient.MachinesMethod")
        defer func() {
            sc := -1
            if result.Response.Response != nil {
                sc = result.Response.Response.StatusCode
            }
            tracing.EndSpan(ctx, sc, err)
        }()
    }
            if err := validation.Validate([]validation.Validation{
            { TargetValue: groupParam,
             Constraints: []validation.Constraint{	{Target: "groupParam.GroupID", Name: validation.Null, Rule: true, Chain: nil }}}}); err != nil {
            return result, validation.NewError(".GetClient", "MachinesMethod", err.Error())
            }

                req, err := client.MachinesMethodPreparer(ctx, groupParam)
    if err != nil {
    err = autorest.NewErrorWithError(err, ".GetClient", "MachinesMethod", nil , "Failure preparing request")
    return
    }

            resp, err := client.MachinesMethodSender(req)
            if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, ".GetClient", "MachinesMethod", resp, "Failure sending request")
            return
            }

            result, err = client.MachinesMethodResponder(resp)
            if err != nil {
            err = autorest.NewErrorWithError(err, ".GetClient", "MachinesMethod", resp, "Failure responding to request")
            }

    return
    }

    // MachinesMethodPreparer prepares the MachinesMethod request.
    func (client GetClient) MachinesMethodPreparer(ctx context.Context, groupParam BodyModelType) (*http.Request, error) {
                queryParameters := map[string]interface{} {
        "access_token": autorest.Encode("query",client.AccessToken),
        }

    preparer := autorest.CreatePreparer(
    autorest.AsContentType("application/json; charset=utf-8"),
    autorest.AsPost(),
    autorest.WithBaseURL(client.BaseURI),
    autorest.WithPath("/machines/list"),
    autorest.WithJSON(groupParam),
    autorest.WithQueryParameters(queryParameters))
    return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // MachinesMethodSender sends the MachinesMethod request. The method will close the
    // http.Response Body if it receives an error.
    func (client GetClient) MachinesMethodSender(req *http.Request) (*http.Response, error) {
            return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
            }

// MachinesMethodResponder handles the response to the MachinesMethod request. The method always
// closes the http.Response Body.
func (client GetClient) MachinesMethodResponder(resp *http.Response) (result MachinesOKResponseType, err error) {
    err = autorest.Respond(
    resp,
    client.ByInspecting(),
    azure.WithErrorUnlessStatusCode(http.StatusOK),
    autorest.ByUnmarshallingJSON(&result),
    autorest.ByClosing())
    result.Response = autorest.Response{Response: resp}
        return
    }

// SensorsMethod get sensor objects. This method returns a list of the sensor objects in the Samsara Cloud and
// information about them.
    // Parameters:
        // groupParam - group ID to query.
func (client GetClient) SensorsMethod(ctx context.Context, groupParam BodyModelType) (result SensorsOKResponseType, err error) {
    if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/GetClient.SensorsMethod")
        defer func() {
            sc := -1
            if result.Response.Response != nil {
                sc = result.Response.Response.StatusCode
            }
            tracing.EndSpan(ctx, sc, err)
        }()
    }
            if err := validation.Validate([]validation.Validation{
            { TargetValue: groupParam,
             Constraints: []validation.Constraint{	{Target: "groupParam.GroupID", Name: validation.Null, Rule: true, Chain: nil }}}}); err != nil {
            return result, validation.NewError(".GetClient", "SensorsMethod", err.Error())
            }

                req, err := client.SensorsMethodPreparer(ctx, groupParam)
    if err != nil {
    err = autorest.NewErrorWithError(err, ".GetClient", "SensorsMethod", nil , "Failure preparing request")
    return
    }

            resp, err := client.SensorsMethodSender(req)
            if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, ".GetClient", "SensorsMethod", resp, "Failure sending request")
            return
            }

            result, err = client.SensorsMethodResponder(resp)
            if err != nil {
            err = autorest.NewErrorWithError(err, ".GetClient", "SensorsMethod", resp, "Failure responding to request")
            }

    return
    }

    // SensorsMethodPreparer prepares the SensorsMethod request.
    func (client GetClient) SensorsMethodPreparer(ctx context.Context, groupParam BodyModelType) (*http.Request, error) {
                queryParameters := map[string]interface{} {
        "access_token": autorest.Encode("query",client.AccessToken),
        }

    preparer := autorest.CreatePreparer(
    autorest.AsContentType("application/json; charset=utf-8"),
    autorest.AsPost(),
    autorest.WithBaseURL(client.BaseURI),
    autorest.WithPath("/sensors/list"),
    autorest.WithJSON(groupParam),
    autorest.WithQueryParameters(queryParameters))
    return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // SensorsMethodSender sends the SensorsMethod request. The method will close the
    // http.Response Body if it receives an error.
    func (client GetClient) SensorsMethodSender(req *http.Request) (*http.Response, error) {
            return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
            }

// SensorsMethodResponder handles the response to the SensorsMethod request. The method always
// closes the http.Response Body.
func (client GetClient) SensorsMethodResponder(resp *http.Response) (result SensorsOKResponseType, err error) {
    err = autorest.Respond(
    resp,
    client.ByInspecting(),
    azure.WithErrorUnlessStatusCode(http.StatusOK),
    autorest.ByUnmarshallingJSON(&result),
    autorest.ByClosing())
    result.Response = autorest.Response{Response: resp}
        return
    }

// Summary1Method get the current HOS status for all drivers in the group.
func (client GetClient) Summary1Method(ctx context.Context, hosLogsParam HosLogsParamType) (result HosLogsSummaryResponseType, err error) {
    if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/GetClient.Summary1Method")
        defer func() {
            sc := -1
            if result.Response.Response != nil {
                sc = result.Response.Response.StatusCode
            }
            tracing.EndSpan(ctx, sc, err)
        }()
    }
            if err := validation.Validate([]validation.Validation{
            { TargetValue: hosLogsParam,
             Constraints: []validation.Constraint{	{Target: "hosLogsParam.GroupID", Name: validation.Null, Rule: true, Chain: nil }}}}); err != nil {
            return result, validation.NewError(".GetClient", "Summary1Method", err.Error())
            }

                req, err := client.Summary1MethodPreparer(ctx, hosLogsParam)
    if err != nil {
    err = autorest.NewErrorWithError(err, ".GetClient", "Summary1Method", nil , "Failure preparing request")
    return
    }

            resp, err := client.Summary1MethodSender(req)
            if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, ".GetClient", "Summary1Method", resp, "Failure sending request")
            return
            }

            result, err = client.Summary1MethodResponder(resp)
            if err != nil {
            err = autorest.NewErrorWithError(err, ".GetClient", "Summary1Method", resp, "Failure responding to request")
            }

    return
    }

    // Summary1MethodPreparer prepares the Summary1Method request.
    func (client GetClient) Summary1MethodPreparer(ctx context.Context, hosLogsParam HosLogsParamType) (*http.Request, error) {
                queryParameters := map[string]interface{} {
        "access_token": autorest.Encode("query",client.AccessToken),
        }

    preparer := autorest.CreatePreparer(
    autorest.AsContentType("application/json; charset=utf-8"),
    autorest.AsPost(),
    autorest.WithBaseURL(client.BaseURI),
    autorest.WithPath("/fleet/hos_logs_summary"),
    autorest.WithJSON(hosLogsParam),
    autorest.WithQueryParameters(queryParameters))
    return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // Summary1MethodSender sends the Summary1Method request. The method will close the
    // http.Response Body if it receives an error.
    func (client GetClient) Summary1MethodSender(req *http.Request) (*http.Response, error) {
            return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
            }

// Summary1MethodResponder handles the response to the Summary1Method request. The method always
// closes the http.Response Body.
func (client GetClient) Summary1MethodResponder(resp *http.Response) (result HosLogsSummaryResponseType, err error) {
    err = autorest.Respond(
    resp,
    client.ByInspecting(),
    azure.WithErrorUnlessStatusCode(http.StatusOK),
    autorest.ByUnmarshallingJSON(&result),
    autorest.ByClosing())
    result.Response = autorest.Response{Response: resp}
        return
    }

// SummaryMethod get the distance and time each driver in an organization has driven in a given time period.
    // Parameters:
        // driversSummaryParam - org ID and time range to query.
        // snapToDayBounds - snap query result to HOS day boundaries.
func (client GetClient) SummaryMethod(ctx context.Context, driversSummaryParam DriversSummaryParamType, snapToDayBounds *bool) (result DriversSummaryResponseType, err error) {
    if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/GetClient.SummaryMethod")
        defer func() {
            sc := -1
            if result.Response.Response != nil {
                sc = result.Response.Response.StatusCode
            }
            tracing.EndSpan(ctx, sc, err)
        }()
    }
            if err := validation.Validate([]validation.Validation{
            { TargetValue: driversSummaryParam,
             Constraints: []validation.Constraint{	{Target: "driversSummaryParam.EndMs", Name: validation.Null, Rule: true, Chain: nil },
            	{Target: "driversSummaryParam.OrgID", Name: validation.Null, Rule: true, Chain: nil },
            	{Target: "driversSummaryParam.StartMs", Name: validation.Null, Rule: true, Chain: nil }}}}); err != nil {
            return result, validation.NewError(".GetClient", "SummaryMethod", err.Error())
            }

                req, err := client.SummaryMethodPreparer(ctx, driversSummaryParam, snapToDayBounds)
    if err != nil {
    err = autorest.NewErrorWithError(err, ".GetClient", "SummaryMethod", nil , "Failure preparing request")
    return
    }

            resp, err := client.SummaryMethodSender(req)
            if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, ".GetClient", "SummaryMethod", resp, "Failure sending request")
            return
            }

            result, err = client.SummaryMethodResponder(resp)
            if err != nil {
            err = autorest.NewErrorWithError(err, ".GetClient", "SummaryMethod", resp, "Failure responding to request")
            }

    return
    }

    // SummaryMethodPreparer prepares the SummaryMethod request.
    func (client GetClient) SummaryMethodPreparer(ctx context.Context, driversSummaryParam DriversSummaryParamType, snapToDayBounds *bool) (*http.Request, error) {
                queryParameters := map[string]interface{} {
        "access_token": autorest.Encode("query",client.AccessToken),
        }
            if snapToDayBounds != nil {
            queryParameters["snap_to_day_bounds"] = autorest.Encode("query",*snapToDayBounds)
            }

    preparer := autorest.CreatePreparer(
    autorest.AsContentType("application/json; charset=utf-8"),
    autorest.AsPost(),
    autorest.WithBaseURL(client.BaseURI),
    autorest.WithPath("/fleet/drivers/summary"),
    autorest.WithJSON(driversSummaryParam),
    autorest.WithQueryParameters(queryParameters))
    return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // SummaryMethodSender sends the SummaryMethod request. The method will close the
    // http.Response Body if it receives an error.
    func (client GetClient) SummaryMethodSender(req *http.Request) (*http.Response, error) {
            return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
            }

// SummaryMethodResponder handles the response to the SummaryMethod request. The method always
// closes the http.Response Body.
func (client GetClient) SummaryMethodResponder(resp *http.Response) (result DriversSummaryResponseType, err error) {
    err = autorest.Respond(
    resp,
    client.ByInspecting(),
    azure.WithErrorUnlessStatusCode(http.StatusOK),
    autorest.ByUnmarshallingJSON(&result),
    autorest.ByClosing())
    result.Response = autorest.Response{Response: resp}
        return
    }

// TemperatureMethod get temperature for requested sensors. This method returns the current ambient temperature (and
// probe temperature if applicable) for the requested sensors.
    // Parameters:
        // sensorParam - group ID and list of sensor IDs to query.
func (client GetClient) TemperatureMethod(ctx context.Context, sensorParam BodyModelModelType) (result TemperatureResponseType, err error) {
    if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/GetClient.TemperatureMethod")
        defer func() {
            sc := -1
            if result.Response.Response != nil {
                sc = result.Response.Response.StatusCode
            }
            tracing.EndSpan(ctx, sc, err)
        }()
    }
            if err := validation.Validate([]validation.Validation{
            { TargetValue: sensorParam,
             Constraints: []validation.Constraint{	{Target: "sensorParam.GroupID", Name: validation.Null, Rule: true, Chain: nil },
            	{Target: "sensorParam.Sensors", Name: validation.Null, Rule: true, Chain: nil }}}}); err != nil {
            return result, validation.NewError(".GetClient", "TemperatureMethod", err.Error())
            }

                req, err := client.TemperatureMethodPreparer(ctx, sensorParam)
    if err != nil {
    err = autorest.NewErrorWithError(err, ".GetClient", "TemperatureMethod", nil , "Failure preparing request")
    return
    }

            resp, err := client.TemperatureMethodSender(req)
            if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, ".GetClient", "TemperatureMethod", resp, "Failure sending request")
            return
            }

            result, err = client.TemperatureMethodResponder(resp)
            if err != nil {
            err = autorest.NewErrorWithError(err, ".GetClient", "TemperatureMethod", resp, "Failure responding to request")
            }

    return
    }

    // TemperatureMethodPreparer prepares the TemperatureMethod request.
    func (client GetClient) TemperatureMethodPreparer(ctx context.Context, sensorParam BodyModelModelType) (*http.Request, error) {
                queryParameters := map[string]interface{} {
        "access_token": autorest.Encode("query",client.AccessToken),
        }

    preparer := autorest.CreatePreparer(
    autorest.AsContentType("application/json; charset=utf-8"),
    autorest.AsPost(),
    autorest.WithBaseURL(client.BaseURI),
    autorest.WithPath("/sensors/temperature"),
    autorest.WithJSON(sensorParam),
    autorest.WithQueryParameters(queryParameters))
    return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // TemperatureMethodSender sends the TemperatureMethod request. The method will close the
    // http.Response Body if it receives an error.
    func (client GetClient) TemperatureMethodSender(req *http.Request) (*http.Response, error) {
            return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
            }

// TemperatureMethodResponder handles the response to the TemperatureMethod request. The method always
// closes the http.Response Body.
func (client GetClient) TemperatureMethodResponder(resp *http.Response) (result TemperatureResponseType, err error) {
    err = autorest.Respond(
    resp,
    client.ByInspecting(),
    azure.WithErrorUnlessStatusCode(http.StatusOK),
    autorest.ByUnmarshallingJSON(&result),
    autorest.ByClosing())
    result.Response = autorest.Response{Response: resp}
        return
    }

// TripsMethod get historical trips data for specified vehicle. This method returns a set of historical trips data for
// the specified vehicle in the specified time range.
    // Parameters:
        // tripsParam - group ID, vehicle ID and time range to query.
func (client GetClient) TripsMethod(ctx context.Context, tripsParam TripsParamType) (result TripResponseType, err error) {
    if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/GetClient.TripsMethod")
        defer func() {
            sc := -1
            if result.Response.Response != nil {
                sc = result.Response.Response.StatusCode
            }
            tracing.EndSpan(ctx, sc, err)
        }()
    }
            if err := validation.Validate([]validation.Validation{
            { TargetValue: tripsParam,
             Constraints: []validation.Constraint{	{Target: "tripsParam.EndMs", Name: validation.Null, Rule: true, Chain: nil },
            	{Target: "tripsParam.GroupID", Name: validation.Null, Rule: true, Chain: nil },
            	{Target: "tripsParam.StartMs", Name: validation.Null, Rule: true, Chain: nil },
            	{Target: "tripsParam.VehicleID", Name: validation.Null, Rule: true, Chain: nil }}}}); err != nil {
            return result, validation.NewError(".GetClient", "TripsMethod", err.Error())
            }

                req, err := client.TripsMethodPreparer(ctx, tripsParam)
    if err != nil {
    err = autorest.NewErrorWithError(err, ".GetClient", "TripsMethod", nil , "Failure preparing request")
    return
    }

            resp, err := client.TripsMethodSender(req)
            if err != nil {
            result.Response = autorest.Response{Response: resp}
            err = autorest.NewErrorWithError(err, ".GetClient", "TripsMethod", resp, "Failure sending request")
            return
            }

            result, err = client.TripsMethodResponder(resp)
            if err != nil {
            err = autorest.NewErrorWithError(err, ".GetClient", "TripsMethod", resp, "Failure responding to request")
            }

    return
    }

    // TripsMethodPreparer prepares the TripsMethod request.
    func (client GetClient) TripsMethodPreparer(ctx context.Context, tripsParam TripsParamType) (*http.Request, error) {
                queryParameters := map[string]interface{} {
        "access_token": autorest.Encode("query",client.AccessToken),
        }

    preparer := autorest.CreatePreparer(
    autorest.AsContentType("application/json; charset=utf-8"),
    autorest.AsPost(),
    autorest.WithBaseURL(client.BaseURI),
    autorest.WithPath("/fleet/trips"),
    autorest.WithJSON(tripsParam),
    autorest.WithQueryParameters(queryParameters))
    return preparer.Prepare((&http.Request{}).WithContext(ctx))
    }

    // TripsMethodSender sends the TripsMethod request. The method will close the
    // http.Response Body if it receives an error.
    func (client GetClient) TripsMethodSender(req *http.Request) (*http.Response, error) {
            return autorest.SendWithSender(client, req,
            autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
            }

// TripsMethodResponder handles the response to the TripsMethod request. The method always
// closes the http.Response Body.
func (client GetClient) TripsMethodResponder(resp *http.Response) (result TripResponseType, err error) {
    err = autorest.Respond(
    resp,
    client.ByInspecting(),
    azure.WithErrorUnlessStatusCode(http.StatusOK),
    autorest.ByUnmarshallingJSON(&result),
    autorest.ByClosing())
    result.Response = autorest.Response{Response: resp}
        return
    }

