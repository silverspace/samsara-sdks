# coding=utf-8
# --------------------------------------------------------------------------
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is
# regenerated.
# --------------------------------------------------------------------------

from msrest.service_client import ServiceClient
from msrest import Configuration, Serializer, Deserializer
from .version import VERSION
from msrest.pipeline import ClientRawResponse
from .operations.add_operations import AddOperations
from .operations.get_operations import GetOperations
from .operations.list_operations import ListOperations
from .operations.create_operations import CreateOperations
from .operations.update_operations import UpdateOperations
from . import models


class SamsaraAPIConfiguration(Configuration):
    """Configuration for SamsaraAPI
    Note that all parameters used to create this instance are saved as instance
    attributes.

    :param access_token: Samsara API access token.
    :type access_token: str
    :param end_ms: Timestamp in milliseconds representing the end of the
     period to fetch, inclusive. Used in combination with startMs.
    :type end_ms: long
    :param start_ms: Timestamp in milliseconds representing the start of the
     period to fetch, inclusive. Used in combination with endMs.
    :type start_ms: long
    :param asset_id: ID of the asset
    :type asset_id: long
    :param end_ms1: Timestamp in unix milliseconds representing the end of the
     period to fetch, inclusive. Used in combination with startMs. Defaults to
     nowMs.
    :type end_ms1: long
    :param data_input_id: ID of the data input
    :type data_input_id: long
    :param start_ms1: Timestamp in unix milliseconds representing the start of
     the period to fetch, inclusive. Used in combination with endMs. defaults
     to nowMs.
    :type start_ms1: long
    :param duration_ms: Time in milliseconds that represents the duration
     before endMs to query. Defaults to 24 hours.
    :type duration_ms: long
    :param end_ms2: Time in unix milliseconds that represents the oldest
     documents to return. Used in combination with durationMs. Defaults to now.
    :type end_ms2: long
    :param driver_id_or_external_id: ID of the driver.  This must be either
     the numeric ID generated by Samsara or the external ID of the driver.
     External IDs are customer specified key-value pairs.
    :type driver_id_or_external_id: str
    :param group_id: Optional group ID if the organization has multiple groups
     (uncommon).
    :type group_id: long
    :param timestamp: Timestamp in milliseconds representing the timestamp of
     a harsh event.
    :type timestamp: long
    :param include: Optionally set include=route to include route object in
     response payload.
    :type include: str
    :param sequence_id: Sequence ID from the response payload of the last
     request. Defaults to fetching updates from last 24 hours.
    :type sequence_id: str
    :param ending_before: Pagination parameter indicating the cursor position
     to return results before. Used in conjunction with the 'limit' parameter.
     Mutually exclusive with 'startingAfter' parameter.
    :type ending_before: str
    :param limit: Pagination parameter indicating the number of results to
     return in this request. Used in conjunction with either 'startingAfter' or
     'endingBefore'.
    :type limit: float
    :param starting_after: Pagination parameter indicating the cursor position
     to continue returning results after. Used in conjunction with the 'limit'
     parameter. Mutually exclusive with 'endingBefore' parameter.
    :type starting_after: str
    :param duration: Time in milliseconds that represents the duration before
     end_time to query. Defaults to 24 hours.
    :type duration: long
    :param end_time: Time in unix milliseconds that represents the oldest
     routes to return. Used in combination with duration. Defaults to now.
    :type end_time: long
    :param end_time1: Timestamp representing the end of the period to fetch,
     inclusive. Used in combination with start_time. Defaults to nowMs.
    :type end_time1: long
    :param start_time: Timestamp representing the start of the period to
     fetch, inclusive. Used in combination with end_time. Defaults to 0.
    :type start_time: long
    :param end_ms3: Timestamp in milliseconds representing the end of the
     period to fetch, inclusive. Used in combination with startMs.
    :type end_ms3: long
    :param start_ms2: Timestamp in milliseconds representing the start of the
     period to fetch, inclusive. Used in combination with endMs.
    :type start_ms2: long
    :param tag_id: ID of the tag.
    :type tag_id: long
    :param vehicle_id_or_external_id: ID of the vehicle.  This must be either
     the numeric ID generated by Samsara or the external ID of the vehicle.
     External IDs are customer specified key-value pairs.
    :type vehicle_id_or_external_id: str
    :param str base_url: Service URL
    """

    def __init__(
            self, access_token, end_ms, start_ms, asset_id, data_input_id, driver_id_or_external_id, timestamp, end_ms3, start_ms2, tag_id, vehicle_id_or_external_id, end_ms1=None, start_ms1=None, duration_ms=None, end_ms2=None, group_id=None, include=None, sequence_id=None, ending_before=None, limit=None, starting_after=None, duration=None, end_time=None, end_time1=None, start_time=None, base_url=None):

        if access_token is None:
            raise ValueError("Parameter 'access_token' must not be None.")
        if end_ms is None:
            raise ValueError("Parameter 'end_ms' must not be None.")
        if start_ms is None:
            raise ValueError("Parameter 'start_ms' must not be None.")
        if asset_id is None:
            raise ValueError("Parameter 'asset_id' must not be None.")
        if data_input_id is None:
            raise ValueError("Parameter 'data_input_id' must not be None.")
        if driver_id_or_external_id is None:
            raise ValueError("Parameter 'driver_id_or_external_id' must not be None.")
        if timestamp is None:
            raise ValueError("Parameter 'timestamp' must not be None.")
        if end_ms3 is None:
            raise ValueError("Parameter 'end_ms3' must not be None.")
        if start_ms2 is None:
            raise ValueError("Parameter 'start_ms2' must not be None.")
        if tag_id is None:
            raise ValueError("Parameter 'tag_id' must not be None.")
        if vehicle_id_or_external_id is None:
            raise ValueError("Parameter 'vehicle_id_or_external_id' must not be None.")
        if not base_url:
            base_url = 'https://api.samsara.com/v1'

        super(SamsaraAPIConfiguration, self).__init__(base_url)

        self.add_user_agent('samsaraapi/{}'.format(VERSION))

        self.access_token = access_token
        self.end_ms = end_ms
        self.start_ms = start_ms
        self.asset_id = asset_id
        self.end_ms1 = end_ms1
        self.data_input_id = data_input_id
        self.start_ms1 = start_ms1
        self.duration_ms = duration_ms
        self.end_ms2 = end_ms2
        self.driver_id_or_external_id = driver_id_or_external_id
        self.group_id = group_id
        self.timestamp = timestamp
        self.include = include
        self.sequence_id = sequence_id
        self.ending_before = ending_before
        self.limit = limit
        self.starting_after = starting_after
        self.duration = duration
        self.end_time = end_time
        self.end_time1 = end_time1
        self.start_time = start_time
        self.end_ms3 = end_ms3
        self.start_ms2 = start_ms2
        self.tag_id = tag_id
        self.vehicle_id_or_external_id = vehicle_id_or_external_id


class SamsaraAPI(object):
    """# Introduction
    Samsara provides API endpoints for interacting with Samsara Cloud, so that you can build powerful applications and custom solutions with sensor data. Samsara has endpoints available to track and analyze sensors, vehicles, and entire fleets.
    The Samsara Cloud API is a [RESTful API](https://en.wikipedia.org/wiki/Representational_state_transfer) accessed by an [HTTP](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol) client such as wget or curl, or HTTP libraries of most modern programming languages including python, ruby, java. We use built-in HTTP features, like HTTP authentication and HTTP verbs, which are understood by off-the-shelf HTTP clients. We allow you to interact securely with our API from a client-side web application (though you should never expose your secret API key). [JSON](http://www.json.org/) is returned by all API responses, including errors. If youâ€™re familiar with what you can build with a REST API, the following API reference guide will be your go-to resource.
    API access to the Samsara cloud is available to all Samsara administrators. To start developing with Samsara APIs you will need to [obtain your API keys](#section/Authentication) to authenticate your API requests.
    If you have any questions you can reach out to us on [support@samsara.com](mailto:support@samsara.com)
    # Endpoints
    All our APIs can be accessed through HTTP requests to URLs like:
    ```curl
    https://api.samsara.com/&lt;version&gt;/&lt;endpoint&gt;
    ```
    All our APIs are [versioned](#section/Versioning). If we intend to make breaking changes to an API which either changes the response format or request parameter, we will increment the version.
    # Authentication
    To authenticate your API request you will need to include your secret token. You can manage your API tokens in the [Dashboard](https://cloud.samsara.com). They are visible under `Settings-&gt;Organization-&gt;API Tokens`.
    Your API tokens carry many privileges, so be sure to keep them secure. Do not share your secret API tokens in publicly accessible areas such as GitHub, client-side code, and so on.
    Authentication to the API is performed via [HTTP Basic Auth](https://en.wikipedia.org/wiki/Basic_access_authentication). Provide your API token as the basic access_token value in the URL. You do not need to provide a password.
    ```curl
    https://api.samsara.com/&lt;version&gt;/&lt;endpoint&gt;?access_token={access_token}
    ```
    All API requests must be made over [HTTPS](https://en.wikipedia.org/wiki/HTTPS). Calls made over plain HTTP or without authentication will fail.
    # Request Methods
    Our API endpoints use [HTTP request methods](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Request_methods) to specify the desired operation to be performed. The documentation below specified request method supported by each endpoint and the resulting action.
    ## GET
    GET requests are typically used for fetching data (like data for a particular driver).
    ## POST
    POST requests are typically used for creating or updating a record (like adding new tags to the system). With that being said, a few of our POST requests can be used for fetching data (like current location data of your fleet).
    ## PUT
    PUT requests are typically used for updating an existing record (like updating all devices associated with a particular tag).
    ## PATCH
    PATCH requests are typically used for modifying an existing record (like modifying a few devices associated with a particular tag).
    ## DELETE
    DELETE requests are used for deleting a record (like deleting a tag from the system).
    # Response Codes
    All API requests will respond with appropriate [HTTP status code](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes). Your API client should handle each response class differently.
    ## 2XX
    These are successful responses and indicate that the API request returned the expected response.
    ## 4XX
    These indicate that there was a problem with the request like a missing parameter or invalid values. Check the response for specific [error details](#section/Error-Responses). Requests that respond with a 4XX status code, should be modified before retrying.
    ## 5XX
    These indicate server errors when the server is unreachable or is misconfigured. In this case, you should retry the API request after some delay.
    # Error Responses
    In case of a 4XX status code, the body of the response will contain information to briefly explain the error reported. To help debugging the error, you can refer to the following table for understanding the error message.
    | Status Code | Message | Description |
    |-------------|----------------|-------------------------------------------------------------------|
    | 401 | Invalid token | The API token is invalid and could not be authenticated. Please refer to the [authentication section](#section/Authentication). |
    | 404 | Page not found | The API endpoint being accessed is invalid. |
    | 400 | Bad request | Default response for an invalid request. Please check the request to make sure it follows the format specified in the documentation. |
    # Versioning
    All our APIs are versioned. Our current API version is `v1` and we are continuously working on improving it further and provide additional endpoints. If we intend to make breaking changes to an API which either changes the response format or request parameter, we will increment the version. Thus, you can use our current API version worry free.
    # FAQs
    Check out our [responses to FAQs here](https://kb.samsara.com/hc/en-us/sections/360000538054-APIs). Donâ€™t see an answer to your question? Reach out to us on [support@samsara.com](mailto:support@samsara.com).

    :ivar config: Configuration for client.
    :vartype config: SamsaraAPIConfiguration

    :ivar add: Add operations
    :vartype add: swagger.operations.AddOperations
    :ivar get: Get operations
    :vartype get: swagger.operations.GetOperations
    :ivar list: List operations
    :vartype list: swagger.operations.ListOperations
    :ivar create: Create operations
    :vartype create: swagger.operations.CreateOperations
    :ivar update: Update operations
    :vartype update: swagger.operations.UpdateOperations

    :param access_token: Samsara API access token.
    :type access_token: str
    :param end_ms: Timestamp in milliseconds representing the end of the
     period to fetch, inclusive. Used in combination with startMs.
    :type end_ms: long
    :param start_ms: Timestamp in milliseconds representing the start of the
     period to fetch, inclusive. Used in combination with endMs.
    :type start_ms: long
    :param asset_id: ID of the asset
    :type asset_id: long
    :param end_ms1: Timestamp in unix milliseconds representing the end of the
     period to fetch, inclusive. Used in combination with startMs. Defaults to
     nowMs.
    :type end_ms1: long
    :param data_input_id: ID of the data input
    :type data_input_id: long
    :param start_ms1: Timestamp in unix milliseconds representing the start of
     the period to fetch, inclusive. Used in combination with endMs. defaults
     to nowMs.
    :type start_ms1: long
    :param duration_ms: Time in milliseconds that represents the duration
     before endMs to query. Defaults to 24 hours.
    :type duration_ms: long
    :param end_ms2: Time in unix milliseconds that represents the oldest
     documents to return. Used in combination with durationMs. Defaults to now.
    :type end_ms2: long
    :param driver_id_or_external_id: ID of the driver.  This must be either
     the numeric ID generated by Samsara or the external ID of the driver.
     External IDs are customer specified key-value pairs.
    :type driver_id_or_external_id: str
    :param group_id: Optional group ID if the organization has multiple groups
     (uncommon).
    :type group_id: long
    :param timestamp: Timestamp in milliseconds representing the timestamp of
     a harsh event.
    :type timestamp: long
    :param include: Optionally set include=route to include route object in
     response payload.
    :type include: str
    :param sequence_id: Sequence ID from the response payload of the last
     request. Defaults to fetching updates from last 24 hours.
    :type sequence_id: str
    :param ending_before: Pagination parameter indicating the cursor position
     to return results before. Used in conjunction with the 'limit' parameter.
     Mutually exclusive with 'startingAfter' parameter.
    :type ending_before: str
    :param limit: Pagination parameter indicating the number of results to
     return in this request. Used in conjunction with either 'startingAfter' or
     'endingBefore'.
    :type limit: float
    :param starting_after: Pagination parameter indicating the cursor position
     to continue returning results after. Used in conjunction with the 'limit'
     parameter. Mutually exclusive with 'endingBefore' parameter.
    :type starting_after: str
    :param duration: Time in milliseconds that represents the duration before
     end_time to query. Defaults to 24 hours.
    :type duration: long
    :param end_time: Time in unix milliseconds that represents the oldest
     routes to return. Used in combination with duration. Defaults to now.
    :type end_time: long
    :param end_time1: Timestamp representing the end of the period to fetch,
     inclusive. Used in combination with start_time. Defaults to nowMs.
    :type end_time1: long
    :param start_time: Timestamp representing the start of the period to
     fetch, inclusive. Used in combination with end_time. Defaults to 0.
    :type start_time: long
    :param end_ms3: Timestamp in milliseconds representing the end of the
     period to fetch, inclusive. Used in combination with startMs.
    :type end_ms3: long
    :param start_ms2: Timestamp in milliseconds representing the start of the
     period to fetch, inclusive. Used in combination with endMs.
    :type start_ms2: long
    :param tag_id: ID of the tag.
    :type tag_id: long
    :param vehicle_id_or_external_id: ID of the vehicle.  This must be either
     the numeric ID generated by Samsara or the external ID of the vehicle.
     External IDs are customer specified key-value pairs.
    :type vehicle_id_or_external_id: str
    :param str base_url: Service URL
    """

    def __init__(
            self, access_token, end_ms, start_ms, asset_id, data_input_id, driver_id_or_external_id, timestamp, end_ms3, start_ms2, tag_id, vehicle_id_or_external_id, end_ms1=None, start_ms1=None, duration_ms=None, end_ms2=None, group_id=None, include=None, sequence_id=None, ending_before=None, limit=None, starting_after=None, duration=None, end_time=None, end_time1=None, start_time=None, base_url=None):

        self.config = SamsaraAPIConfiguration(access_token, end_ms, start_ms, asset_id, data_input_id, driver_id_or_external_id, timestamp, end_ms3, start_ms2, tag_id, vehicle_id_or_external_id, end_ms1, start_ms1, duration_ms, end_ms2, group_id, include, sequence_id, ending_before, limit, starting_after, duration, end_time, end_time1, start_time, base_url)
        self._client = ServiceClient(None, self.config)

        client_models = {k: v for k, v in models.__dict__.items() if isinstance(v, type)}
        self.api_version = '1.0.0'
        self._serialize = Serializer(client_models)
        self._deserialize = Deserializer(client_models)

        self.add = AddOperations(
            self._client, self.config, self._serialize, self._deserialize)
        self.get = GetOperations(
            self._client, self.config, self._serialize, self._deserialize)
        self.list = ListOperations(
            self._client, self.config, self._serialize, self._deserialize)
        self.create = CreateOperations(
            self._client, self.config, self._serialize, self._deserialize)
        self.update = UpdateOperations(
            self._client, self.config, self._serialize, self._deserialize)

    def get_organization_addresses(
            self, custom_headers=None, raw=False, **operation_config):
        """/addresses.

        Fetch all addresses/geofences for the organization. An address contains
        either a circle or polygon geofence describing the address boundaries.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~swagger.models.Address] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_organization_addresses.metadata['url']

        # Construct parameters
        query_parameters = {}
        query_parameters['access_token'] = self._serialize.query("self.config.access_token", self.config.access_token, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response, 'str')

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[Address]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_organization_addresses.metadata = {'url': '/addresses'}

    def add_organization_addresses(
            self, addresses, custom_headers=None, raw=False, **operation_config):
        """/addresses.

        Add one or more addresses to the organization.

        :param addresses: List of addresses/geofences to add. Geofences can be
         circular or a polygon.
         For each address, only one of 'circle' or 'polygon' should be
         provided. If both are provided, the geofence will be saved as a
         polygon.
        :type addresses: ~swagger.models.Addresses
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~swagger.models.Address] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.add_organization_addresses.metadata['url']

        # Construct parameters
        query_parameters = {}
        query_parameters['access_token'] = self._serialize.query("self.config.access_token", self.config.access_token, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(addresses, 'Addresses')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response, 'str')

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[Address]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    add_organization_addresses.metadata = {'url': '/addresses'}

    def get_organization_address(
            self, address_id, custom_headers=None, raw=False, **operation_config):
        """/addresses/{addressId}.

        Fetch an address by its id.

        :param address_id: ID of the address/geofence
        :type address_id: long
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: Address or ClientRawResponse if raw=true
        :rtype: ~swagger.models.Address or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_organization_address.metadata['url']
        path_format_arguments = {
            'addressId': self._serialize.url("address_id", address_id, 'long')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        query_parameters['access_token'] = self._serialize.query("self.config.access_token", self.config.access_token, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response, 'str')

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('Address', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_organization_address.metadata = {'url': '/addresses/{addressId}'}

    def delete_organization_address(
            self, address_id, custom_headers=None, raw=False, **operation_config):
        """/addresses/{addressId}.

        Delete an address.

        :param address_id: ID of the address/geofence
        :type address_id: long
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.delete_organization_address.metadata['url']
        path_format_arguments = {
            'addressId': self._serialize.url("address_id", address_id, 'long')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        query_parameters['access_token'] = self._serialize.query("self.config.access_token", self.config.access_token, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response, 'str')

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    delete_organization_address.metadata = {'url': '/addresses/{addressId}'}

    def update_organization_address(
            self, address, address_id, custom_headers=None, raw=False, **operation_config):
        """/addresses/{addressId}.

        Update the name, formatted address, geofence, notes, or tag and contact
        Ids for an address. The set of tags or contacts associated with this
        address will be updated to exactly match the list of IDs passed in. To
        remove all tags or contacts from an address, pass an empty list; to
        remove notes, pass an empty string.

        :param address: Update parts of an address's value. If the geofence
         'circle' or 'polygon' key is specified, the update will change the
         type of geofence accordingly.
        :type address: ~swagger.models.AddressModel
        :param address_id: ID of the address/geofence
        :type address_id: long
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.update_organization_address.metadata['url']
        path_format_arguments = {
            'addressId': self._serialize.url("address_id", address_id, 'long')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        query_parameters['access_token'] = self._serialize.query("self.config.access_token", self.config.access_token, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(address, 'AddressModel')

        # Construct and send request
        request = self._client.patch(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response, 'str')

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    update_organization_address.metadata = {'url': '/addresses/{addressId}'}

    def list_contacts(
            self, custom_headers=None, raw=False, **operation_config):
        """/contacts.

        Fetch all contacts for the organization.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~swagger.models.Contact] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.list_contacts.metadata['url']

        # Construct parameters
        query_parameters = {}
        query_parameters['access_token'] = self._serialize.query("self.config.access_token", self.config.access_token, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response, 'str')

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[Contact]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    list_contacts.metadata = {'url': '/contacts'}

    def get_organization_contact(
            self, contact_id, custom_headers=None, raw=False, **operation_config):
        """/contacts/{contact_id}.

        Fetch a contact by its id.

        :param contact_id: ID of the contact
        :type contact_id: long
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: Contact or ClientRawResponse if raw=true
        :rtype: ~swagger.models.Contact or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_organization_contact.metadata['url']
        path_format_arguments = {
            'contact_id': self._serialize.url("contact_id", contact_id, 'long')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        query_parameters['access_token'] = self._serialize.query("self.config.access_token", self.config.access_token, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response, 'str')

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('Contact', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_organization_contact.metadata = {'url': '/contacts/{contact_id}'}

    def get_all_assets(
            self, custom_headers=None, raw=False, **operation_config):
        """/fleet/assets.

        Fetch all of the assets for the group.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: GetAllAssetsOKResponse or ClientRawResponse if raw=true
        :rtype: ~swagger.models.GetAllAssetsOKResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_all_assets.metadata['url']

        # Construct parameters
        query_parameters = {}
        query_parameters['access_token'] = self._serialize.query("self.config.access_token", self.config.access_token, 'str')
        if self.config.group_id is not None:
            query_parameters['group_id'] = self._serialize.query("self.config.group_id", self.config.group_id, 'long')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response, 'str')

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('GetAllAssetsOKResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_all_assets.metadata = {'url': '/fleet/assets'}

    def get_all_asset_current_locations(
            self, custom_headers=None, raw=False, **operation_config):
        """/fleet/assets/locations.

        Fetch current locations of all assets for the group.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: GetAllAssetCurrentLocationsOKResponse or ClientRawResponse if
         raw=true
        :rtype: ~swagger.models.GetAllAssetCurrentLocationsOKResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_all_asset_current_locations.metadata['url']

        # Construct parameters
        query_parameters = {}
        query_parameters['access_token'] = self._serialize.query("self.config.access_token", self.config.access_token, 'str')
        if self.config.group_id is not None:
            query_parameters['group_id'] = self._serialize.query("self.config.group_id", self.config.group_id, 'long')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response, 'str')

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('GetAllAssetCurrentLocationsOKResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_all_asset_current_locations.metadata = {'url': '/fleet/assets/locations'}

    def get_asset_location(
            self, custom_headers=None, raw=False, **operation_config):
        """/fleet/assets/{assetId:[0-9]+}/locations.

        Fetch the historical locations for the asset.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~swagger.models.AssetLocationResponseItem] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_asset_location.metadata['url']
        path_format_arguments = {
            'asset_id': self._serialize.url("self.config.asset_id", self.config.asset_id, 'long')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        query_parameters['access_token'] = self._serialize.query("self.config.access_token", self.config.access_token, 'str')
        query_parameters['startMs'] = self._serialize.query("self.config.start_ms", self.config.start_ms, 'long')
        query_parameters['endMs'] = self._serialize.query("self.config.end_ms", self.config.end_ms, 'long')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response, 'str')

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[AssetLocationResponseItem]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_asset_location.metadata = {'url': '/fleet/assets/{asset_id}/locations'}

    def get_asset_reefer(
            self, custom_headers=None, raw=False, **operation_config):
        """/fleet/assets/{assetId:[0-9]+}/reefer.

        Fetch the reefer-specific stats of an asset.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: AssetReeferResponse or ClientRawResponse if raw=true
        :rtype: ~swagger.models.AssetReeferResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_asset_reefer.metadata['url']
        path_format_arguments = {
            'asset_id': self._serialize.url("self.config.asset_id", self.config.asset_id, 'long')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        query_parameters['access_token'] = self._serialize.query("self.config.access_token", self.config.access_token, 'str')
        query_parameters['startMs'] = self._serialize.query("self.config.start_ms", self.config.start_ms, 'long')
        query_parameters['endMs'] = self._serialize.query("self.config.end_ms", self.config.end_ms, 'long')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response, 'str')

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('AssetReeferResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_asset_reefer.metadata = {'url': '/fleet/assets/{asset_id}/reefer'}

    def fetch_all_dispatch_routes(
            self, custom_headers=None, raw=False, **operation_config):
        """/fleet/dispatch/routes.

        Fetch all of the dispatch routes for the group.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~swagger.models.DispatchRoute] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.fetch_all_dispatch_routes.metadata['url']

        # Construct parameters
        query_parameters = {}
        query_parameters['access_token'] = self._serialize.query("self.config.access_token", self.config.access_token, 'str')
        if self.config.group_id is not None:
            query_parameters['group_id'] = self._serialize.query("self.config.group_id", self.config.group_id, 'long')
        if self.config.end_time is not None:
            query_parameters['end_time'] = self._serialize.query("self.config.end_time", self.config.end_time, 'long')
        if self.config.duration is not None:
            query_parameters['duration'] = self._serialize.query("self.config.duration", self.config.duration, 'long')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response, 'str')

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[DispatchRoute]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    fetch_all_dispatch_routes.metadata = {'url': '/fleet/dispatch/routes'}

    def create_dispatch_route(
            self, create_dispatch_route_params, custom_headers=None, raw=False, **operation_config):
        """/fleet/dispatch/routes.

        Create a new dispatch route.

        :param create_dispatch_route_params:
        :type create_dispatch_route_params:
         ~swagger.models.DispatchRouteCreate
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: DispatchRoute or ClientRawResponse if raw=true
        :rtype: ~swagger.models.DispatchRoute or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.create_dispatch_route.metadata['url']

        # Construct parameters
        query_parameters = {}
        query_parameters['access_token'] = self._serialize.query("self.config.access_token", self.config.access_token, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(create_dispatch_route_params, 'DispatchRouteCreate')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response, 'str')

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('DispatchRoute', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    create_dispatch_route.metadata = {'url': '/fleet/dispatch/routes'}

    def fetch_all_route_job_updates(
            self, custom_headers=None, raw=False, **operation_config):
        """/fleet/dispatch/routes/job_updates.

        Fetch all updates to a job including route data in the last 24 hours or
        subsequent to an sequence ID.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: AllRouteJobUpdates or ClientRawResponse if raw=true
        :rtype: ~swagger.models.AllRouteJobUpdates or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.fetch_all_route_job_updates.metadata['url']

        # Construct parameters
        query_parameters = {}
        query_parameters['access_token'] = self._serialize.query("self.config.access_token", self.config.access_token, 'str')
        if self.config.group_id is not None:
            query_parameters['group_id'] = self._serialize.query("self.config.group_id", self.config.group_id, 'long')
        if self.config.sequence_id is not None:
            query_parameters['sequence_id'] = self._serialize.query("self.config.sequence_id", self.config.sequence_id, 'str')
        if self.config.include is not None:
            query_parameters['include'] = self._serialize.query("self.config.include", self.config.include, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response, 'str')

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('AllRouteJobUpdates', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    fetch_all_route_job_updates.metadata = {'url': '/fleet/dispatch/routes/job_updates'}

    def get_dispatch_route_by_id(
            self, route_id, custom_headers=None, raw=False, **operation_config):
        """/fleet/dispatch/routes/{route_id:[0-9]+}.

        Fetch a dispatch route by id.

        :param route_id: ID of the dispatch route.
        :type route_id: long
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: DispatchRoute or ClientRawResponse if raw=true
        :rtype: ~swagger.models.DispatchRoute or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_dispatch_route_by_id.metadata['url']
        path_format_arguments = {
            'route_id': self._serialize.url("route_id", route_id, 'long')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        query_parameters['access_token'] = self._serialize.query("self.config.access_token", self.config.access_token, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response, 'str')

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('DispatchRoute', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_dispatch_route_by_id.metadata = {'url': '/fleet/dispatch/routes/{route_id}'}

    def update_dispatch_route_by_id(
            self, update_dispatch_route_params, route_id, custom_headers=None, raw=False, **operation_config):
        """/fleet/dispatch/routes/{route_id:[0-9]+}/.

        Update a dispatch route and its associated jobs.

        :param update_dispatch_route_params:
        :type update_dispatch_route_params: ~swagger.models.DispatchRoute
        :param route_id: ID of the dispatch route.
        :type route_id: long
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: DispatchRoute or ClientRawResponse if raw=true
        :rtype: ~swagger.models.DispatchRoute or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.update_dispatch_route_by_id.metadata['url']
        path_format_arguments = {
            'route_id': self._serialize.url("route_id", route_id, 'long')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        query_parameters['access_token'] = self._serialize.query("self.config.access_token", self.config.access_token, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(update_dispatch_route_params, 'DispatchRoute')

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response, 'str')

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('DispatchRoute', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    update_dispatch_route_by_id.metadata = {'url': '/fleet/dispatch/routes/{route_id}'}

    def delete_dispatch_route_by_id(
            self, route_id, custom_headers=None, raw=False, **operation_config):
        """/fleet/dispatch/routes/{route_id:[0-9]+}/.

        Delete a dispatch route and its associated jobs.

        :param route_id: ID of the dispatch route.
        :type route_id: long
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.delete_dispatch_route_by_id.metadata['url']
        path_format_arguments = {
            'route_id': self._serialize.url("route_id", route_id, 'long')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        query_parameters['access_token'] = self._serialize.query("self.config.access_token", self.config.access_token, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response, 'str')

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    delete_dispatch_route_by_id.metadata = {'url': '/fleet/dispatch/routes/{route_id}'}

    def get_dispatch_route_history(
            self, route_id, custom_headers=None, raw=False, **operation_config):
        """/fleet/dispatch/routes/{route_id:[0-9]+}/history.

        Fetch the history of a dispatch route.

        :param route_id: ID of the route with history.
        :type route_id: long
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: DispatchRouteHistory or ClientRawResponse if raw=true
        :rtype: ~swagger.models.DispatchRouteHistory or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_dispatch_route_history.metadata['url']
        path_format_arguments = {
            'route_id': self._serialize.url("route_id", route_id, 'long')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        query_parameters['access_token'] = self._serialize.query("self.config.access_token", self.config.access_token, 'str')
        if self.config.start_time is not None:
            query_parameters['start_time'] = self._serialize.query("self.config.start_time", self.config.start_time, 'long')
        if self.config.end_time is not None:
            query_parameters['end_time'] = self._serialize.query("self.config.end_time", self.config.end_time, 'long')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response, 'str')

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('DispatchRouteHistory', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_dispatch_route_history.metadata = {'url': '/fleet/dispatch/routes/{route_id}/history'}

    def create_driver(
            self, create_driver_param, custom_headers=None, raw=False, **operation_config):
        """/fleet/drivers/create.

        Create a new driver.

        :param create_driver_param: Driver creation body
        :type create_driver_param: ~swagger.models.DriverForCreate
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: CurrentDriver or ClientRawResponse if raw=true
        :rtype: ~swagger.models.CurrentDriver or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.create_driver.metadata['url']

        # Construct parameters
        query_parameters = {}
        query_parameters['access_token'] = self._serialize.query("self.config.access_token", self.config.access_token, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(create_driver_param, 'DriverForCreate')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response, 'str')

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('CurrentDriver', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    create_driver.metadata = {'url': '/fleet/drivers/create'}

    def get_driver_document_types_by_org_id(
            self, custom_headers=None, raw=False, **operation_config):
        """/fleet/drivers/document_types.

        Fetch all of the document types.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~swagger.models.DocumentType] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_driver_document_types_by_org_id.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response, 'str')

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[DocumentType]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_driver_document_types_by_org_id.metadata = {'url': '/fleet/drivers/document_types'}

    def get_driver_documents_by_org_id(
            self, custom_headers=None, raw=False, **operation_config):
        """/fleet/drivers/documents.

        Fetch all of the documents.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~swagger.models.Document] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_driver_documents_by_org_id.metadata['url']

        # Construct parameters
        query_parameters = {}
        if self.config.end_ms is not None:
            query_parameters['endMs'] = self._serialize.query("self.config.end_ms", self.config.end_ms, 'long')
        if self.config.duration_ms is not None:
            query_parameters['durationMs'] = self._serialize.query("self.config.duration_ms", self.config.duration_ms, 'long')
        query_parameters['access_token'] = self._serialize.query("self.config.access_token", self.config.access_token, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response, 'str')

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[Document]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_driver_documents_by_org_id.metadata = {'url': '/fleet/drivers/documents'}

    def get_all_deactivated_drivers(
            self, custom_headers=None, raw=False, **operation_config):
        """/fleet/drivers/inactive.

        Fetch all deactivated drivers for the group.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~swagger.models.CurrentDriver] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_all_deactivated_drivers.metadata['url']

        # Construct parameters
        query_parameters = {}
        query_parameters['access_token'] = self._serialize.query("self.config.access_token", self.config.access_token, 'str')
        if self.config.group_id is not None:
            query_parameters['group_id'] = self._serialize.query("self.config.group_id", self.config.group_id, 'long')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response, 'str')

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[CurrentDriver]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_all_deactivated_drivers.metadata = {'url': '/fleet/drivers/inactive'}

    def get_deactivated_driver_by_id(
            self, custom_headers=None, raw=False, **operation_config):
        """/fleet/drivers/inactive/{driver_id:[0-9]+ | external_id:[a-zA-Z0-9]+}.

        Fetch deactivated driver by id.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: CurrentDriver or ClientRawResponse if raw=true
        :rtype: ~swagger.models.CurrentDriver or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_deactivated_driver_by_id.metadata['url']
        path_format_arguments = {
            'driver_id_or_external_id': self._serialize.url("self.config.driver_id_or_external_id", self.config.driver_id_or_external_id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        query_parameters['access_token'] = self._serialize.query("self.config.access_token", self.config.access_token, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response, 'str')

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('CurrentDriver', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_deactivated_driver_by_id.metadata = {'url': '/fleet/drivers/inactive/{driver_id_or_external_id}'}

    def reactivate_driver_by_id(
            self, reactivate_driver_param, custom_headers=None, raw=False, **operation_config):
        """/fleet/drivers/inactive/{driver_id:[0-9]+ | external_id:[a-zA-Z0-9]+}.

        Reactivate the inactive driver having id.

        :param reactivate_driver_param: Driver reactivation body
        :type reactivate_driver_param: ~swagger.models.ReactivateDriverParam
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: CurrentDriver or ClientRawResponse if raw=true
        :rtype: ~swagger.models.CurrentDriver or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.reactivate_driver_by_id.metadata['url']
        path_format_arguments = {
            'driver_id_or_external_id': self._serialize.url("self.config.driver_id_or_external_id", self.config.driver_id_or_external_id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        query_parameters['access_token'] = self._serialize.query("self.config.access_token", self.config.access_token, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(reactivate_driver_param, 'ReactivateDriverParam')

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response, 'str')

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('CurrentDriver', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    reactivate_driver_by_id.metadata = {'url': '/fleet/drivers/inactive/{driver_id_or_external_id}'}

    def get_driver_safety_score(
            self, driver_id, custom_headers=None, raw=False, **operation_config):
        """/fleet/drivers/{driverId:[0-9]+}/safety/score.

        Fetch the safety score for the driver.

        :param driver_id: ID of the driver
        :type driver_id: long
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: DriverSafetyScoreResponse or ClientRawResponse if raw=true
        :rtype: ~swagger.models.DriverSafetyScoreResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_driver_safety_score.metadata['url']
        path_format_arguments = {
            'driverId': self._serialize.url("driver_id", driver_id, 'long')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        query_parameters['access_token'] = self._serialize.query("self.config.access_token", self.config.access_token, 'str')
        query_parameters['startMs'] = self._serialize.query("self.config.start_ms", self.config.start_ms, 'long')
        query_parameters['endMs'] = self._serialize.query("self.config.end_ms", self.config.end_ms, 'long')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response, 'str')

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('DriverSafetyScoreResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_driver_safety_score.metadata = {'url': '/fleet/drivers/{driverId}/safety/score'}

    def get_driver_by_id(
            self, custom_headers=None, raw=False, **operation_config):
        """/fleet/drivers/{driver_id:[0-9]+ | external_id:[a-zA-Z0-9]+}.

        Fetch driver by id.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: CurrentDriver or ClientRawResponse if raw=true
        :rtype: ~swagger.models.CurrentDriver or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_driver_by_id.metadata['url']
        path_format_arguments = {
            'driver_id_or_external_id': self._serialize.url("self.config.driver_id_or_external_id", self.config.driver_id_or_external_id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        query_parameters['access_token'] = self._serialize.query("self.config.access_token", self.config.access_token, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response, 'str')

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('CurrentDriver', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_driver_by_id.metadata = {'url': '/fleet/drivers/{driver_id_or_external_id}'}

    def deactivate_driver(
            self, custom_headers=None, raw=False, **operation_config):
        """/fleet/drivers/{driver_id:[0-9]+ | external_id:[a-zA-Z0-9]+}.

        Deactivate a driver with the given id.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.deactivate_driver.metadata['url']
        path_format_arguments = {
            'driver_id_or_external_id': self._serialize.url("self.config.driver_id_or_external_id", self.config.driver_id_or_external_id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        query_parameters['access_token'] = self._serialize.query("self.config.access_token", self.config.access_token, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response, 'str')

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    deactivate_driver.metadata = {'url': '/fleet/drivers/{driver_id_or_external_id}'}

    def get_dispatch_routes_by_driver_id(
            self, driver_id, custom_headers=None, raw=False, **operation_config):
        """/fleet/drivers/{driver_id:[0-9]+}/dispatch/routes.

        Fetch all of the dispatch routes for a given driver.

        :param driver_id: ID of the driver with the associated routes.
        :type driver_id: long
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~swagger.models.DispatchRoute] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_dispatch_routes_by_driver_id.metadata['url']
        path_format_arguments = {
            'driver_id': self._serialize.url("driver_id", driver_id, 'long')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if self.config.end_time is not None:
            query_parameters['end_time'] = self._serialize.query("self.config.end_time", self.config.end_time, 'long')
        if self.config.duration is not None:
            query_parameters['duration'] = self._serialize.query("self.config.duration", self.config.duration, 'long')
        query_parameters['access_token'] = self._serialize.query("self.config.access_token", self.config.access_token, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response, 'str')

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[DispatchRoute]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_dispatch_routes_by_driver_id.metadata = {'url': '/fleet/drivers/{driver_id}/dispatch/routes'}

    def create_driver_dispatch_route(
            self, create_dispatch_route_params, driver_id, custom_headers=None, raw=False, **operation_config):
        """/fleet/drivers/{driver_id:[0-9]+}/dispatch/routes.

        Create a new dispatch route for the driver with driver_id.

        :param create_dispatch_route_params:
        :type create_dispatch_route_params:
         ~swagger.models.DispatchRouteCreate
        :param driver_id: ID of the driver with the associated routes.
        :type driver_id: long
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: DispatchRoute or ClientRawResponse if raw=true
        :rtype: ~swagger.models.DispatchRoute or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.create_driver_dispatch_route.metadata['url']
        path_format_arguments = {
            'driver_id': self._serialize.url("driver_id", driver_id, 'long')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        query_parameters['access_token'] = self._serialize.query("self.config.access_token", self.config.access_token, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(create_dispatch_route_params, 'DispatchRouteCreate')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response, 'str')

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('DispatchRoute', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    create_driver_dispatch_route.metadata = {'url': '/fleet/drivers/{driver_id}/dispatch/routes'}

    def create_driver_document(
            self, create_document_params, driver_id, custom_headers=None, raw=False, **operation_config):
        """/fleet/drivers/{driver_id:[0-9]+}/documents.

        Create a driver document for the given driver.

        :param create_document_params: To create a document for a given
         document type, the document type's uuid needs to be passed in to
         documentTypeUuid. The list of fields passed in should match the
         document typeâ€™s list of field types in the correct order. In other
         words, a field's valueType and value (i.e. only one of: stringValue,
         numberValue, or photoValue) at index _i_ should match with the
         document field typeâ€™s valueType at index _i_.
        :type create_document_params: ~swagger.models.DocumentCreate
        :param driver_id: ID of the driver for whom the document is created.
        :type driver_id: long
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: Document or ClientRawResponse if raw=true
        :rtype: ~swagger.models.Document or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.create_driver_document.metadata['url']
        path_format_arguments = {
            'driver_id': self._serialize.url("driver_id", driver_id, 'long')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        query_parameters['access_token'] = self._serialize.query("self.config.access_token", self.config.access_token, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(create_document_params, 'DocumentCreate')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response, 'str')

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('Document', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    create_driver_document.metadata = {'url': '/fleet/drivers/{driver_id}/documents'}

    def get_vehicles_locations(
            self, start_ms, end_ms, custom_headers=None, raw=False, **operation_config):
        """/fleet/vehicles/locations.

        Fetch locations for a given vehicle between a start/end time. The
        maximum query duration is 30 minutes.

        :param start_ms: Time in Unix epoch milliseconds for the start of the
         query (cannot exceed 30 minutes)
        :type start_ms: int
        :param end_ms: Time in Unix epoch milliseconds for the end of the
         query (cannot exceed 30 minutes)
        :type end_ms: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~swagger.models.FleetVehiclesLocationsItem] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_vehicles_locations.metadata['url']

        # Construct parameters
        query_parameters = {}
        query_parameters['access_token'] = self._serialize.query("self.config.access_token", self.config.access_token, 'str')
        query_parameters['startMs'] = self._serialize.query("start_ms", start_ms, 'int')
        query_parameters['endMs'] = self._serialize.query("end_ms", end_ms, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response, 'str')

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[FleetVehiclesLocationsItem]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_vehicles_locations.metadata = {'url': '/fleet/vehicles/locations'}

    def get_vehicle_stats(
            self, start_ms, end_ms, series=None, tag_ids=None, custom_headers=None, raw=False, **operation_config):
        """/fleet/vehicles/stats.

        Fetch engine state and aux input data for all vehicles in the group
        between a start/end time. Data returned may be affected by device
        connectivity and processing time.

        :param start_ms: Time in Unix epoch milliseconds for the start of the
         query.
        :type start_ms: int
        :param end_ms: Time in Unix epoch milliseconds for the end of the
         query.
        :type end_ms: int
        :param series: Comma-separated list of stat types. Options are
         engineState, auxInput1, and auxInput2. If this parameter is excluded,
         all 3 stat types will be returned. Example:
         series=engineState,auxInput2. Possible values include: 'engineState',
         'auxInput1', 'auxInput2'
        :type series: str
        :param tag_ids: Comma-separated list of tag ids. Example: tagIds=1,2,3
        :type tag_ids: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: GetVehicleStatsOKResponse or ClientRawResponse if raw=true
        :rtype: ~swagger.models.GetVehicleStatsOKResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_vehicle_stats.metadata['url']

        # Construct parameters
        query_parameters = {}
        query_parameters['access_token'] = self._serialize.query("self.config.access_token", self.config.access_token, 'str')
        query_parameters['startMs'] = self._serialize.query("start_ms", start_ms, 'int')
        query_parameters['endMs'] = self._serialize.query("end_ms", end_ms, 'int')
        if series is not None:
            query_parameters['series'] = self._serialize.query("series", series, 'str')
        if tag_ids is not None:
            query_parameters['tagIds'] = self._serialize.query("tag_ids", tag_ids, 'str')
        if self.config.starting_after is not None:
            query_parameters['startingAfter'] = self._serialize.query("self.config.starting_after", self.config.starting_after, 'str')
        if self.config.ending_before is not None:
            query_parameters['endingBefore'] = self._serialize.query("self.config.ending_before", self.config.ending_before, 'str')
        if self.config.limit is not None:
            query_parameters['limit'] = self._serialize.query("self.config.limit", self.config.limit, 'float')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response, 'str')

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('GetVehicleStatsOKResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_vehicle_stats.metadata = {'url': '/fleet/vehicles/stats'}

    def get_vehicle_harsh_event(
            self, vehicle_id, custom_headers=None, raw=False, **operation_config):
        """/fleet/vehicles/{vehicleId:[0-9]+}/safety/harsh_event.

        Fetch harsh event details for a vehicle.

        :param vehicle_id: ID of the vehicle
        :type vehicle_id: long
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: VehicleHarshEventResponse or ClientRawResponse if raw=true
        :rtype: ~swagger.models.VehicleHarshEventResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_vehicle_harsh_event.metadata['url']
        path_format_arguments = {
            'vehicleId': self._serialize.url("vehicle_id", vehicle_id, 'long')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        query_parameters['access_token'] = self._serialize.query("self.config.access_token", self.config.access_token, 'str')
        query_parameters['timestamp'] = self._serialize.query("self.config.timestamp", self.config.timestamp, 'long')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response, 'str')

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('VehicleHarshEventResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_vehicle_harsh_event.metadata = {'url': '/fleet/vehicles/{vehicleId}/safety/harsh_event'}

    def get_vehicle_safety_score(
            self, vehicle_id, custom_headers=None, raw=False, **operation_config):
        """/fleet/vehicles/{vehicleId:[0-9]+}/safety/score.

        Fetch the safety score for the vehicle.

        :param vehicle_id: ID of the vehicle
        :type vehicle_id: long
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: VehicleSafetyScoreResponse or ClientRawResponse if raw=true
        :rtype: ~swagger.models.VehicleSafetyScoreResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_vehicle_safety_score.metadata['url']
        path_format_arguments = {
            'vehicleId': self._serialize.url("vehicle_id", vehicle_id, 'long')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        query_parameters['access_token'] = self._serialize.query("self.config.access_token", self.config.access_token, 'str')
        query_parameters['startMs'] = self._serialize.query("self.config.start_ms", self.config.start_ms, 'long')
        query_parameters['endMs'] = self._serialize.query("self.config.end_ms", self.config.end_ms, 'long')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response, 'str')

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('VehicleSafetyScoreResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_vehicle_safety_score.metadata = {'url': '/fleet/vehicles/{vehicleId}/safety/score'}

    def get_fleet_vehicle(
            self, custom_headers=None, raw=False, **operation_config):
        """/fleet/vehicles/{vehicle_id:[0-9]+ | external_id:[a-zA-Z0-9]+}.

        Gets a specific vehicle.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: FleetVehicleResponse or ClientRawResponse if raw=true
        :rtype: ~swagger.models.FleetVehicleResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_fleet_vehicle.metadata['url']
        path_format_arguments = {
            'vehicle_id_or_external_id': self._serialize.url("self.config.vehicle_id_or_external_id", self.config.vehicle_id_or_external_id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        query_parameters['access_token'] = self._serialize.query("self.config.access_token", self.config.access_token, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response, 'str')

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('FleetVehicleResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_fleet_vehicle.metadata = {'url': '/fleet/vehicles/{vehicle_id_or_external_id}'}

    def patch_fleet_vehicle(
            self, data, custom_headers=None, raw=False, **operation_config):
        """/fleet/vehicles/{vehicle_id:[0-9]+ | external_id:[a-zA-Z0-9]+}.

        Updates the specified vehicle using JSON merge patch format. See IETF
        RFC 7396: https://tools.ietf.org/html/rfc7396.

        :param data:
        :type data: ~swagger.models.Data
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: FleetVehicleResponse or ClientRawResponse if raw=true
        :rtype: ~swagger.models.FleetVehicleResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.patch_fleet_vehicle.metadata['url']
        path_format_arguments = {
            'vehicle_id_or_external_id': self._serialize.url("self.config.vehicle_id_or_external_id", self.config.vehicle_id_or_external_id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        query_parameters['access_token'] = self._serialize.query("self.config.access_token", self.config.access_token, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(data, 'Data')

        # Construct and send request
        request = self._client.patch(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response, 'str')

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('FleetVehicleResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    patch_fleet_vehicle.metadata = {'url': '/fleet/vehicles/{vehicle_id_or_external_id}'}

    def get_dispatch_routes_by_vehicle_id(
            self, vehicle_id, custom_headers=None, raw=False, **operation_config):
        """/fleet/vehicles/{vehicle_id:[0-9]+}/dispatch/routes.

        Fetch all of the dispatch routes for a given vehicle.

        :param vehicle_id: ID of the vehicle with the associated routes.
        :type vehicle_id: long
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~swagger.models.DispatchRoute] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_dispatch_routes_by_vehicle_id.metadata['url']
        path_format_arguments = {
            'vehicle_id': self._serialize.url("vehicle_id", vehicle_id, 'long')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if self.config.end_time is not None:
            query_parameters['end_time'] = self._serialize.query("self.config.end_time", self.config.end_time, 'long')
        if self.config.duration is not None:
            query_parameters['duration'] = self._serialize.query("self.config.duration", self.config.duration, 'long')
        query_parameters['access_token'] = self._serialize.query("self.config.access_token", self.config.access_token, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response, 'str')

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[DispatchRoute]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_dispatch_routes_by_vehicle_id.metadata = {'url': '/fleet/vehicles/{vehicle_id}/dispatch/routes'}

    def create_vehicle_dispatch_route(
            self, create_dispatch_route_params, vehicle_id, custom_headers=None, raw=False, **operation_config):
        """/fleet/vehicles/{vehicle_id:[0-9]+}/dispatch/routes.

        Create a new dispatch route for the vehicle with vehicle_id.

        :param create_dispatch_route_params:
        :type create_dispatch_route_params:
         ~swagger.models.DispatchRouteCreate
        :param vehicle_id: ID of the vehicle with the associated routes.
        :type vehicle_id: long
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: DispatchRoute or ClientRawResponse if raw=true
        :rtype: ~swagger.models.DispatchRoute or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.create_vehicle_dispatch_route.metadata['url']
        path_format_arguments = {
            'vehicle_id': self._serialize.url("vehicle_id", vehicle_id, 'long')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        query_parameters['access_token'] = self._serialize.query("self.config.access_token", self.config.access_token, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(create_dispatch_route_params, 'DispatchRouteCreate')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response, 'str')

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('DispatchRoute', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    create_vehicle_dispatch_route.metadata = {'url': '/fleet/vehicles/{vehicle_id}/dispatch/routes'}

    def get_vehicle_locations(
            self, vehicle_id, start_ms, end_ms, custom_headers=None, raw=False, **operation_config):
        """/fleet/vehicles/{vehicle_id:[0-9]+}/locations.

        Fetch locations for a given vehicle between a start/end time. The
        maximum query duration is one hour.

        :param vehicle_id: ID of the vehicle with the associated routes.
        :type vehicle_id: long
        :param start_ms: Time in Unix epoch milliseconds for the start of the
         query (cannot exceed 1 hour)
        :type start_ms: long
        :param end_ms: Time in Unix epoch milliseconds for the end of the
         query (cannot exceed 1 hour)
        :type end_ms: long
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~swagger.models.FleetVehicleLocation] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_vehicle_locations.metadata['url']
        path_format_arguments = {
            'vehicle_id': self._serialize.url("vehicle_id", vehicle_id, 'long')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        query_parameters['access_token'] = self._serialize.query("self.config.access_token", self.config.access_token, 'str')
        query_parameters['startMs'] = self._serialize.query("start_ms", start_ms, 'long')
        query_parameters['endMs'] = self._serialize.query("end_ms", end_ms, 'long')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response, 'str')

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[FleetVehicleLocation]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_vehicle_locations.metadata = {'url': '/fleet/vehicles/{vehicle_id}/locations'}

    def get_all_data_inputs(
            self, custom_headers=None, raw=False, **operation_config):
        """/industrial/data.

        Fetch all of the data inputs for a group.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: GetAllDataInputsOKResponse or ClientRawResponse if raw=true
        :rtype: ~swagger.models.GetAllDataInputsOKResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_all_data_inputs.metadata['url']

        # Construct parameters
        query_parameters = {}
        query_parameters['access_token'] = self._serialize.query("self.config.access_token", self.config.access_token, 'str')
        if self.config.group_id is not None:
            query_parameters['group_id'] = self._serialize.query("self.config.group_id", self.config.group_id, 'long')
        if self.config.start_ms is not None:
            query_parameters['startMs'] = self._serialize.query("self.config.start_ms", self.config.start_ms, 'long')
        if self.config.end_ms is not None:
            query_parameters['endMs'] = self._serialize.query("self.config.end_ms", self.config.end_ms, 'long')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response, 'str')

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('GetAllDataInputsOKResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_all_data_inputs.metadata = {'url': '/industrial/data'}

    def get_data_input(
            self, custom_headers=None, raw=False, **operation_config):
        """/industrial/data/{data_input_id:[0-9]+}.

        Fetch datapoints from a given data input.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: DataInputHistoryResponse or ClientRawResponse if raw=true
        :rtype: ~swagger.models.DataInputHistoryResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_data_input.metadata['url']
        path_format_arguments = {
            'data_input_id': self._serialize.url("self.config.data_input_id", self.config.data_input_id, 'long')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        query_parameters['access_token'] = self._serialize.query("self.config.access_token", self.config.access_token, 'str')
        if self.config.start_ms is not None:
            query_parameters['startMs'] = self._serialize.query("self.config.start_ms", self.config.start_ms, 'long')
        if self.config.end_ms is not None:
            query_parameters['endMs'] = self._serialize.query("self.config.end_ms", self.config.end_ms, 'long')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response, 'str')

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('DataInputHistoryResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_data_input.metadata = {'url': '/industrial/data/{data_input_id}'}

    def get_all_tags(
            self, custom_headers=None, raw=False, **operation_config):
        """/tags.

        Fetch all of the tags for a group.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: GetAllTagsOKResponse or ClientRawResponse if raw=true
        :rtype: ~swagger.models.GetAllTagsOKResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_all_tags.metadata['url']

        # Construct parameters
        query_parameters = {}
        query_parameters['access_token'] = self._serialize.query("self.config.access_token", self.config.access_token, 'str')
        if self.config.group_id is not None:
            query_parameters['group_id'] = self._serialize.query("self.config.group_id", self.config.group_id, 'long')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response, 'str')

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('GetAllTagsOKResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_all_tags.metadata = {'url': '/tags'}

    def create_tag(
            self, tag_create_params, custom_headers=None, raw=False, **operation_config):
        """/tags.

        Create a new tag for the group.

        :param tag_create_params:
        :type tag_create_params: ~swagger.models.TagCreate
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: Tag or ClientRawResponse if raw=true
        :rtype: ~swagger.models.Tag or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.create_tag.metadata['url']

        # Construct parameters
        query_parameters = {}
        query_parameters['access_token'] = self._serialize.query("self.config.access_token", self.config.access_token, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(tag_create_params, 'TagCreate')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response, 'str')

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('Tag', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    create_tag.metadata = {'url': '/tags'}

    def get_tag_by_id(
            self, custom_headers=None, raw=False, **operation_config):
        """/tags/{tag_id:[0-9]+}.

        Fetch a tag by id.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: Tag or ClientRawResponse if raw=true
        :rtype: ~swagger.models.Tag or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_tag_by_id.metadata['url']
        path_format_arguments = {
            'tag_id': self._serialize.url("self.config.tag_id", self.config.tag_id, 'long')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        query_parameters['access_token'] = self._serialize.query("self.config.access_token", self.config.access_token, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response, 'str')

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('Tag', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_tag_by_id.metadata = {'url': '/tags/{tag_id}'}

    def update_tag_by_id(
            self, update_tag_params, custom_headers=None, raw=False, **operation_config):
        """/tags/{tag_id:[0-9]+}.

        Update a tag with a new name and new members. This API call would
        replace all old members of a tag with new members specified in the
        request body. To modify only a few devices associated with a tag use
        the PATCH endpoint.

        :param update_tag_params:
        :type update_tag_params: ~swagger.models.TagUpdate
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: Tag or ClientRawResponse if raw=true
        :rtype: ~swagger.models.Tag or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.update_tag_by_id.metadata['url']
        path_format_arguments = {
            'tag_id': self._serialize.url("self.config.tag_id", self.config.tag_id, 'long')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        query_parameters['access_token'] = self._serialize.query("self.config.access_token", self.config.access_token, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(update_tag_params, 'TagUpdate')

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response, 'str')

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('Tag', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    update_tag_by_id.metadata = {'url': '/tags/{tag_id}'}

    def delete_tag_by_id(
            self, custom_headers=None, raw=False, **operation_config):
        """/tags/{tag_id:[0-9]+}.

        Permanently deletes a tag.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.delete_tag_by_id.metadata['url']
        path_format_arguments = {
            'tag_id': self._serialize.url("self.config.tag_id", self.config.tag_id, 'long')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        query_parameters['access_token'] = self._serialize.query("self.config.access_token", self.config.access_token, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response, 'str')

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    delete_tag_by_id.metadata = {'url': '/tags/{tag_id}'}

    def modify_tag_by_id(
            self, tag_modify_params, custom_headers=None, raw=False, **operation_config):
        """/tags/{tag_id:[0-9]+}.

        Add or delete specific members from a tag, or modify the name of a tag.

        :param tag_modify_params:
        :type tag_modify_params: ~swagger.models.TagModify
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: Tag or ClientRawResponse if raw=true
        :rtype: ~swagger.models.Tag or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.modify_tag_by_id.metadata['url']
        path_format_arguments = {
            'tag_id': self._serialize.url("self.config.tag_id", self.config.tag_id, 'long')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        query_parameters['access_token'] = self._serialize.query("self.config.access_token", self.config.access_token, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(tag_modify_params, 'TagModify')

        # Construct and send request
        request = self._client.patch(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response, 'str')

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('Tag', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    modify_tag_by_id.metadata = {'url': '/tags/{tag_id}'}

    def list_user_roles(
            self, custom_headers=None, raw=False, **operation_config):
        """/user_roles.

        Get all roles in the organization.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~swagger.models.UserRole] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.list_user_roles.metadata['url']

        # Construct parameters
        query_parameters = {}
        query_parameters['access_token'] = self._serialize.query("self.config.access_token", self.config.access_token, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response, 'str')

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[UserRole]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    list_user_roles.metadata = {'url': '/user_roles'}

    def get_user_by_id(
            self, user_id, custom_headers=None, raw=False, **operation_config):
        """/users/{userId:[0-9]+}.

        Get a user.

        :param user_id: ID of the user.
        :type user_id: long
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: User or ClientRawResponse if raw=true
        :rtype: ~swagger.models.User or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_user_by_id.metadata['url']
        path_format_arguments = {
            'userId': self._serialize.url("user_id", user_id, 'long')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        query_parameters['access_token'] = self._serialize.query("self.config.access_token", self.config.access_token, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response, 'str')

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('User', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_user_by_id.metadata = {'url': '/users/{userId}'}

    def delete_user_by_id(
            self, user_id, custom_headers=None, raw=False, **operation_config):
        """/users/{userId:[0-9]+}.

        Remove a user from the organization.

        :param user_id: ID of the user.
        :type user_id: long
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.delete_user_by_id.metadata['url']
        path_format_arguments = {
            'userId': self._serialize.url("user_id", user_id, 'long')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        query_parameters['access_token'] = self._serialize.query("self.config.access_token", self.config.access_token, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response, 'str')

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    delete_user_by_id.metadata = {'url': '/users/{userId}'}
