/*
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */

/* jshint latedef:false */
/* jshint forin:false */
/* jshint noempty:false */

'use strict';

const msRest = require('ms-rest');
const ServiceClient = msRest.ServiceClient;
const WebResource = msRest.WebResource;

const models = require('./models');
const operations = require('./operations');


/**
 * @summary /addresses
 *
 * Fetch all addresses/geofences for the organization. An address contains
 * either a circle or polygon geofence describing the address boundaries.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {array} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getOrganizationAddresses(options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (this.accessToken === null || this.accessToken === undefined || typeof this.accessToken.valueOf() !== 'string') {
      throw new Error('this.accessToken cannot be null or undefined and it must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'addresses';
  let queryParameters = [];
  queryParameters.push('access_token=' + encodeURIComponent(this.accessToken));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedErrorResponse',
            type: {
              name: 'String'
            }
          };
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Sequence',
              element: {
                  required: false,
                  serializedName: 'AddressElementType',
                  type: {
                    name: 'Composite',
                    className: 'Address'
                  }
              }
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary /addresses
 *
 * Add one or more addresses to the organization
 *
 * @param {object} addresses List of addresses/geofences to add. Geofences can
 * be circular or a polygon.
 * For each address, only one of 'circle' or 'polygon' should be provided. If
 * both are provided, the geofence will be saved as a polygon.
 *
 * @param {array} addresses.addresses
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {array} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _addOrganizationAddresses(addresses, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (this.accessToken === null || this.accessToken === undefined || typeof this.accessToken.valueOf() !== 'string') {
      throw new Error('this.accessToken cannot be null or undefined and it must be of type string.');
    }
    if (addresses === null || addresses === undefined) {
      throw new Error('addresses cannot be null or undefined.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'addresses';
  let queryParameters = [];
  queryParameters.push('access_token=' + encodeURIComponent(this.accessToken));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (addresses !== null && addresses !== undefined) {
      let requestModelMapper = new client.models['Addresses']().mapper();
      requestModel = client.serialize(requestModelMapper, addresses, 'addresses');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(addresses, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedErrorResponse',
            type: {
              name: 'String'
            }
          };
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Sequence',
              element: {
                  required: false,
                  serializedName: 'AddressElementType',
                  type: {
                    name: 'Composite',
                    className: 'Address'
                  }
              }
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary /addresses/{addressId}
 *
 * Fetch an address by its id.
 *
 * @param {number} addressId ID of the address/geofence
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link Address} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getOrganizationAddress(addressId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (this.accessToken === null || this.accessToken === undefined || typeof this.accessToken.valueOf() !== 'string') {
      throw new Error('this.accessToken cannot be null or undefined and it must be of type string.');
    }
    if (addressId === null || addressId === undefined || typeof addressId !== 'number') {
      throw new Error('addressId cannot be null or undefined and it must be of type number.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'addresses/{addressId}';
  requestUrl = requestUrl.replace('{addressId}', encodeURIComponent(addressId.toString()));
  let queryParameters = [];
  queryParameters.push('access_token=' + encodeURIComponent(this.accessToken));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedErrorResponse',
            type: {
              name: 'String'
            }
          };
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['Address']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary /addresses/{addressId}
 *
 * Delete an address.
 *
 * @param {number} addressId ID of the address/geofence
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deleteOrganizationAddress(addressId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (this.accessToken === null || this.accessToken === undefined || typeof this.accessToken.valueOf() !== 'string') {
      throw new Error('this.accessToken cannot be null or undefined and it must be of type string.');
    }
    if (addressId === null || addressId === undefined || typeof addressId !== 'number') {
      throw new Error('addressId cannot be null or undefined and it must be of type number.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'addresses/{addressId}';
  requestUrl = requestUrl.replace('{addressId}', encodeURIComponent(addressId.toString()));
  let queryParameters = [];
  queryParameters.push('access_token=' + encodeURIComponent(this.accessToken));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedErrorResponse',
            type: {
              name: 'String'
            }
          };
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary /addresses/{addressId}
 *
 * Update the name, formatted address, geofence, notes, or tag and contact Ids
 * for an address. The set of tags or contacts associated with this address
 * will be updated to exactly match the list of IDs passed in. To remove all
 * tags or contacts from an address, pass an empty list; to remove notes, pass
 * an empty string.
 *
 * @param {object} address Update parts of an address's value. If the geofence
 * 'circle' or 'polygon' key is specified, the update will change the type of
 * geofence accordingly.
 *
 * @param {array} [address.contactIds]
 *
 * @param {string} [address.formattedAddress] The full address associated with
 * this address/geofence, as it might be recognized by maps.google.com
 *
 * @param {object} [address.geofence]
 *
 * @param {object} [address.geofence.circle] Information about a circular
 * geofence. This field is only populated if the geofence is a circle.
 *
 * @param {number} [address.geofence.circle.latitude] The latitude of the
 * center of the circular geofence
 *
 * @param {number} [address.geofence.circle.longitude] The longitude of the
 * center of the circular geofence
 *
 * @param {number} [address.geofence.circle.radiusMeters] The radius of the
 * circular geofence
 *
 * @param {object} [address.geofence.polygon] Information about a polygon
 * geofence. This field is only populated if the geofence is a polygon.
 *
 * @param {array} [address.geofence.polygon.vertices] The vertices of the
 * polygon geofence. These geofence vertices describe the perimeter of the
 * polygon, and must consist of at least 3 vertices and less than 40.
 *
 * @param {string} [address.name] The name of this address/geofence
 *
 * @param {string} [address.notes]
 *
 * @param {array} [address.tagIds]
 *
 * @param {number} addressId ID of the address/geofence
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _updateOrganizationAddress(address, addressId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (this.accessToken === null || this.accessToken === undefined || typeof this.accessToken.valueOf() !== 'string') {
      throw new Error('this.accessToken cannot be null or undefined and it must be of type string.');
    }
    if (address === null || address === undefined) {
      throw new Error('address cannot be null or undefined.');
    }
    if (addressId === null || addressId === undefined || typeof addressId !== 'number') {
      throw new Error('addressId cannot be null or undefined and it must be of type number.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'addresses/{addressId}';
  requestUrl = requestUrl.replace('{addressId}', encodeURIComponent(addressId.toString()));
  let queryParameters = [];
  queryParameters.push('access_token=' + encodeURIComponent(this.accessToken));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PATCH';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (address !== null && address !== undefined) {
      let requestModelMapper = new client.models['AddressModel']().mapper();
      requestModel = client.serialize(requestModelMapper, address, 'address');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(address, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedErrorResponse',
            type: {
              name: 'String'
            }
          };
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary /contacts
 *
 * Fetch all contacts for the organization.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {array} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listContacts(options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (this.accessToken === null || this.accessToken === undefined || typeof this.accessToken.valueOf() !== 'string') {
      throw new Error('this.accessToken cannot be null or undefined and it must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'contacts';
  let queryParameters = [];
  queryParameters.push('access_token=' + encodeURIComponent(this.accessToken));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedErrorResponse',
            type: {
              name: 'String'
            }
          };
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Sequence',
              element: {
                  required: false,
                  serializedName: 'ContactElementType',
                  type: {
                    name: 'Composite',
                    className: 'Contact'
                  }
              }
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary /contacts/{contact_id}
 *
 * Fetch a contact by its id.
 *
 * @param {number} contactId ID of the contact
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link Contact} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getOrganizationContact(contactId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (this.accessToken === null || this.accessToken === undefined || typeof this.accessToken.valueOf() !== 'string') {
      throw new Error('this.accessToken cannot be null or undefined and it must be of type string.');
    }
    if (contactId === null || contactId === undefined || typeof contactId !== 'number') {
      throw new Error('contactId cannot be null or undefined and it must be of type number.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'contacts/{contact_id}';
  requestUrl = requestUrl.replace('{contact_id}', encodeURIComponent(contactId.toString()));
  let queryParameters = [];
  queryParameters.push('access_token=' + encodeURIComponent(this.accessToken));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedErrorResponse',
            type: {
              name: 'String'
            }
          };
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['Contact']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary /fleet/assets
 *
 * Fetch all of the assets for the group.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link GetAllAssetsOKResponse} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getAllAssets(options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (this.accessToken === null || this.accessToken === undefined || typeof this.accessToken.valueOf() !== 'string') {
      throw new Error('this.accessToken cannot be null or undefined and it must be of type string.');
    }
    if (this.groupId !== null && this.groupId !== undefined && typeof this.groupId !== 'number') {
      throw new Error('this.groupId must be of type number.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'fleet/assets';
  let queryParameters = [];
  queryParameters.push('access_token=' + encodeURIComponent(this.accessToken));
  if (this.groupId !== null && this.groupId !== undefined) {
    queryParameters.push('group_id=' + encodeURIComponent(this.groupId.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedErrorResponse',
            type: {
              name: 'String'
            }
          };
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['GetAllAssetsOKResponse']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary /fleet/assets/locations
 *
 * Fetch current locations of all assets for the group.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link GetAllAssetCurrentLocationsOKResponse} for
 *                      more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getAllAssetCurrentLocations(options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (this.accessToken === null || this.accessToken === undefined || typeof this.accessToken.valueOf() !== 'string') {
      throw new Error('this.accessToken cannot be null or undefined and it must be of type string.');
    }
    if (this.groupId !== null && this.groupId !== undefined && typeof this.groupId !== 'number') {
      throw new Error('this.groupId must be of type number.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'fleet/assets/locations';
  let queryParameters = [];
  queryParameters.push('access_token=' + encodeURIComponent(this.accessToken));
  if (this.groupId !== null && this.groupId !== undefined) {
    queryParameters.push('group_id=' + encodeURIComponent(this.groupId.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedErrorResponse',
            type: {
              name: 'String'
            }
          };
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['GetAllAssetCurrentLocationsOKResponse']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary /fleet/assets/{assetId:[0-9]+}/locations
 *
 * Fetch the historical locations for the asset.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {array} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getAssetLocation(options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (this.accessToken === null || this.accessToken === undefined || typeof this.accessToken.valueOf() !== 'string') {
      throw new Error('this.accessToken cannot be null or undefined and it must be of type string.');
    }
    if (this.assetId === null || this.assetId === undefined || typeof this.assetId !== 'number') {
      throw new Error('this.assetId cannot be null or undefined and it must be of type number.');
    }
    if (this.startMs === null || this.startMs === undefined || typeof this.startMs !== 'number') {
      throw new Error('this.startMs cannot be null or undefined and it must be of type number.');
    }
    if (this.endMs === null || this.endMs === undefined || typeof this.endMs !== 'number') {
      throw new Error('this.endMs cannot be null or undefined and it must be of type number.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'fleet/assets/{asset_id}/locations';
  requestUrl = requestUrl.replace('{asset_id}', encodeURIComponent(this.assetId.toString()));
  let queryParameters = [];
  queryParameters.push('access_token=' + encodeURIComponent(this.accessToken));
  queryParameters.push('startMs=' + encodeURIComponent(this.startMs.toString()));
  queryParameters.push('endMs=' + encodeURIComponent(this.endMs.toString()));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedErrorResponse',
            type: {
              name: 'String'
            }
          };
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Sequence',
              element: {
                  required: false,
                  serializedName: 'AssetLocationResponseItemElementType',
                  type: {
                    name: 'Composite',
                    className: 'AssetLocationResponseItem'
                  }
              }
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary /fleet/assets/{assetId:[0-9]+}/reefer
 *
 * Fetch the reefer-specific stats of an asset.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link AssetReeferResponse} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getAssetReefer(options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (this.accessToken === null || this.accessToken === undefined || typeof this.accessToken.valueOf() !== 'string') {
      throw new Error('this.accessToken cannot be null or undefined and it must be of type string.');
    }
    if (this.assetId === null || this.assetId === undefined || typeof this.assetId !== 'number') {
      throw new Error('this.assetId cannot be null or undefined and it must be of type number.');
    }
    if (this.startMs === null || this.startMs === undefined || typeof this.startMs !== 'number') {
      throw new Error('this.startMs cannot be null or undefined and it must be of type number.');
    }
    if (this.endMs === null || this.endMs === undefined || typeof this.endMs !== 'number') {
      throw new Error('this.endMs cannot be null or undefined and it must be of type number.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'fleet/assets/{asset_id}/reefer';
  requestUrl = requestUrl.replace('{asset_id}', encodeURIComponent(this.assetId.toString()));
  let queryParameters = [];
  queryParameters.push('access_token=' + encodeURIComponent(this.accessToken));
  queryParameters.push('startMs=' + encodeURIComponent(this.startMs.toString()));
  queryParameters.push('endMs=' + encodeURIComponent(this.endMs.toString()));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedErrorResponse',
            type: {
              name: 'String'
            }
          };
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['AssetReeferResponse']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary /fleet/dispatch/routes
 *
 * Fetch all of the dispatch routes for the group.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {array} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _fetchAllDispatchRoutes(options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (this.accessToken === null || this.accessToken === undefined || typeof this.accessToken.valueOf() !== 'string') {
      throw new Error('this.accessToken cannot be null or undefined and it must be of type string.');
    }
    if (this.groupId !== null && this.groupId !== undefined && typeof this.groupId !== 'number') {
      throw new Error('this.groupId must be of type number.');
    }
    if (this.endTime !== null && this.endTime !== undefined && typeof this.endTime !== 'number') {
      throw new Error('this.endTime must be of type number.');
    }
    if (this.duration !== null && this.duration !== undefined && typeof this.duration !== 'number') {
      throw new Error('this.duration must be of type number.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'fleet/dispatch/routes';
  let queryParameters = [];
  queryParameters.push('access_token=' + encodeURIComponent(this.accessToken));
  if (this.groupId !== null && this.groupId !== undefined) {
    queryParameters.push('group_id=' + encodeURIComponent(this.groupId.toString()));
  }
  if (this.endTime !== null && this.endTime !== undefined) {
    queryParameters.push('end_time=' + encodeURIComponent(this.endTime.toString()));
  }
  if (this.duration !== null && this.duration !== undefined) {
    queryParameters.push('duration=' + encodeURIComponent(this.duration.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedErrorResponse',
            type: {
              name: 'String'
            }
          };
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Sequence',
              element: {
                  required: false,
                  serializedName: 'DispatchRouteElementType',
                  type: {
                    name: 'Composite',
                    className: 'DispatchRoute'
                  }
              }
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary /fleet/dispatch/routes
 *
 * Create a new dispatch route.
 *
 * @param {object} createDispatchRouteParams
 *
 * @param {array} createDispatchRouteParams.dispatchJobs The dispatch jobs to
 * create for this route.
 *
 * @param {number} [createDispatchRouteParams.actualEndMs] The time in Unix
 * epoch milliseconds that the route actually ended.
 *
 * @param {number} [createDispatchRouteParams.actualStartMs] The time in Unix
 * epoch milliseconds that the route actually started.
 *
 * @param {number} [createDispatchRouteParams.driverId] ID of the driver
 * assigned to the dispatch route. Note that driver_id and vehicle_id are
 * mutually exclusive. If neither is specified, then the route is unassigned.
 *
 * @param {number} [createDispatchRouteParams.groupId] ID of the group if the
 * organization has multiple groups (optional).
 *
 * @param {string} createDispatchRouteParams.name Descriptive name of this
 * route.
 *
 * @param {number} createDispatchRouteParams.scheduledEndMs The time in Unix
 * epoch milliseconds that the last job in the route is scheduled to end.
 *
 * @param {number} [createDispatchRouteParams.scheduledMeters] The distance
 * expected to be traveled for this route in meters.
 *
 * @param {number} createDispatchRouteParams.scheduledStartMs The time in Unix
 * epoch milliseconds that the route is scheduled to start.
 *
 * @param {string} [createDispatchRouteParams.startLocationAddress] The address
 * of the route's starting location, as it would be recognized if provided to
 * maps.google.com. Optional if a valid start location address ID is provided.
 *
 * @param {number} [createDispatchRouteParams.startLocationAddressId] ID of the
 * start location associated with an address book entry. Optional if valid
 * values are provided for start location address or latitude/longitude. If a
 * valid start location address ID is provided, address/latitude/longitude will
 * be used from the address book entry. Name of the address book entry will
 * only be used if the start location name is not provided.
 *
 * @param {number} [createDispatchRouteParams.startLocationLat] Latitude of the
 * start location in decimal degrees. Optional if a valid start location
 * address ID is provided.
 *
 * @param {number} [createDispatchRouteParams.startLocationLng] Longitude of
 * the start location in decimal degrees. Optional if a valid start location
 * address ID is provided.
 *
 * @param {string} [createDispatchRouteParams.startLocationName] The name of
 * the route's starting location. If provided, it will take precedence over the
 * name of the address book entry.
 *
 * @param {number} [createDispatchRouteParams.trailerId] ID of the trailer
 * assigned to the dispatch route. Note that trailers can only be assigned to
 * routes that have a Vehicle or Driver assigned to them.
 *
 * @param {number} [createDispatchRouteParams.vehicleId] ID of the vehicle
 * assigned to the dispatch route. Note that vehicle_id and driver_id are
 * mutually exclusive. If neither is specified, then the route is unassigned.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link DispatchRoute} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _createDispatchRoute(createDispatchRouteParams, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (this.accessToken === null || this.accessToken === undefined || typeof this.accessToken.valueOf() !== 'string') {
      throw new Error('this.accessToken cannot be null or undefined and it must be of type string.');
    }
    if (createDispatchRouteParams === null || createDispatchRouteParams === undefined) {
      throw new Error('createDispatchRouteParams cannot be null or undefined.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'fleet/dispatch/routes';
  let queryParameters = [];
  queryParameters.push('access_token=' + encodeURIComponent(this.accessToken));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (createDispatchRouteParams !== null && createDispatchRouteParams !== undefined) {
      let requestModelMapper = new client.models['DispatchRouteCreate']().mapper();
      requestModel = client.serialize(requestModelMapper, createDispatchRouteParams, 'createDispatchRouteParams');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(createDispatchRouteParams, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedErrorResponse',
            type: {
              name: 'String'
            }
          };
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['DispatchRoute']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary /fleet/dispatch/routes/job_updates
 *
 * Fetch all updates to a job including route data in the last 24 hours or
 * subsequent to an sequence ID
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link AllRouteJobUpdates} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _fetchAllRouteJobUpdates(options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (this.accessToken === null || this.accessToken === undefined || typeof this.accessToken.valueOf() !== 'string') {
      throw new Error('this.accessToken cannot be null or undefined and it must be of type string.');
    }
    if (this.groupId !== null && this.groupId !== undefined && typeof this.groupId !== 'number') {
      throw new Error('this.groupId must be of type number.');
    }
    if (this.sequenceId !== null && this.sequenceId !== undefined && typeof this.sequenceId.valueOf() !== 'string') {
      throw new Error('this.sequenceId must be of type string.');
    }
    if (this.include !== null && this.include !== undefined && typeof this.include.valueOf() !== 'string') {
      throw new Error('this.include must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'fleet/dispatch/routes/job_updates';
  let queryParameters = [];
  queryParameters.push('access_token=' + encodeURIComponent(this.accessToken));
  if (this.groupId !== null && this.groupId !== undefined) {
    queryParameters.push('group_id=' + encodeURIComponent(this.groupId.toString()));
  }
  if (this.sequenceId !== null && this.sequenceId !== undefined) {
    queryParameters.push('sequence_id=' + encodeURIComponent(this.sequenceId));
  }
  if (this.include !== null && this.include !== undefined) {
    queryParameters.push('include=' + encodeURIComponent(this.include));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedErrorResponse',
            type: {
              name: 'String'
            }
          };
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['AllRouteJobUpdates']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary /fleet/dispatch/routes/{route_id:[0-9]+}
 *
 * Fetch a dispatch route by id.
 *
 * @param {number} routeId ID of the dispatch route.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link DispatchRoute} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getDispatchRouteById(routeId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (this.accessToken === null || this.accessToken === undefined || typeof this.accessToken.valueOf() !== 'string') {
      throw new Error('this.accessToken cannot be null or undefined and it must be of type string.');
    }
    if (routeId === null || routeId === undefined || typeof routeId !== 'number') {
      throw new Error('routeId cannot be null or undefined and it must be of type number.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'fleet/dispatch/routes/{route_id}';
  requestUrl = requestUrl.replace('{route_id}', encodeURIComponent(routeId.toString()));
  let queryParameters = [];
  queryParameters.push('access_token=' + encodeURIComponent(this.accessToken));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedErrorResponse',
            type: {
              name: 'String'
            }
          };
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['DispatchRoute']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary /fleet/dispatch/routes/{route_id:[0-9]+}/
 *
 * Update a dispatch route and its associated jobs.
 *
 * @param {object} updateDispatchRouteParams
 *
 * @param {array} updateDispatchRouteParams.dispatchJobs The dispatch jobs
 * associated with this route.
 *
 * @param {number} updateDispatchRouteParams.id ID of the Samsara dispatch
 * route.
 *
 * @param {number} [updateDispatchRouteParams.actualEndMs] The time in Unix
 * epoch milliseconds that the route actually ended.
 *
 * @param {number} [updateDispatchRouteParams.actualStartMs] The time in Unix
 * epoch milliseconds that the route actually started.
 *
 * @param {number} [updateDispatchRouteParams.driverId] ID of the driver
 * assigned to the dispatch route. Note that driver_id and vehicle_id are
 * mutually exclusive. If neither is specified, then the route is unassigned.
 *
 * @param {number} [updateDispatchRouteParams.groupId] ID of the group if the
 * organization has multiple groups (optional).
 *
 * @param {string} updateDispatchRouteParams.name Descriptive name of this
 * route.
 *
 * @param {number} updateDispatchRouteParams.scheduledEndMs The time in Unix
 * epoch milliseconds that the last job in the route is scheduled to end.
 *
 * @param {number} [updateDispatchRouteParams.scheduledMeters] The distance
 * expected to be traveled for this route in meters.
 *
 * @param {number} updateDispatchRouteParams.scheduledStartMs The time in Unix
 * epoch milliseconds that the route is scheduled to start.
 *
 * @param {string} [updateDispatchRouteParams.startLocationAddress] The address
 * of the route's starting location, as it would be recognized if provided to
 * maps.google.com. Optional if a valid start location address ID is provided.
 *
 * @param {number} [updateDispatchRouteParams.startLocationAddressId] ID of the
 * start location associated with an address book entry. Optional if valid
 * values are provided for start location address or latitude/longitude. If a
 * valid start location address ID is provided, address/latitude/longitude will
 * be used from the address book entry. Name of the address book entry will
 * only be used if the start location name is not provided.
 *
 * @param {number} [updateDispatchRouteParams.startLocationLat] Latitude of the
 * start location in decimal degrees. Optional if a valid start location
 * address ID is provided.
 *
 * @param {number} [updateDispatchRouteParams.startLocationLng] Longitude of
 * the start location in decimal degrees. Optional if a valid start location
 * address ID is provided.
 *
 * @param {string} [updateDispatchRouteParams.startLocationName] The name of
 * the route's starting location. If provided, it will take precedence over the
 * name of the address book entry.
 *
 * @param {number} [updateDispatchRouteParams.trailerId] ID of the trailer
 * assigned to the dispatch route. Note that trailers can only be assigned to
 * routes that have a Vehicle or Driver assigned to them.
 *
 * @param {number} [updateDispatchRouteParams.vehicleId] ID of the vehicle
 * assigned to the dispatch route. Note that vehicle_id and driver_id are
 * mutually exclusive. If neither is specified, then the route is unassigned.
 *
 * @param {number} routeId ID of the dispatch route.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link DispatchRoute} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _updateDispatchRouteById(updateDispatchRouteParams, routeId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (updateDispatchRouteParams === null || updateDispatchRouteParams === undefined) {
      throw new Error('updateDispatchRouteParams cannot be null or undefined.');
    }
    if (this.accessToken === null || this.accessToken === undefined || typeof this.accessToken.valueOf() !== 'string') {
      throw new Error('this.accessToken cannot be null or undefined and it must be of type string.');
    }
    if (routeId === null || routeId === undefined || typeof routeId !== 'number') {
      throw new Error('routeId cannot be null or undefined and it must be of type number.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'fleet/dispatch/routes/{route_id}';
  requestUrl = requestUrl.replace('{route_id}', encodeURIComponent(routeId.toString()));
  let queryParameters = [];
  queryParameters.push('access_token=' + encodeURIComponent(this.accessToken));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (updateDispatchRouteParams !== null && updateDispatchRouteParams !== undefined) {
      let requestModelMapper = new client.models['DispatchRoute']().mapper();
      requestModel = client.serialize(requestModelMapper, updateDispatchRouteParams, 'updateDispatchRouteParams');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(updateDispatchRouteParams, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedErrorResponse',
            type: {
              name: 'String'
            }
          };
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['DispatchRoute']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary /fleet/dispatch/routes/{route_id:[0-9]+}/
 *
 * Delete a dispatch route and its associated jobs.
 *
 * @param {number} routeId ID of the dispatch route.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deleteDispatchRouteById(routeId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (this.accessToken === null || this.accessToken === undefined || typeof this.accessToken.valueOf() !== 'string') {
      throw new Error('this.accessToken cannot be null or undefined and it must be of type string.');
    }
    if (routeId === null || routeId === undefined || typeof routeId !== 'number') {
      throw new Error('routeId cannot be null or undefined and it must be of type number.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'fleet/dispatch/routes/{route_id}';
  requestUrl = requestUrl.replace('{route_id}', encodeURIComponent(routeId.toString()));
  let queryParameters = [];
  queryParameters.push('access_token=' + encodeURIComponent(this.accessToken));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedErrorResponse',
            type: {
              name: 'String'
            }
          };
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary /fleet/dispatch/routes/{route_id:[0-9]+}/history
 *
 * Fetch the history of a dispatch route.
 *
 * @param {number} routeId ID of the route with history.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link DispatchRouteHistory} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getDispatchRouteHistory(routeId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (this.accessToken === null || this.accessToken === undefined || typeof this.accessToken.valueOf() !== 'string') {
      throw new Error('this.accessToken cannot be null or undefined and it must be of type string.');
    }
    if (this.startTime !== null && this.startTime !== undefined && typeof this.startTime !== 'number') {
      throw new Error('this.startTime must be of type number.');
    }
    if (this.endTime !== null && this.endTime !== undefined && typeof this.endTime !== 'number') {
      throw new Error('this.endTime must be of type number.');
    }
    if (routeId === null || routeId === undefined || typeof routeId !== 'number') {
      throw new Error('routeId cannot be null or undefined and it must be of type number.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'fleet/dispatch/routes/{route_id}/history';
  requestUrl = requestUrl.replace('{route_id}', encodeURIComponent(routeId.toString()));
  let queryParameters = [];
  queryParameters.push('access_token=' + encodeURIComponent(this.accessToken));
  if (this.startTime !== null && this.startTime !== undefined) {
    queryParameters.push('start_time=' + encodeURIComponent(this.startTime.toString()));
  }
  if (this.endTime !== null && this.endTime !== undefined) {
    queryParameters.push('end_time=' + encodeURIComponent(this.endTime.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedErrorResponse',
            type: {
              name: 'String'
            }
          };
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['DispatchRouteHistory']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary /fleet/drivers/create
 *
 * Create a new driver.
 *
 * @param {object} createDriverParam Driver creation body
 *
 * @param {string} createDriverParam.password Driver's password for the driver
 * app.
 *
 * @param {array} [createDriverParam.tagIds]
 *
 * @param {boolean} [createDriverParam.eldAdverseWeatherExemptionEnabled] Flag
 * indicating this driver may use Adverse Weather exemptions in ELD logs.
 *
 * @param {boolean} [createDriverParam.eldBigDayExemptionEnabled] Flag
 * indicating this driver may use Big Day excemptions in ELD logs.
 *
 * @param {number} [createDriverParam.eldDayStartHour] 0 indicating
 * midnight-to-midnight ELD driving hours, 12 to indicate noon-to-noon driving
 * hours.
 *
 * @param {boolean} [createDriverParam.eldExempt] Flag indicating this driver
 * is exempt from the Electronic Logging Mandate.
 *
 * @param {string} [createDriverParam.eldExemptReason] Reason that this driver
 * is exempt from the Electronic Logging Mandate (see eldExempt).
 *
 * @param {boolean} [createDriverParam.eldPcEnabled] Flag indicating this
 * driver may select the Personal Conveyance duty status in ELD logs.
 *
 * @param {boolean} [createDriverParam.eldYmEnabled] Flag indicating this
 * driver may select the Yard Move duty status in ELD logs.
 *
 * @param {object} [createDriverParam.externalIds] Dictionary of external IDs
 * (string key-value pairs)
 *
 * @param {number} [createDriverParam.groupId] ID of the group if the
 * organization has multiple groups (uncommon).
 *
 * @param {string} [createDriverParam.licenseNumber] Driver's state issued
 * license number.
 *
 * @param {string} [createDriverParam.licenseState] Abbreviation of state that
 * issued driver's license.
 *
 * @param {string} createDriverParam.name Driver's name.
 *
 * @param {string} [createDriverParam.notes] Notes about the driver.
 *
 * @param {string} [createDriverParam.phone] Driver's phone number. Please
 * include only digits, ex. 4157771234
 *
 * @param {string} [createDriverParam.username] Driver's login username into
 * the driver app.
 *
 * @param {number} [createDriverParam.vehicleId] ID of the vehicle assigned to
 * the driver for static vehicle assignments. (uncommon).
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link CurrentDriver} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _createDriver(createDriverParam, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (this.accessToken === null || this.accessToken === undefined || typeof this.accessToken.valueOf() !== 'string') {
      throw new Error('this.accessToken cannot be null or undefined and it must be of type string.');
    }
    if (createDriverParam === null || createDriverParam === undefined) {
      throw new Error('createDriverParam cannot be null or undefined.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'fleet/drivers/create';
  let queryParameters = [];
  queryParameters.push('access_token=' + encodeURIComponent(this.accessToken));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (createDriverParam !== null && createDriverParam !== undefined) {
      let requestModelMapper = new client.models['DriverForCreate']().mapper();
      requestModel = client.serialize(requestModelMapper, createDriverParam, 'createDriverParam');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(createDriverParam, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedErrorResponse',
            type: {
              name: 'String'
            }
          };
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['CurrentDriver']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary /fleet/drivers/document_types
 *
 * Fetch all of the document types.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {array} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getDriverDocumentTypesByOrgId(options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'fleet/drivers/document_types';

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedErrorResponse',
            type: {
              name: 'String'
            }
          };
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Sequence',
              element: {
                  required: false,
                  serializedName: 'DocumentTypeElementType',
                  type: {
                    name: 'Composite',
                    className: 'DocumentType'
                  }
              }
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary /fleet/drivers/documents
 *
 * Fetch all of the documents.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {array} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getDriverDocumentsByOrgId(options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (this.endMs !== null && this.endMs !== undefined && typeof this.endMs !== 'number') {
      throw new Error('this.endMs must be of type number.');
    }
    if (this.durationMs !== null && this.durationMs !== undefined && typeof this.durationMs !== 'number') {
      throw new Error('this.durationMs must be of type number.');
    }
    if (this.accessToken === null || this.accessToken === undefined || typeof this.accessToken.valueOf() !== 'string') {
      throw new Error('this.accessToken cannot be null or undefined and it must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'fleet/drivers/documents';
  let queryParameters = [];
  if (this.endMs !== null && this.endMs !== undefined) {
    queryParameters.push('endMs=' + encodeURIComponent(this.endMs.toString()));
  }
  if (this.durationMs !== null && this.durationMs !== undefined) {
    queryParameters.push('durationMs=' + encodeURIComponent(this.durationMs.toString()));
  }
  queryParameters.push('access_token=' + encodeURIComponent(this.accessToken));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedErrorResponse',
            type: {
              name: 'String'
            }
          };
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Sequence',
              element: {
                  required: false,
                  serializedName: 'DocumentElementType',
                  type: {
                    name: 'Composite',
                    className: 'Document'
                  }
              }
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary /fleet/drivers/inactive
 *
 * Fetch all deactivated drivers for the group.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {array} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getAllDeactivatedDrivers(options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (this.accessToken === null || this.accessToken === undefined || typeof this.accessToken.valueOf() !== 'string') {
      throw new Error('this.accessToken cannot be null or undefined and it must be of type string.');
    }
    if (this.groupId !== null && this.groupId !== undefined && typeof this.groupId !== 'number') {
      throw new Error('this.groupId must be of type number.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'fleet/drivers/inactive';
  let queryParameters = [];
  queryParameters.push('access_token=' + encodeURIComponent(this.accessToken));
  if (this.groupId !== null && this.groupId !== undefined) {
    queryParameters.push('group_id=' + encodeURIComponent(this.groupId.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedErrorResponse',
            type: {
              name: 'String'
            }
          };
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Sequence',
              element: {
                  required: false,
                  serializedName: 'CurrentDriverElementType',
                  type: {
                    name: 'Composite',
                    className: 'CurrentDriver'
                  }
              }
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary /fleet/drivers/inactive/{driver_id:[0-9]+ |
 * external_id:[a-zA-Z0-9]+}
 *
 * Fetch deactivated driver by id.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link CurrentDriver} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getDeactivatedDriverById(options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (this.accessToken === null || this.accessToken === undefined || typeof this.accessToken.valueOf() !== 'string') {
      throw new Error('this.accessToken cannot be null or undefined and it must be of type string.');
    }
    if (this.driverIdOrExternalId === null || this.driverIdOrExternalId === undefined || typeof this.driverIdOrExternalId.valueOf() !== 'string') {
      throw new Error('this.driverIdOrExternalId cannot be null or undefined and it must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'fleet/drivers/inactive/{driver_id_or_external_id}';
  requestUrl = requestUrl.replace('{driver_id_or_external_id}', encodeURIComponent(this.driverIdOrExternalId));
  let queryParameters = [];
  queryParameters.push('access_token=' + encodeURIComponent(this.accessToken));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedErrorResponse',
            type: {
              name: 'String'
            }
          };
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['CurrentDriver']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary /fleet/drivers/inactive/{driver_id:[0-9]+ |
 * external_id:[a-zA-Z0-9]+}
 *
 * Reactivate the inactive driver having id.
 *
 * @param {object} reactivateDriverParam Driver reactivation body
 *
 * @param {boolean} reactivateDriverParam.reactivate True indicates that this
 * driver should be reactivated.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link CurrentDriver} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _reactivateDriverById(reactivateDriverParam, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (reactivateDriverParam === null || reactivateDriverParam === undefined) {
      throw new Error('reactivateDriverParam cannot be null or undefined.');
    }
    if (this.accessToken === null || this.accessToken === undefined || typeof this.accessToken.valueOf() !== 'string') {
      throw new Error('this.accessToken cannot be null or undefined and it must be of type string.');
    }
    if (this.driverIdOrExternalId === null || this.driverIdOrExternalId === undefined || typeof this.driverIdOrExternalId.valueOf() !== 'string') {
      throw new Error('this.driverIdOrExternalId cannot be null or undefined and it must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'fleet/drivers/inactive/{driver_id_or_external_id}';
  requestUrl = requestUrl.replace('{driver_id_or_external_id}', encodeURIComponent(this.driverIdOrExternalId));
  let queryParameters = [];
  queryParameters.push('access_token=' + encodeURIComponent(this.accessToken));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (reactivateDriverParam !== null && reactivateDriverParam !== undefined) {
      let requestModelMapper = new client.models['ReactivateDriverParam']().mapper();
      requestModel = client.serialize(requestModelMapper, reactivateDriverParam, 'reactivateDriverParam');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(reactivateDriverParam, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedErrorResponse',
            type: {
              name: 'String'
            }
          };
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['CurrentDriver']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary /fleet/drivers/{driverId:[0-9]+}/safety/score
 *
 * Fetch the safety score for the driver.
 *
 * @param {number} driverId ID of the driver
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link DriverSafetyScoreResponse} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getDriverSafetyScore(driverId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (this.accessToken === null || this.accessToken === undefined || typeof this.accessToken.valueOf() !== 'string') {
      throw new Error('this.accessToken cannot be null or undefined and it must be of type string.');
    }
    if (this.startMs === null || this.startMs === undefined || typeof this.startMs !== 'number') {
      throw new Error('this.startMs cannot be null or undefined and it must be of type number.');
    }
    if (this.endMs === null || this.endMs === undefined || typeof this.endMs !== 'number') {
      throw new Error('this.endMs cannot be null or undefined and it must be of type number.');
    }
    if (driverId === null || driverId === undefined || typeof driverId !== 'number') {
      throw new Error('driverId cannot be null or undefined and it must be of type number.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'fleet/drivers/{driverId}/safety/score';
  requestUrl = requestUrl.replace('{driverId}', encodeURIComponent(driverId.toString()));
  let queryParameters = [];
  queryParameters.push('access_token=' + encodeURIComponent(this.accessToken));
  queryParameters.push('startMs=' + encodeURIComponent(this.startMs.toString()));
  queryParameters.push('endMs=' + encodeURIComponent(this.endMs.toString()));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedErrorResponse',
            type: {
              name: 'String'
            }
          };
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['DriverSafetyScoreResponse']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary /fleet/drivers/{driver_id:[0-9]+ | external_id:[a-zA-Z0-9]+}
 *
 * Fetch driver by id.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link CurrentDriver} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getDriverById(options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (this.accessToken === null || this.accessToken === undefined || typeof this.accessToken.valueOf() !== 'string') {
      throw new Error('this.accessToken cannot be null or undefined and it must be of type string.');
    }
    if (this.driverIdOrExternalId === null || this.driverIdOrExternalId === undefined || typeof this.driverIdOrExternalId.valueOf() !== 'string') {
      throw new Error('this.driverIdOrExternalId cannot be null or undefined and it must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'fleet/drivers/{driver_id_or_external_id}';
  requestUrl = requestUrl.replace('{driver_id_or_external_id}', encodeURIComponent(this.driverIdOrExternalId));
  let queryParameters = [];
  queryParameters.push('access_token=' + encodeURIComponent(this.accessToken));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedErrorResponse',
            type: {
              name: 'String'
            }
          };
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['CurrentDriver']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary /fleet/drivers/{driver_id:[0-9]+ | external_id:[a-zA-Z0-9]+}
 *
 * Deactivate a driver with the given id.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deactivateDriver(options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (this.accessToken === null || this.accessToken === undefined || typeof this.accessToken.valueOf() !== 'string') {
      throw new Error('this.accessToken cannot be null or undefined and it must be of type string.');
    }
    if (this.driverIdOrExternalId === null || this.driverIdOrExternalId === undefined || typeof this.driverIdOrExternalId.valueOf() !== 'string') {
      throw new Error('this.driverIdOrExternalId cannot be null or undefined and it must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'fleet/drivers/{driver_id_or_external_id}';
  requestUrl = requestUrl.replace('{driver_id_or_external_id}', encodeURIComponent(this.driverIdOrExternalId));
  let queryParameters = [];
  queryParameters.push('access_token=' + encodeURIComponent(this.accessToken));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedErrorResponse',
            type: {
              name: 'String'
            }
          };
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary /fleet/drivers/{driver_id:[0-9]+}/dispatch/routes
 *
 * Fetch all of the dispatch routes for a given driver.
 *
 * @param {number} driverId ID of the driver with the associated routes.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {array} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getDispatchRoutesByDriverId(driverId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (this.endTime !== null && this.endTime !== undefined && typeof this.endTime !== 'number') {
      throw new Error('this.endTime must be of type number.');
    }
    if (this.duration !== null && this.duration !== undefined && typeof this.duration !== 'number') {
      throw new Error('this.duration must be of type number.');
    }
    if (this.accessToken === null || this.accessToken === undefined || typeof this.accessToken.valueOf() !== 'string') {
      throw new Error('this.accessToken cannot be null or undefined and it must be of type string.');
    }
    if (driverId === null || driverId === undefined || typeof driverId !== 'number') {
      throw new Error('driverId cannot be null or undefined and it must be of type number.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'fleet/drivers/{driver_id}/dispatch/routes';
  requestUrl = requestUrl.replace('{driver_id}', encodeURIComponent(driverId.toString()));
  let queryParameters = [];
  if (this.endTime !== null && this.endTime !== undefined) {
    queryParameters.push('end_time=' + encodeURIComponent(this.endTime.toString()));
  }
  if (this.duration !== null && this.duration !== undefined) {
    queryParameters.push('duration=' + encodeURIComponent(this.duration.toString()));
  }
  queryParameters.push('access_token=' + encodeURIComponent(this.accessToken));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedErrorResponse',
            type: {
              name: 'String'
            }
          };
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Sequence',
              element: {
                  required: false,
                  serializedName: 'DispatchRouteElementType',
                  type: {
                    name: 'Composite',
                    className: 'DispatchRoute'
                  }
              }
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary /fleet/drivers/{driver_id:[0-9]+}/dispatch/routes
 *
 * Create a new dispatch route for the driver with driver_id.
 *
 * @param {object} createDispatchRouteParams
 *
 * @param {array} createDispatchRouteParams.dispatchJobs The dispatch jobs to
 * create for this route.
 *
 * @param {number} [createDispatchRouteParams.actualEndMs] The time in Unix
 * epoch milliseconds that the route actually ended.
 *
 * @param {number} [createDispatchRouteParams.actualStartMs] The time in Unix
 * epoch milliseconds that the route actually started.
 *
 * @param {number} [createDispatchRouteParams.driverId] ID of the driver
 * assigned to the dispatch route. Note that driver_id and vehicle_id are
 * mutually exclusive. If neither is specified, then the route is unassigned.
 *
 * @param {number} [createDispatchRouteParams.groupId] ID of the group if the
 * organization has multiple groups (optional).
 *
 * @param {string} createDispatchRouteParams.name Descriptive name of this
 * route.
 *
 * @param {number} createDispatchRouteParams.scheduledEndMs The time in Unix
 * epoch milliseconds that the last job in the route is scheduled to end.
 *
 * @param {number} [createDispatchRouteParams.scheduledMeters] The distance
 * expected to be traveled for this route in meters.
 *
 * @param {number} createDispatchRouteParams.scheduledStartMs The time in Unix
 * epoch milliseconds that the route is scheduled to start.
 *
 * @param {string} [createDispatchRouteParams.startLocationAddress] The address
 * of the route's starting location, as it would be recognized if provided to
 * maps.google.com. Optional if a valid start location address ID is provided.
 *
 * @param {number} [createDispatchRouteParams.startLocationAddressId] ID of the
 * start location associated with an address book entry. Optional if valid
 * values are provided for start location address or latitude/longitude. If a
 * valid start location address ID is provided, address/latitude/longitude will
 * be used from the address book entry. Name of the address book entry will
 * only be used if the start location name is not provided.
 *
 * @param {number} [createDispatchRouteParams.startLocationLat] Latitude of the
 * start location in decimal degrees. Optional if a valid start location
 * address ID is provided.
 *
 * @param {number} [createDispatchRouteParams.startLocationLng] Longitude of
 * the start location in decimal degrees. Optional if a valid start location
 * address ID is provided.
 *
 * @param {string} [createDispatchRouteParams.startLocationName] The name of
 * the route's starting location. If provided, it will take precedence over the
 * name of the address book entry.
 *
 * @param {number} [createDispatchRouteParams.trailerId] ID of the trailer
 * assigned to the dispatch route. Note that trailers can only be assigned to
 * routes that have a Vehicle or Driver assigned to them.
 *
 * @param {number} [createDispatchRouteParams.vehicleId] ID of the vehicle
 * assigned to the dispatch route. Note that vehicle_id and driver_id are
 * mutually exclusive. If neither is specified, then the route is unassigned.
 *
 * @param {number} driverId ID of the driver with the associated routes.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link DispatchRoute} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _createDriverDispatchRoute(createDispatchRouteParams, driverId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (createDispatchRouteParams === null || createDispatchRouteParams === undefined) {
      throw new Error('createDispatchRouteParams cannot be null or undefined.');
    }
    if (this.accessToken === null || this.accessToken === undefined || typeof this.accessToken.valueOf() !== 'string') {
      throw new Error('this.accessToken cannot be null or undefined and it must be of type string.');
    }
    if (driverId === null || driverId === undefined || typeof driverId !== 'number') {
      throw new Error('driverId cannot be null or undefined and it must be of type number.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'fleet/drivers/{driver_id}/dispatch/routes';
  requestUrl = requestUrl.replace('{driver_id}', encodeURIComponent(driverId.toString()));
  let queryParameters = [];
  queryParameters.push('access_token=' + encodeURIComponent(this.accessToken));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (createDispatchRouteParams !== null && createDispatchRouteParams !== undefined) {
      let requestModelMapper = new client.models['DispatchRouteCreate']().mapper();
      requestModel = client.serialize(requestModelMapper, createDispatchRouteParams, 'createDispatchRouteParams');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(createDispatchRouteParams, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedErrorResponse',
            type: {
              name: 'String'
            }
          };
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['DispatchRoute']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary /fleet/drivers/{driver_id:[0-9]+}/documents
 *
 * Create a driver document for the given driver.
 *
 * @param {object} createDocumentParams To create a document for a given
 * document type, the document type's uuid needs to be passed in to
 * documentTypeUuid. The list of fields passed in should match the document
 * types list of field types in the correct order. In other words, a field's
 * valueType and value (i.e. only one of: stringValue, numberValue, or
 * photoValue) at index _i_ should match with the document field types
 * valueType at index _i_.
 *
 * @param {string} createDocumentParams.documentTypeUuid Universally unique
 * identifier for the document type this document is being created for.
 *
 * @param {array} createDocumentParams.fields List of fields should match the
 * document types list of field types in the correct order. In other words, a
 * field's valueType and value (i.e. only one of: stringValue, numberValue, or
 * photoValue) at index _i_ should match with the document field types
 * valueType at index _i_.
 *
 * @param {number} [createDocumentParams.dispatchJobId] ID of the Samsara
 * dispatch job for which the document is submitted
 *
 * @param {string} [createDocumentParams.notes] Notes submitted with this
 * document.
 *
 * @param {number} driverId ID of the driver for whom the document is created.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link Document} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _createDriverDocument(createDocumentParams, driverId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (createDocumentParams === null || createDocumentParams === undefined) {
      throw new Error('createDocumentParams cannot be null or undefined.');
    }
    if (this.accessToken === null || this.accessToken === undefined || typeof this.accessToken.valueOf() !== 'string') {
      throw new Error('this.accessToken cannot be null or undefined and it must be of type string.');
    }
    if (driverId === null || driverId === undefined || typeof driverId !== 'number') {
      throw new Error('driverId cannot be null or undefined and it must be of type number.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'fleet/drivers/{driver_id}/documents';
  requestUrl = requestUrl.replace('{driver_id}', encodeURIComponent(driverId.toString()));
  let queryParameters = [];
  queryParameters.push('access_token=' + encodeURIComponent(this.accessToken));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (createDocumentParams !== null && createDocumentParams !== undefined) {
      let requestModelMapper = new client.models['DocumentCreate']().mapper();
      requestModel = client.serialize(requestModelMapper, createDocumentParams, 'createDocumentParams');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(createDocumentParams, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedErrorResponse',
            type: {
              name: 'String'
            }
          };
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['Document']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary /fleet/vehicles/locations
 *
 * Fetch locations for a given vehicle between a start/end time. The maximum
 * query duration is 30 minutes.
 *
 * @param {number} startMs Time in Unix epoch milliseconds for the start of the
 * query (cannot exceed 30 minutes)
 *
 * @param {number} endMs Time in Unix epoch milliseconds for the end of the
 * query (cannot exceed 30 minutes)
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {array} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getVehiclesLocations(startMs, endMs, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (this.accessToken === null || this.accessToken === undefined || typeof this.accessToken.valueOf() !== 'string') {
      throw new Error('this.accessToken cannot be null or undefined and it must be of type string.');
    }
    if (startMs === null || startMs === undefined || typeof startMs !== 'number') {
      throw new Error('startMs cannot be null or undefined and it must be of type number.');
    }
    if (endMs === null || endMs === undefined || typeof endMs !== 'number') {
      throw new Error('endMs cannot be null or undefined and it must be of type number.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'fleet/vehicles/locations';
  let queryParameters = [];
  queryParameters.push('access_token=' + encodeURIComponent(this.accessToken));
  queryParameters.push('startMs=' + encodeURIComponent(startMs.toString()));
  queryParameters.push('endMs=' + encodeURIComponent(endMs.toString()));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedErrorResponse',
            type: {
              name: 'String'
            }
          };
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Sequence',
              element: {
                  required: false,
                  serializedName: 'FleetVehiclesLocationsItemElementType',
                  type: {
                    name: 'Composite',
                    className: 'FleetVehiclesLocationsItem'
                  }
              }
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary /fleet/vehicles/stats
 *
 * Fetch engine state and aux input data for all vehicles in the group between
 * a start/end time. Data returned may be affected by device connectivity and
 * processing time.
 *
 * @param {number} startMs Time in Unix epoch milliseconds for the start of the
 * query.
 *
 * @param {number} endMs Time in Unix epoch milliseconds for the end of the
 * query.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {string} [options.series] Comma-separated list of stat types. Options
 * are engineState, auxInput1, and auxInput2. If this parameter is excluded,
 * all 3 stat types will be returned. Example: series=engineState,auxInput2.
 * Possible values include: 'engineState', 'auxInput1', 'auxInput2'
 *
 * @param {string} [options.tagIds] Comma-separated list of tag ids. Example:
 * tagIds=1,2,3
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link GetVehicleStatsOKResponse} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getVehicleStats(startMs, endMs, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let series = (options && options.series !== undefined) ? options.series : undefined;
  let tagIds = (options && options.tagIds !== undefined) ? options.tagIds : undefined;
  // Validate
  try {
    if (this.accessToken === null || this.accessToken === undefined || typeof this.accessToken.valueOf() !== 'string') {
      throw new Error('this.accessToken cannot be null or undefined and it must be of type string.');
    }
    if (startMs === null || startMs === undefined || typeof startMs !== 'number') {
      throw new Error('startMs cannot be null or undefined and it must be of type number.');
    }
    if (endMs === null || endMs === undefined || typeof endMs !== 'number') {
      throw new Error('endMs cannot be null or undefined and it must be of type number.');
    }
    if (series !== null && series !== undefined && typeof series.valueOf() !== 'string') {
      throw new Error('series must be of type string.');
    }
    if (tagIds !== null && tagIds !== undefined && typeof tagIds.valueOf() !== 'string') {
      throw new Error('tagIds must be of type string.');
    }
    if (this.startingAfter !== null && this.startingAfter !== undefined && typeof this.startingAfter.valueOf() !== 'string') {
      throw new Error('this.startingAfter must be of type string.');
    }
    if (this.endingBefore !== null && this.endingBefore !== undefined && typeof this.endingBefore.valueOf() !== 'string') {
      throw new Error('this.endingBefore must be of type string.');
    }
    if (this.limit !== null && this.limit !== undefined && typeof this.limit !== 'number') {
      throw new Error('this.limit must be of type number.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'fleet/vehicles/stats';
  let queryParameters = [];
  queryParameters.push('access_token=' + encodeURIComponent(this.accessToken));
  queryParameters.push('startMs=' + encodeURIComponent(startMs.toString()));
  queryParameters.push('endMs=' + encodeURIComponent(endMs.toString()));
  if (series !== null && series !== undefined) {
    queryParameters.push('series=' + encodeURIComponent(series));
  }
  if (tagIds !== null && tagIds !== undefined) {
    queryParameters.push('tagIds=' + encodeURIComponent(tagIds));
  }
  if (this.startingAfter !== null && this.startingAfter !== undefined) {
    queryParameters.push('startingAfter=' + encodeURIComponent(this.startingAfter));
  }
  if (this.endingBefore !== null && this.endingBefore !== undefined) {
    queryParameters.push('endingBefore=' + encodeURIComponent(this.endingBefore));
  }
  if (this.limit !== null && this.limit !== undefined) {
    queryParameters.push('limit=' + encodeURIComponent(this.limit.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedErrorResponse',
            type: {
              name: 'String'
            }
          };
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['GetVehicleStatsOKResponse']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary /fleet/vehicles/{vehicleId:[0-9]+}/safety/harsh_event
 *
 * Fetch harsh event details for a vehicle.
 *
 * @param {number} vehicleId ID of the vehicle
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link VehicleHarshEventResponse} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getVehicleHarshEvent(vehicleId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (this.accessToken === null || this.accessToken === undefined || typeof this.accessToken.valueOf() !== 'string') {
      throw new Error('this.accessToken cannot be null or undefined and it must be of type string.');
    }
    if (this.timestamp === null || this.timestamp === undefined || typeof this.timestamp !== 'number') {
      throw new Error('this.timestamp cannot be null or undefined and it must be of type number.');
    }
    if (vehicleId === null || vehicleId === undefined || typeof vehicleId !== 'number') {
      throw new Error('vehicleId cannot be null or undefined and it must be of type number.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'fleet/vehicles/{vehicleId}/safety/harsh_event';
  requestUrl = requestUrl.replace('{vehicleId}', encodeURIComponent(vehicleId.toString()));
  let queryParameters = [];
  queryParameters.push('access_token=' + encodeURIComponent(this.accessToken));
  queryParameters.push('timestamp=' + encodeURIComponent(this.timestamp.toString()));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedErrorResponse',
            type: {
              name: 'String'
            }
          };
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['VehicleHarshEventResponse']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary /fleet/vehicles/{vehicleId:[0-9]+}/safety/score
 *
 * Fetch the safety score for the vehicle.
 *
 * @param {number} vehicleId ID of the vehicle
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link VehicleSafetyScoreResponse} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getVehicleSafetyScore(vehicleId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (this.accessToken === null || this.accessToken === undefined || typeof this.accessToken.valueOf() !== 'string') {
      throw new Error('this.accessToken cannot be null or undefined and it must be of type string.');
    }
    if (this.startMs === null || this.startMs === undefined || typeof this.startMs !== 'number') {
      throw new Error('this.startMs cannot be null or undefined and it must be of type number.');
    }
    if (this.endMs === null || this.endMs === undefined || typeof this.endMs !== 'number') {
      throw new Error('this.endMs cannot be null or undefined and it must be of type number.');
    }
    if (vehicleId === null || vehicleId === undefined || typeof vehicleId !== 'number') {
      throw new Error('vehicleId cannot be null or undefined and it must be of type number.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'fleet/vehicles/{vehicleId}/safety/score';
  requestUrl = requestUrl.replace('{vehicleId}', encodeURIComponent(vehicleId.toString()));
  let queryParameters = [];
  queryParameters.push('access_token=' + encodeURIComponent(this.accessToken));
  queryParameters.push('startMs=' + encodeURIComponent(this.startMs.toString()));
  queryParameters.push('endMs=' + encodeURIComponent(this.endMs.toString()));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedErrorResponse',
            type: {
              name: 'String'
            }
          };
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['VehicleSafetyScoreResponse']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary /fleet/vehicles/{vehicle_id:[0-9]+ | external_id:[a-zA-Z0-9]+}
 *
 * Gets a specific vehicle.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link FleetVehicleResponse} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getFleetVehicle(options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (this.accessToken === null || this.accessToken === undefined || typeof this.accessToken.valueOf() !== 'string') {
      throw new Error('this.accessToken cannot be null or undefined and it must be of type string.');
    }
    if (this.vehicleIdOrExternalId === null || this.vehicleIdOrExternalId === undefined || typeof this.vehicleIdOrExternalId.valueOf() !== 'string') {
      throw new Error('this.vehicleIdOrExternalId cannot be null or undefined and it must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'fleet/vehicles/{vehicle_id_or_external_id}';
  requestUrl = requestUrl.replace('{vehicle_id_or_external_id}', encodeURIComponent(this.vehicleIdOrExternalId));
  let queryParameters = [];
  queryParameters.push('access_token=' + encodeURIComponent(this.accessToken));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedErrorResponse',
            type: {
              name: 'String'
            }
          };
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['FleetVehicleResponse']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary /fleet/vehicles/{vehicle_id:[0-9]+ | external_id:[a-zA-Z0-9]+}
 *
 * Updates the specified vehicle using JSON merge patch format. See IETF RFC
 * 7396: https://tools.ietf.org/html/rfc7396.
 *
 * @param {object} data
 *
 * @param {object} [data.externalIds]
 *
 * @param {number} [data.harshAccelSetting] Harsh Event Detection Setting
 * * 0: Passenger
 * * 1: Light Truck
 * * 2: Heavy
 * * 3: Off
 * * 4: Automatic
 *
 * @param {string} [data.name] Name
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link FleetVehicleResponse} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _patchFleetVehicle(data, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (this.accessToken === null || this.accessToken === undefined || typeof this.accessToken.valueOf() !== 'string') {
      throw new Error('this.accessToken cannot be null or undefined and it must be of type string.');
    }
    if (this.vehicleIdOrExternalId === null || this.vehicleIdOrExternalId === undefined || typeof this.vehicleIdOrExternalId.valueOf() !== 'string') {
      throw new Error('this.vehicleIdOrExternalId cannot be null or undefined and it must be of type string.');
    }
    if (data === null || data === undefined) {
      throw new Error('data cannot be null or undefined.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'fleet/vehicles/{vehicle_id_or_external_id}';
  requestUrl = requestUrl.replace('{vehicle_id_or_external_id}', encodeURIComponent(this.vehicleIdOrExternalId));
  let queryParameters = [];
  queryParameters.push('access_token=' + encodeURIComponent(this.accessToken));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PATCH';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (data !== null && data !== undefined) {
      let requestModelMapper = new client.models['Data']().mapper();
      requestModel = client.serialize(requestModelMapper, data, 'data');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(data, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedErrorResponse',
            type: {
              name: 'String'
            }
          };
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['FleetVehicleResponse']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary /fleet/vehicles/{vehicle_id:[0-9]+}/dispatch/routes
 *
 * Fetch all of the dispatch routes for a given vehicle.
 *
 * @param {number} vehicleId ID of the vehicle with the associated routes.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {array} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getDispatchRoutesByVehicleId(vehicleId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (this.endTime !== null && this.endTime !== undefined && typeof this.endTime !== 'number') {
      throw new Error('this.endTime must be of type number.');
    }
    if (this.duration !== null && this.duration !== undefined && typeof this.duration !== 'number') {
      throw new Error('this.duration must be of type number.');
    }
    if (this.accessToken === null || this.accessToken === undefined || typeof this.accessToken.valueOf() !== 'string') {
      throw new Error('this.accessToken cannot be null or undefined and it must be of type string.');
    }
    if (vehicleId === null || vehicleId === undefined || typeof vehicleId !== 'number') {
      throw new Error('vehicleId cannot be null or undefined and it must be of type number.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'fleet/vehicles/{vehicle_id}/dispatch/routes';
  requestUrl = requestUrl.replace('{vehicle_id}', encodeURIComponent(vehicleId.toString()));
  let queryParameters = [];
  if (this.endTime !== null && this.endTime !== undefined) {
    queryParameters.push('end_time=' + encodeURIComponent(this.endTime.toString()));
  }
  if (this.duration !== null && this.duration !== undefined) {
    queryParameters.push('duration=' + encodeURIComponent(this.duration.toString()));
  }
  queryParameters.push('access_token=' + encodeURIComponent(this.accessToken));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedErrorResponse',
            type: {
              name: 'String'
            }
          };
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Sequence',
              element: {
                  required: false,
                  serializedName: 'DispatchRouteElementType',
                  type: {
                    name: 'Composite',
                    className: 'DispatchRoute'
                  }
              }
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary /fleet/vehicles/{vehicle_id:[0-9]+}/dispatch/routes
 *
 * Create a new dispatch route for the vehicle with vehicle_id.
 *
 * @param {object} createDispatchRouteParams
 *
 * @param {array} createDispatchRouteParams.dispatchJobs The dispatch jobs to
 * create for this route.
 *
 * @param {number} [createDispatchRouteParams.actualEndMs] The time in Unix
 * epoch milliseconds that the route actually ended.
 *
 * @param {number} [createDispatchRouteParams.actualStartMs] The time in Unix
 * epoch milliseconds that the route actually started.
 *
 * @param {number} [createDispatchRouteParams.driverId] ID of the driver
 * assigned to the dispatch route. Note that driver_id and vehicle_id are
 * mutually exclusive. If neither is specified, then the route is unassigned.
 *
 * @param {number} [createDispatchRouteParams.groupId] ID of the group if the
 * organization has multiple groups (optional).
 *
 * @param {string} createDispatchRouteParams.name Descriptive name of this
 * route.
 *
 * @param {number} createDispatchRouteParams.scheduledEndMs The time in Unix
 * epoch milliseconds that the last job in the route is scheduled to end.
 *
 * @param {number} [createDispatchRouteParams.scheduledMeters] The distance
 * expected to be traveled for this route in meters.
 *
 * @param {number} createDispatchRouteParams.scheduledStartMs The time in Unix
 * epoch milliseconds that the route is scheduled to start.
 *
 * @param {string} [createDispatchRouteParams.startLocationAddress] The address
 * of the route's starting location, as it would be recognized if provided to
 * maps.google.com. Optional if a valid start location address ID is provided.
 *
 * @param {number} [createDispatchRouteParams.startLocationAddressId] ID of the
 * start location associated with an address book entry. Optional if valid
 * values are provided for start location address or latitude/longitude. If a
 * valid start location address ID is provided, address/latitude/longitude will
 * be used from the address book entry. Name of the address book entry will
 * only be used if the start location name is not provided.
 *
 * @param {number} [createDispatchRouteParams.startLocationLat] Latitude of the
 * start location in decimal degrees. Optional if a valid start location
 * address ID is provided.
 *
 * @param {number} [createDispatchRouteParams.startLocationLng] Longitude of
 * the start location in decimal degrees. Optional if a valid start location
 * address ID is provided.
 *
 * @param {string} [createDispatchRouteParams.startLocationName] The name of
 * the route's starting location. If provided, it will take precedence over the
 * name of the address book entry.
 *
 * @param {number} [createDispatchRouteParams.trailerId] ID of the trailer
 * assigned to the dispatch route. Note that trailers can only be assigned to
 * routes that have a Vehicle or Driver assigned to them.
 *
 * @param {number} [createDispatchRouteParams.vehicleId] ID of the vehicle
 * assigned to the dispatch route. Note that vehicle_id and driver_id are
 * mutually exclusive. If neither is specified, then the route is unassigned.
 *
 * @param {number} vehicleId ID of the vehicle with the associated routes.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link DispatchRoute} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _createVehicleDispatchRoute(createDispatchRouteParams, vehicleId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (createDispatchRouteParams === null || createDispatchRouteParams === undefined) {
      throw new Error('createDispatchRouteParams cannot be null or undefined.');
    }
    if (this.accessToken === null || this.accessToken === undefined || typeof this.accessToken.valueOf() !== 'string') {
      throw new Error('this.accessToken cannot be null or undefined and it must be of type string.');
    }
    if (vehicleId === null || vehicleId === undefined || typeof vehicleId !== 'number') {
      throw new Error('vehicleId cannot be null or undefined and it must be of type number.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'fleet/vehicles/{vehicle_id}/dispatch/routes';
  requestUrl = requestUrl.replace('{vehicle_id}', encodeURIComponent(vehicleId.toString()));
  let queryParameters = [];
  queryParameters.push('access_token=' + encodeURIComponent(this.accessToken));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (createDispatchRouteParams !== null && createDispatchRouteParams !== undefined) {
      let requestModelMapper = new client.models['DispatchRouteCreate']().mapper();
      requestModel = client.serialize(requestModelMapper, createDispatchRouteParams, 'createDispatchRouteParams');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(createDispatchRouteParams, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedErrorResponse',
            type: {
              name: 'String'
            }
          };
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['DispatchRoute']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary /fleet/vehicles/{vehicle_id:[0-9]+}/locations
 *
 * Fetch locations for a given vehicle between a start/end time. The maximum
 * query duration is one hour.
 *
 * @param {number} vehicleId ID of the vehicle with the associated routes.
 *
 * @param {number} startMs Time in Unix epoch milliseconds for the start of the
 * query (cannot exceed 1 hour)
 *
 * @param {number} endMs Time in Unix epoch milliseconds for the end of the
 * query (cannot exceed 1 hour)
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {array} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getVehicleLocations(vehicleId, startMs, endMs, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (this.accessToken === null || this.accessToken === undefined || typeof this.accessToken.valueOf() !== 'string') {
      throw new Error('this.accessToken cannot be null or undefined and it must be of type string.');
    }
    if (vehicleId === null || vehicleId === undefined || typeof vehicleId !== 'number') {
      throw new Error('vehicleId cannot be null or undefined and it must be of type number.');
    }
    if (startMs === null || startMs === undefined || typeof startMs !== 'number') {
      throw new Error('startMs cannot be null or undefined and it must be of type number.');
    }
    if (endMs === null || endMs === undefined || typeof endMs !== 'number') {
      throw new Error('endMs cannot be null or undefined and it must be of type number.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'fleet/vehicles/{vehicle_id}/locations';
  requestUrl = requestUrl.replace('{vehicle_id}', encodeURIComponent(vehicleId.toString()));
  let queryParameters = [];
  queryParameters.push('access_token=' + encodeURIComponent(this.accessToken));
  queryParameters.push('startMs=' + encodeURIComponent(startMs.toString()));
  queryParameters.push('endMs=' + encodeURIComponent(endMs.toString()));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedErrorResponse',
            type: {
              name: 'String'
            }
          };
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Sequence',
              element: {
                  required: false,
                  serializedName: 'FleetVehicleLocationElementType',
                  type: {
                    name: 'Composite',
                    className: 'FleetVehicleLocation'
                  }
              }
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary /industrial/data
 *
 * Fetch all of the data inputs for a group.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link GetAllDataInputsOKResponse} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getAllDataInputs(options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (this.accessToken === null || this.accessToken === undefined || typeof this.accessToken.valueOf() !== 'string') {
      throw new Error('this.accessToken cannot be null or undefined and it must be of type string.');
    }
    if (this.groupId !== null && this.groupId !== undefined && typeof this.groupId !== 'number') {
      throw new Error('this.groupId must be of type number.');
    }
    if (this.startMs !== null && this.startMs !== undefined && typeof this.startMs !== 'number') {
      throw new Error('this.startMs must be of type number.');
    }
    if (this.endMs !== null && this.endMs !== undefined && typeof this.endMs !== 'number') {
      throw new Error('this.endMs must be of type number.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'industrial/data';
  let queryParameters = [];
  queryParameters.push('access_token=' + encodeURIComponent(this.accessToken));
  if (this.groupId !== null && this.groupId !== undefined) {
    queryParameters.push('group_id=' + encodeURIComponent(this.groupId.toString()));
  }
  if (this.startMs !== null && this.startMs !== undefined) {
    queryParameters.push('startMs=' + encodeURIComponent(this.startMs.toString()));
  }
  if (this.endMs !== null && this.endMs !== undefined) {
    queryParameters.push('endMs=' + encodeURIComponent(this.endMs.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedErrorResponse',
            type: {
              name: 'String'
            }
          };
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['GetAllDataInputsOKResponse']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary /industrial/data/{data_input_id:[0-9]+}
 *
 * Fetch datapoints from a given data input.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link DataInputHistoryResponse} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getDataInput(options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (this.accessToken === null || this.accessToken === undefined || typeof this.accessToken.valueOf() !== 'string') {
      throw new Error('this.accessToken cannot be null or undefined and it must be of type string.');
    }
    if (this.dataInputId === null || this.dataInputId === undefined || typeof this.dataInputId !== 'number') {
      throw new Error('this.dataInputId cannot be null or undefined and it must be of type number.');
    }
    if (this.startMs !== null && this.startMs !== undefined && typeof this.startMs !== 'number') {
      throw new Error('this.startMs must be of type number.');
    }
    if (this.endMs !== null && this.endMs !== undefined && typeof this.endMs !== 'number') {
      throw new Error('this.endMs must be of type number.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'industrial/data/{data_input_id}';
  requestUrl = requestUrl.replace('{data_input_id}', encodeURIComponent(this.dataInputId.toString()));
  let queryParameters = [];
  queryParameters.push('access_token=' + encodeURIComponent(this.accessToken));
  if (this.startMs !== null && this.startMs !== undefined) {
    queryParameters.push('startMs=' + encodeURIComponent(this.startMs.toString()));
  }
  if (this.endMs !== null && this.endMs !== undefined) {
    queryParameters.push('endMs=' + encodeURIComponent(this.endMs.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedErrorResponse',
            type: {
              name: 'String'
            }
          };
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['DataInputHistoryResponse']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary /tags
 *
 * Fetch all of the tags for a group.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link GetAllTagsOKResponse} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getAllTags(options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (this.accessToken === null || this.accessToken === undefined || typeof this.accessToken.valueOf() !== 'string') {
      throw new Error('this.accessToken cannot be null or undefined and it must be of type string.');
    }
    if (this.groupId !== null && this.groupId !== undefined && typeof this.groupId !== 'number') {
      throw new Error('this.groupId must be of type number.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'tags';
  let queryParameters = [];
  queryParameters.push('access_token=' + encodeURIComponent(this.accessToken));
  if (this.groupId !== null && this.groupId !== undefined) {
    queryParameters.push('group_id=' + encodeURIComponent(this.groupId.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedErrorResponse',
            type: {
              name: 'String'
            }
          };
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['GetAllTagsOKResponse']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary /tags
 *
 * Create a new tag for the group.
 *
 * @param {object} tagCreateParams
 *
 * @param {array} [tagCreateParams.assets] The assets that belong to this tag.
 *
 * @param {array} [tagCreateParams.drivers] The drivers that belong to this
 * tag.
 *
 * @param {array} [tagCreateParams.machines] The machines that belong to this
 * tag.
 *
 * @param {string} tagCreateParams.name Name of this tag.
 *
 * @param {number} [tagCreateParams.parentTagId] If this tag is part a
 * hierarchical tag tree as a child tag, the parentTagId is the ID of this
 * tag's parent tag.
 *
 * @param {array} [tagCreateParams.sensors] The sensors that belong to this
 * tag.
 *
 * @param {array} [tagCreateParams.vehicles] The vehicles that belong to this
 * tag.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link Tag} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _createTag(tagCreateParams, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (this.accessToken === null || this.accessToken === undefined || typeof this.accessToken.valueOf() !== 'string') {
      throw new Error('this.accessToken cannot be null or undefined and it must be of type string.');
    }
    if (tagCreateParams === null || tagCreateParams === undefined) {
      throw new Error('tagCreateParams cannot be null or undefined.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'tags';
  let queryParameters = [];
  queryParameters.push('access_token=' + encodeURIComponent(this.accessToken));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (tagCreateParams !== null && tagCreateParams !== undefined) {
      let requestModelMapper = new client.models['TagCreate']().mapper();
      requestModel = client.serialize(requestModelMapper, tagCreateParams, 'tagCreateParams');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(tagCreateParams, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedErrorResponse',
            type: {
              name: 'String'
            }
          };
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['Tag']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary /tags/{tag_id:[0-9]+}
 *
 * Fetch a tag by id.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link Tag} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getTagById(options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (this.accessToken === null || this.accessToken === undefined || typeof this.accessToken.valueOf() !== 'string') {
      throw new Error('this.accessToken cannot be null or undefined and it must be of type string.');
    }
    if (this.tagId === null || this.tagId === undefined || typeof this.tagId !== 'number') {
      throw new Error('this.tagId cannot be null or undefined and it must be of type number.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'tags/{tag_id}';
  requestUrl = requestUrl.replace('{tag_id}', encodeURIComponent(this.tagId.toString()));
  let queryParameters = [];
  queryParameters.push('access_token=' + encodeURIComponent(this.accessToken));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedErrorResponse',
            type: {
              name: 'String'
            }
          };
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['Tag']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary /tags/{tag_id:[0-9]+}
 *
 * Update a tag with a new name and new members. This API call would replace
 * all old members of a tag with new members specified in the request body. To
 * modify only a few devices associated with a tag use the PATCH endpoint.
 *
 * @param {object} updateTagParams
 *
 * @param {array} [updateTagParams.assets] The assets that belong to this tag.
 *
 * @param {array} [updateTagParams.drivers] The drivers that belong to this
 * tag.
 *
 * @param {array} [updateTagParams.machines] The machines that belong to this
 * tag.
 *
 * @param {string} [updateTagParams.name] Updated name of this tag.
 *
 * @param {number} [updateTagParams.parentTagId] If this tag is part a
 * hierarchical tag tree as a child tag, the parentTagId is the ID of this
 * tag's parent tag.
 *
 * @param {array} [updateTagParams.sensors] The sensors that belong to this
 * tag.
 *
 * @param {array} [updateTagParams.vehicles] The vehicles that belong to this
 * tag.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link Tag} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _updateTagById(updateTagParams, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (this.accessToken === null || this.accessToken === undefined || typeof this.accessToken.valueOf() !== 'string') {
      throw new Error('this.accessToken cannot be null or undefined and it must be of type string.');
    }
    if (this.tagId === null || this.tagId === undefined || typeof this.tagId !== 'number') {
      throw new Error('this.tagId cannot be null or undefined and it must be of type number.');
    }
    if (updateTagParams === null || updateTagParams === undefined) {
      throw new Error('updateTagParams cannot be null or undefined.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'tags/{tag_id}';
  requestUrl = requestUrl.replace('{tag_id}', encodeURIComponent(this.tagId.toString()));
  let queryParameters = [];
  queryParameters.push('access_token=' + encodeURIComponent(this.accessToken));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (updateTagParams !== null && updateTagParams !== undefined) {
      let requestModelMapper = new client.models['TagUpdate']().mapper();
      requestModel = client.serialize(requestModelMapper, updateTagParams, 'updateTagParams');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(updateTagParams, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedErrorResponse',
            type: {
              name: 'String'
            }
          };
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['Tag']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary /tags/{tag_id:[0-9]+}
 *
 * Permanently deletes a tag.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deleteTagById(options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (this.accessToken === null || this.accessToken === undefined || typeof this.accessToken.valueOf() !== 'string') {
      throw new Error('this.accessToken cannot be null or undefined and it must be of type string.');
    }
    if (this.tagId === null || this.tagId === undefined || typeof this.tagId !== 'number') {
      throw new Error('this.tagId cannot be null or undefined and it must be of type number.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'tags/{tag_id}';
  requestUrl = requestUrl.replace('{tag_id}', encodeURIComponent(this.tagId.toString()));
  let queryParameters = [];
  queryParameters.push('access_token=' + encodeURIComponent(this.accessToken));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedErrorResponse',
            type: {
              name: 'String'
            }
          };
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary /tags/{tag_id:[0-9]+}
 *
 * Add or delete specific members from a tag, or modify the name of a tag.
 *
 * @param {object} tagModifyParams
 *
 * @param {object} [tagModifyParams.add] Specify devices, etc. that should be
 * added to the tag.
 *
 * @param {array} [tagModifyParams.add.assets] The assets to be added to this
 * tag.
 *
 * @param {array} [tagModifyParams.add.drivers] The drivers to be added to this
 * tag.
 *
 * @param {array} [tagModifyParams.add.machines] The machines to be added to
 * this tag.
 *
 * @param {array} [tagModifyParams.add.sensors] The sensors to be added to this
 * tag.
 *
 * @param {array} [tagModifyParams.add.vehicles] The vehicles to be added to
 * this tag.
 *
 * @param {object} [tagModifyParams.deleteProperty] Specify devices, etc. that
 * should be removed from the tag.
 *
 * @param {array} [tagModifyParams.deleteProperty.assets] The assets to be
 * removed from this tag.
 *
 * @param {array} [tagModifyParams.deleteProperty.drivers] The drivers to be
 * removed from this tag.
 *
 * @param {array} [tagModifyParams.deleteProperty.machines] The machines to be
 * removed from this tag.
 *
 * @param {array} [tagModifyParams.deleteProperty.sensors] The sensors to be
 * removed from this tag.
 *
 * @param {array} [tagModifyParams.deleteProperty.vehicles] The vehicles to be
 * removed from this tag.
 *
 * @param {string} [tagModifyParams.name] Updated name of this tag.
 *
 * @param {number} [tagModifyParams.parentTagId] If this tag is part a
 * hierarchical tag tree as a child tag, the parentTagId is the ID of this
 * tag's parent tag.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link Tag} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _modifyTagById(tagModifyParams, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (this.accessToken === null || this.accessToken === undefined || typeof this.accessToken.valueOf() !== 'string') {
      throw new Error('this.accessToken cannot be null or undefined and it must be of type string.');
    }
    if (this.tagId === null || this.tagId === undefined || typeof this.tagId !== 'number') {
      throw new Error('this.tagId cannot be null or undefined and it must be of type number.');
    }
    if (tagModifyParams === null || tagModifyParams === undefined) {
      throw new Error('tagModifyParams cannot be null or undefined.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'tags/{tag_id}';
  requestUrl = requestUrl.replace('{tag_id}', encodeURIComponent(this.tagId.toString()));
  let queryParameters = [];
  queryParameters.push('access_token=' + encodeURIComponent(this.accessToken));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PATCH';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (tagModifyParams !== null && tagModifyParams !== undefined) {
      let requestModelMapper = new client.models['TagModify']().mapper();
      requestModel = client.serialize(requestModelMapper, tagModifyParams, 'tagModifyParams');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(tagModifyParams, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedErrorResponse',
            type: {
              name: 'String'
            }
          };
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['Tag']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary /user_roles
 *
 * Get all roles in the organization.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {array} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listUserRoles(options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (this.accessToken === null || this.accessToken === undefined || typeof this.accessToken.valueOf() !== 'string') {
      throw new Error('this.accessToken cannot be null or undefined and it must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'user_roles';
  let queryParameters = [];
  queryParameters.push('access_token=' + encodeURIComponent(this.accessToken));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedErrorResponse',
            type: {
              name: 'String'
            }
          };
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Sequence',
              element: {
                  required: false,
                  serializedName: 'UserRoleElementType',
                  type: {
                    name: 'Composite',
                    className: 'UserRole'
                  }
              }
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary /users/{userId:[0-9]+}
 *
 * Get a user.
 *
 * @param {number} userId ID of the user.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link User} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getUserById(userId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (this.accessToken === null || this.accessToken === undefined || typeof this.accessToken.valueOf() !== 'string') {
      throw new Error('this.accessToken cannot be null or undefined and it must be of type string.');
    }
    if (userId === null || userId === undefined || typeof userId !== 'number') {
      throw new Error('userId cannot be null or undefined and it must be of type number.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'users/{userId}';
  requestUrl = requestUrl.replace('{userId}', encodeURIComponent(userId.toString()));
  let queryParameters = [];
  queryParameters.push('access_token=' + encodeURIComponent(this.accessToken));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedErrorResponse',
            type: {
              name: 'String'
            }
          };
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['User']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary /users/{userId:[0-9]+}
 *
 * Remove a user from the organization.
 *
 * @param {number} userId ID of the user.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deleteUserById(userId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (this.accessToken === null || this.accessToken === undefined || typeof this.accessToken.valueOf() !== 'string') {
      throw new Error('this.accessToken cannot be null or undefined and it must be of type string.');
    }
    if (userId === null || userId === undefined || typeof userId !== 'number') {
      throw new Error('userId cannot be null or undefined and it must be of type number.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'users/{userId}';
  requestUrl = requestUrl.replace('{userId}', encodeURIComponent(userId.toString()));
  let queryParameters = [];
  queryParameters.push('access_token=' + encodeURIComponent(this.accessToken));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedErrorResponse',
            type: {
              name: 'String'
            }
          };
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/** Class representing a SamsaraAPI. */
class SamsaraAPI extends ServiceClient {
  /**
   * Create a SamsaraAPI.
   * @param {string} accessToken - Samsara API access token.
   * @param {number} endMs - Timestamp in milliseconds representing the end of the period to fetch, inclusive. Used in combination with startMs.
   * @param {number} startMs - Timestamp in milliseconds representing the start of the period to fetch, inclusive. Used in combination with endMs.
   * @param {number} assetId - ID of the asset
   * @param {number} dataInputId - ID of the data input
   * @param {string} driverIdOrExternalId - ID of the driver.  This must be either the numeric ID generated by Samsara or the external ID of the driver.  External IDs are customer specified key-value pairs.
   * @param {number} timestamp - Timestamp in milliseconds representing the timestamp of a harsh event.
   * @param {number} endMs3 - Timestamp in milliseconds representing the end of the period to fetch, inclusive. Used in combination with startMs.
   * @param {number} startMs2 - Timestamp in milliseconds representing the start of the period to fetch, inclusive. Used in combination with endMs.
   * @param {number} tagId - ID of the tag.
   * @param {string} vehicleIdOrExternalId - ID of the vehicle.  This must be either the numeric ID generated by Samsara or the external ID of the vehicle.  External IDs are customer specified key-value pairs.
   * @param {string} [baseUri] - The base URI of the service.
   * @param {object} [options] - The parameter options
   * @param {Array} [options.filters] - Filters to be added to the request pipeline
   * @param {object} [options.requestOptions] - Options for the underlying request object
   * {@link https://github.com/request/request#requestoptions-callback Options doc}
   * @param {boolean} [options.noRetryPolicy] - If set to true, turn off default retry policy
   * @param {number} [options.endMs1] - Timestamp in unix milliseconds representing the end of the period to fetch, inclusive. Used in combination with startMs. Defaults to nowMs.
   * @param {number} [options.startMs1] - Timestamp in unix milliseconds representing the start of the period to fetch, inclusive. Used in combination with endMs. defaults to nowMs.
   * @param {number} [options.durationMs] - Time in milliseconds that represents the duration before endMs to query. Defaults to 24 hours.
   * @param {number} [options.endMs2] - Time in unix milliseconds that represents the oldest documents to return. Used in combination with durationMs. Defaults to now.
   * @param {number} [options.groupId] - Optional group ID if the organization has multiple groups (uncommon).
   * @param {string} [options.include] - Optionally set include=route to include route object in response payload.
   * @param {string} [options.sequenceId] - Sequence ID from the response payload of the last request. Defaults to fetching updates from last 24 hours.
   * @param {string} [options.endingBefore] - Pagination parameter indicating the cursor position to return results before. Used in conjunction with the 'limit' parameter. Mutually exclusive with 'startingAfter' parameter.
   * @param {number} [options.limit] - Pagination parameter indicating the number of results to return in this request. Used in conjunction with either 'startingAfter' or 'endingBefore'.
   * @param {string} [options.startingAfter] - Pagination parameter indicating the cursor position to continue returning results after. Used in conjunction with the 'limit' parameter. Mutually exclusive with 'endingBefore' parameter.
   * @param {number} [options.duration] - Time in milliseconds that represents the duration before end_time to query. Defaults to 24 hours.
   * @param {number} [options.endTime] - Time in unix milliseconds that represents the oldest routes to return. Used in combination with duration. Defaults to now.
   * @param {number} [options.endTime1] - Timestamp representing the end of the period to fetch, inclusive. Used in combination with start_time. Defaults to nowMs.
   * @param {number} [options.startTime] - Timestamp representing the start of the period to fetch, inclusive. Used in combination with end_time. Defaults to 0.
   */
  constructor(accessToken, endMs, startMs, assetId, dataInputId, driverIdOrExternalId, timestamp, endMs3, startMs2, tagId, vehicleIdOrExternalId, baseUri, options) {
    if (accessToken === null || accessToken === undefined) {
      throw new Error('\'accessToken\' cannot be null.');
    }
    if (endMs === null || endMs === undefined) {
      throw new Error('\'endMs\' cannot be null.');
    }
    if (startMs === null || startMs === undefined) {
      throw new Error('\'startMs\' cannot be null.');
    }
    if (assetId === null || assetId === undefined) {
      throw new Error('\'assetId\' cannot be null.');
    }
    if (dataInputId === null || dataInputId === undefined) {
      throw new Error('\'dataInputId\' cannot be null.');
    }
    if (driverIdOrExternalId === null || driverIdOrExternalId === undefined) {
      throw new Error('\'driverIdOrExternalId\' cannot be null.');
    }
    if (timestamp === null || timestamp === undefined) {
      throw new Error('\'timestamp\' cannot be null.');
    }
    if (endMs3 === null || endMs3 === undefined) {
      throw new Error('\'endMs3\' cannot be null.');
    }
    if (startMs2 === null || startMs2 === undefined) {
      throw new Error('\'startMs2\' cannot be null.');
    }
    if (tagId === null || tagId === undefined) {
      throw new Error('\'tagId\' cannot be null.');
    }
    if (vehicleIdOrExternalId === null || vehicleIdOrExternalId === undefined) {
      throw new Error('\'vehicleIdOrExternalId\' cannot be null.');
    }

    if (!options) options = {};

    super(null, options);

    this.baseUri = baseUri;
    if (!this.baseUri) {
      this.baseUri = 'https://api.samsara.com/v1';
    }
    this.accessToken = accessToken;
    this.endMs = endMs;
    this.startMs = startMs;
    this.assetId = assetId;
    this.dataInputId = dataInputId;
    this.driverIdOrExternalId = driverIdOrExternalId;
    this.timestamp = timestamp;
    this.endMs3 = endMs3;
    this.startMs2 = startMs2;
    this.tagId = tagId;
    this.vehicleIdOrExternalId = vehicleIdOrExternalId;

    let packageInfo = this.getPackageJsonInfo(__dirname);
    this.addUserAgentInfo(`${packageInfo.name}/${packageInfo.version}`);
    if(options.endMs1 !== null && options.endMs1 !== undefined) {
      this.endMs1 = options.endMs1;
    }
    if(options.startMs1 !== null && options.startMs1 !== undefined) {
      this.startMs1 = options.startMs1;
    }
    if(options.durationMs !== null && options.durationMs !== undefined) {
      this.durationMs = options.durationMs;
    }
    if(options.endMs2 !== null && options.endMs2 !== undefined) {
      this.endMs2 = options.endMs2;
    }
    if(options.groupId !== null && options.groupId !== undefined) {
      this.groupId = options.groupId;
    }
    if(options.include !== null && options.include !== undefined) {
      this.include = options.include;
    }
    if(options.sequenceId !== null && options.sequenceId !== undefined) {
      this.sequenceId = options.sequenceId;
    }
    if(options.endingBefore !== null && options.endingBefore !== undefined) {
      this.endingBefore = options.endingBefore;
    }
    if(options.limit !== null && options.limit !== undefined) {
      this.limit = options.limit;
    }
    if(options.startingAfter !== null && options.startingAfter !== undefined) {
      this.startingAfter = options.startingAfter;
    }
    if(options.duration !== null && options.duration !== undefined) {
      this.duration = options.duration;
    }
    if(options.endTime !== null && options.endTime !== undefined) {
      this.endTime = options.endTime;
    }
    if(options.endTime1 !== null && options.endTime1 !== undefined) {
      this.endTime1 = options.endTime1;
    }
    if(options.startTime !== null && options.startTime !== undefined) {
      this.startTime = options.startTime;
    }
    this.add = new operations.Add(this);
    this.get = new operations.Get(this);
    this.list = new operations.List(this);
    this.create = new operations.Create(this);
    this.update = new operations.Update(this);
    this.models = models;
    this._getOrganizationAddresses = _getOrganizationAddresses;
    this._addOrganizationAddresses = _addOrganizationAddresses;
    this._getOrganizationAddress = _getOrganizationAddress;
    this._deleteOrganizationAddress = _deleteOrganizationAddress;
    this._updateOrganizationAddress = _updateOrganizationAddress;
    this._listContacts = _listContacts;
    this._getOrganizationContact = _getOrganizationContact;
    this._getAllAssets = _getAllAssets;
    this._getAllAssetCurrentLocations = _getAllAssetCurrentLocations;
    this._getAssetLocation = _getAssetLocation;
    this._getAssetReefer = _getAssetReefer;
    this._fetchAllDispatchRoutes = _fetchAllDispatchRoutes;
    this._createDispatchRoute = _createDispatchRoute;
    this._fetchAllRouteJobUpdates = _fetchAllRouteJobUpdates;
    this._getDispatchRouteById = _getDispatchRouteById;
    this._updateDispatchRouteById = _updateDispatchRouteById;
    this._deleteDispatchRouteById = _deleteDispatchRouteById;
    this._getDispatchRouteHistory = _getDispatchRouteHistory;
    this._createDriver = _createDriver;
    this._getDriverDocumentTypesByOrgId = _getDriverDocumentTypesByOrgId;
    this._getDriverDocumentsByOrgId = _getDriverDocumentsByOrgId;
    this._getAllDeactivatedDrivers = _getAllDeactivatedDrivers;
    this._getDeactivatedDriverById = _getDeactivatedDriverById;
    this._reactivateDriverById = _reactivateDriverById;
    this._getDriverSafetyScore = _getDriverSafetyScore;
    this._getDriverById = _getDriverById;
    this._deactivateDriver = _deactivateDriver;
    this._getDispatchRoutesByDriverId = _getDispatchRoutesByDriverId;
    this._createDriverDispatchRoute = _createDriverDispatchRoute;
    this._createDriverDocument = _createDriverDocument;
    this._getVehiclesLocations = _getVehiclesLocations;
    this._getVehicleStats = _getVehicleStats;
    this._getVehicleHarshEvent = _getVehicleHarshEvent;
    this._getVehicleSafetyScore = _getVehicleSafetyScore;
    this._getFleetVehicle = _getFleetVehicle;
    this._patchFleetVehicle = _patchFleetVehicle;
    this._getDispatchRoutesByVehicleId = _getDispatchRoutesByVehicleId;
    this._createVehicleDispatchRoute = _createVehicleDispatchRoute;
    this._getVehicleLocations = _getVehicleLocations;
    this._getAllDataInputs = _getAllDataInputs;
    this._getDataInput = _getDataInput;
    this._getAllTags = _getAllTags;
    this._createTag = _createTag;
    this._getTagById = _getTagById;
    this._updateTagById = _updateTagById;
    this._deleteTagById = _deleteTagById;
    this._modifyTagById = _modifyTagById;
    this._listUserRoles = _listUserRoles;
    this._getUserById = _getUserById;
    this._deleteUserById = _deleteUserById;
    msRest.addSerializationMixin(this);
  }

  /**
   * @summary /addresses
   *
   * Fetch all addresses/geofences for the organization. An address contains
   * either a circle or polygon geofence describing the address boundaries.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getOrganizationAddressesWithHttpOperationResponse(options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getOrganizationAddresses(options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary /addresses
   *
   * Fetch all addresses/geofences for the organization. An address contains
   * either a circle or polygon geofence describing the address boundaries.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getOrganizationAddresses(options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getOrganizationAddresses(options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getOrganizationAddresses(options, optionalCallback);
    }
  }

  /**
   * @summary /addresses
   *
   * Add one or more addresses to the organization
   *
   * @param {object} addresses List of addresses/geofences to add. Geofences can
   * be circular or a polygon.
   * For each address, only one of 'circle' or 'polygon' should be provided. If
   * both are provided, the geofence will be saved as a polygon.
   *
   * @param {array} addresses.addresses
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  addOrganizationAddressesWithHttpOperationResponse(addresses, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._addOrganizationAddresses(addresses, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary /addresses
   *
   * Add one or more addresses to the organization
   *
   * @param {object} addresses List of addresses/geofences to add. Geofences can
   * be circular or a polygon.
   * For each address, only one of 'circle' or 'polygon' should be provided. If
   * both are provided, the geofence will be saved as a polygon.
   *
   * @param {array} addresses.addresses
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  addOrganizationAddresses(addresses, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._addOrganizationAddresses(addresses, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._addOrganizationAddresses(addresses, options, optionalCallback);
    }
  }

  /**
   * @summary /addresses/{addressId}
   *
   * Fetch an address by its id.
   *
   * @param {number} addressId ID of the address/geofence
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Address>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getOrganizationAddressWithHttpOperationResponse(addressId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getOrganizationAddress(addressId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary /addresses/{addressId}
   *
   * Fetch an address by its id.
   *
   * @param {number} addressId ID of the address/geofence
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Address} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Address} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getOrganizationAddress(addressId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getOrganizationAddress(addressId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getOrganizationAddress(addressId, options, optionalCallback);
    }
  }

  /**
   * @summary /addresses/{addressId}
   *
   * Delete an address.
   *
   * @param {number} addressId ID of the address/geofence
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deleteOrganizationAddressWithHttpOperationResponse(addressId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deleteOrganizationAddress(addressId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary /addresses/{addressId}
   *
   * Delete an address.
   *
   * @param {number} addressId ID of the address/geofence
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteOrganizationAddress(addressId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deleteOrganizationAddress(addressId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deleteOrganizationAddress(addressId, options, optionalCallback);
    }
  }

  /**
   * @summary /addresses/{addressId}
   *
   * Update the name, formatted address, geofence, notes, or tag and contact Ids
   * for an address. The set of tags or contacts associated with this address
   * will be updated to exactly match the list of IDs passed in. To remove all
   * tags or contacts from an address, pass an empty list; to remove notes, pass
   * an empty string.
   *
   * @param {object} address Update parts of an address's value. If the geofence
   * 'circle' or 'polygon' key is specified, the update will change the type of
   * geofence accordingly.
   *
   * @param {array} [address.contactIds]
   *
   * @param {string} [address.formattedAddress] The full address associated with
   * this address/geofence, as it might be recognized by maps.google.com
   *
   * @param {object} [address.geofence]
   *
   * @param {object} [address.geofence.circle] Information about a circular
   * geofence. This field is only populated if the geofence is a circle.
   *
   * @param {number} [address.geofence.circle.latitude] The latitude of the
   * center of the circular geofence
   *
   * @param {number} [address.geofence.circle.longitude] The longitude of the
   * center of the circular geofence
   *
   * @param {number} [address.geofence.circle.radiusMeters] The radius of the
   * circular geofence
   *
   * @param {object} [address.geofence.polygon] Information about a polygon
   * geofence. This field is only populated if the geofence is a polygon.
   *
   * @param {array} [address.geofence.polygon.vertices] The vertices of the
   * polygon geofence. These geofence vertices describe the perimeter of the
   * polygon, and must consist of at least 3 vertices and less than 40.
   *
   * @param {string} [address.name] The name of this address/geofence
   *
   * @param {string} [address.notes]
   *
   * @param {array} [address.tagIds]
   *
   * @param {number} addressId ID of the address/geofence
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  updateOrganizationAddressWithHttpOperationResponse(address, addressId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._updateOrganizationAddress(address, addressId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary /addresses/{addressId}
   *
   * Update the name, formatted address, geofence, notes, or tag and contact Ids
   * for an address. The set of tags or contacts associated with this address
   * will be updated to exactly match the list of IDs passed in. To remove all
   * tags or contacts from an address, pass an empty list; to remove notes, pass
   * an empty string.
   *
   * @param {object} address Update parts of an address's value. If the geofence
   * 'circle' or 'polygon' key is specified, the update will change the type of
   * geofence accordingly.
   *
   * @param {array} [address.contactIds]
   *
   * @param {string} [address.formattedAddress] The full address associated with
   * this address/geofence, as it might be recognized by maps.google.com
   *
   * @param {object} [address.geofence]
   *
   * @param {object} [address.geofence.circle] Information about a circular
   * geofence. This field is only populated if the geofence is a circle.
   *
   * @param {number} [address.geofence.circle.latitude] The latitude of the
   * center of the circular geofence
   *
   * @param {number} [address.geofence.circle.longitude] The longitude of the
   * center of the circular geofence
   *
   * @param {number} [address.geofence.circle.radiusMeters] The radius of the
   * circular geofence
   *
   * @param {object} [address.geofence.polygon] Information about a polygon
   * geofence. This field is only populated if the geofence is a polygon.
   *
   * @param {array} [address.geofence.polygon.vertices] The vertices of the
   * polygon geofence. These geofence vertices describe the perimeter of the
   * polygon, and must consist of at least 3 vertices and less than 40.
   *
   * @param {string} [address.name] The name of this address/geofence
   *
   * @param {string} [address.notes]
   *
   * @param {array} [address.tagIds]
   *
   * @param {number} addressId ID of the address/geofence
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  updateOrganizationAddress(address, addressId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._updateOrganizationAddress(address, addressId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._updateOrganizationAddress(address, addressId, options, optionalCallback);
    }
  }

  /**
   * @summary /contacts
   *
   * Fetch all contacts for the organization.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listContactsWithHttpOperationResponse(options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listContacts(options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary /contacts
   *
   * Fetch all contacts for the organization.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listContacts(options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listContacts(options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listContacts(options, optionalCallback);
    }
  }

  /**
   * @summary /contacts/{contact_id}
   *
   * Fetch a contact by its id.
   *
   * @param {number} contactId ID of the contact
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Contact>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getOrganizationContactWithHttpOperationResponse(contactId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getOrganizationContact(contactId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary /contacts/{contact_id}
   *
   * Fetch a contact by its id.
   *
   * @param {number} contactId ID of the contact
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Contact} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Contact} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getOrganizationContact(contactId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getOrganizationContact(contactId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getOrganizationContact(contactId, options, optionalCallback);
    }
  }

  /**
   * @summary /fleet/assets
   *
   * Fetch all of the assets for the group.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<GetAllAssetsOKResponse>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getAllAssetsWithHttpOperationResponse(options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getAllAssets(options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary /fleet/assets
   *
   * Fetch all of the assets for the group.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {GetAllAssetsOKResponse} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link GetAllAssetsOKResponse} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getAllAssets(options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getAllAssets(options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getAllAssets(options, optionalCallback);
    }
  }

  /**
   * @summary /fleet/assets/locations
   *
   * Fetch current locations of all assets for the group.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<GetAllAssetCurrentLocationsOKResponse>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getAllAssetCurrentLocationsWithHttpOperationResponse(options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getAllAssetCurrentLocations(options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary /fleet/assets/locations
   *
   * Fetch current locations of all assets for the group.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {GetAllAssetCurrentLocationsOKResponse} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link GetAllAssetCurrentLocationsOKResponse} for
   *                      more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getAllAssetCurrentLocations(options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getAllAssetCurrentLocations(options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getAllAssetCurrentLocations(options, optionalCallback);
    }
  }

  /**
   * @summary /fleet/assets/{assetId:[0-9]+}/locations
   *
   * Fetch the historical locations for the asset.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getAssetLocationWithHttpOperationResponse(options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getAssetLocation(options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary /fleet/assets/{assetId:[0-9]+}/locations
   *
   * Fetch the historical locations for the asset.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getAssetLocation(options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getAssetLocation(options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getAssetLocation(options, optionalCallback);
    }
  }

  /**
   * @summary /fleet/assets/{assetId:[0-9]+}/reefer
   *
   * Fetch the reefer-specific stats of an asset.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<AssetReeferResponse>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getAssetReeferWithHttpOperationResponse(options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getAssetReefer(options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary /fleet/assets/{assetId:[0-9]+}/reefer
   *
   * Fetch the reefer-specific stats of an asset.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {AssetReeferResponse} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link AssetReeferResponse} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getAssetReefer(options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getAssetReefer(options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getAssetReefer(options, optionalCallback);
    }
  }

  /**
   * @summary /fleet/dispatch/routes
   *
   * Fetch all of the dispatch routes for the group.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  fetchAllDispatchRoutesWithHttpOperationResponse(options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._fetchAllDispatchRoutes(options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary /fleet/dispatch/routes
   *
   * Fetch all of the dispatch routes for the group.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  fetchAllDispatchRoutes(options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._fetchAllDispatchRoutes(options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._fetchAllDispatchRoutes(options, optionalCallback);
    }
  }

  /**
   * @summary /fleet/dispatch/routes
   *
   * Create a new dispatch route.
   *
   * @param {object} createDispatchRouteParams
   *
   * @param {array} createDispatchRouteParams.dispatchJobs The dispatch jobs to
   * create for this route.
   *
   * @param {number} [createDispatchRouteParams.actualEndMs] The time in Unix
   * epoch milliseconds that the route actually ended.
   *
   * @param {number} [createDispatchRouteParams.actualStartMs] The time in Unix
   * epoch milliseconds that the route actually started.
   *
   * @param {number} [createDispatchRouteParams.driverId] ID of the driver
   * assigned to the dispatch route. Note that driver_id and vehicle_id are
   * mutually exclusive. If neither is specified, then the route is unassigned.
   *
   * @param {number} [createDispatchRouteParams.groupId] ID of the group if the
   * organization has multiple groups (optional).
   *
   * @param {string} createDispatchRouteParams.name Descriptive name of this
   * route.
   *
   * @param {number} createDispatchRouteParams.scheduledEndMs The time in Unix
   * epoch milliseconds that the last job in the route is scheduled to end.
   *
   * @param {number} [createDispatchRouteParams.scheduledMeters] The distance
   * expected to be traveled for this route in meters.
   *
   * @param {number} createDispatchRouteParams.scheduledStartMs The time in Unix
   * epoch milliseconds that the route is scheduled to start.
   *
   * @param {string} [createDispatchRouteParams.startLocationAddress] The address
   * of the route's starting location, as it would be recognized if provided to
   * maps.google.com. Optional if a valid start location address ID is provided.
   *
   * @param {number} [createDispatchRouteParams.startLocationAddressId] ID of the
   * start location associated with an address book entry. Optional if valid
   * values are provided for start location address or latitude/longitude. If a
   * valid start location address ID is provided, address/latitude/longitude will
   * be used from the address book entry. Name of the address book entry will
   * only be used if the start location name is not provided.
   *
   * @param {number} [createDispatchRouteParams.startLocationLat] Latitude of the
   * start location in decimal degrees. Optional if a valid start location
   * address ID is provided.
   *
   * @param {number} [createDispatchRouteParams.startLocationLng] Longitude of
   * the start location in decimal degrees. Optional if a valid start location
   * address ID is provided.
   *
   * @param {string} [createDispatchRouteParams.startLocationName] The name of
   * the route's starting location. If provided, it will take precedence over the
   * name of the address book entry.
   *
   * @param {number} [createDispatchRouteParams.trailerId] ID of the trailer
   * assigned to the dispatch route. Note that trailers can only be assigned to
   * routes that have a Vehicle or Driver assigned to them.
   *
   * @param {number} [createDispatchRouteParams.vehicleId] ID of the vehicle
   * assigned to the dispatch route. Note that vehicle_id and driver_id are
   * mutually exclusive. If neither is specified, then the route is unassigned.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<DispatchRoute>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  createDispatchRouteWithHttpOperationResponse(createDispatchRouteParams, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._createDispatchRoute(createDispatchRouteParams, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary /fleet/dispatch/routes
   *
   * Create a new dispatch route.
   *
   * @param {object} createDispatchRouteParams
   *
   * @param {array} createDispatchRouteParams.dispatchJobs The dispatch jobs to
   * create for this route.
   *
   * @param {number} [createDispatchRouteParams.actualEndMs] The time in Unix
   * epoch milliseconds that the route actually ended.
   *
   * @param {number} [createDispatchRouteParams.actualStartMs] The time in Unix
   * epoch milliseconds that the route actually started.
   *
   * @param {number} [createDispatchRouteParams.driverId] ID of the driver
   * assigned to the dispatch route. Note that driver_id and vehicle_id are
   * mutually exclusive. If neither is specified, then the route is unassigned.
   *
   * @param {number} [createDispatchRouteParams.groupId] ID of the group if the
   * organization has multiple groups (optional).
   *
   * @param {string} createDispatchRouteParams.name Descriptive name of this
   * route.
   *
   * @param {number} createDispatchRouteParams.scheduledEndMs The time in Unix
   * epoch milliseconds that the last job in the route is scheduled to end.
   *
   * @param {number} [createDispatchRouteParams.scheduledMeters] The distance
   * expected to be traveled for this route in meters.
   *
   * @param {number} createDispatchRouteParams.scheduledStartMs The time in Unix
   * epoch milliseconds that the route is scheduled to start.
   *
   * @param {string} [createDispatchRouteParams.startLocationAddress] The address
   * of the route's starting location, as it would be recognized if provided to
   * maps.google.com. Optional if a valid start location address ID is provided.
   *
   * @param {number} [createDispatchRouteParams.startLocationAddressId] ID of the
   * start location associated with an address book entry. Optional if valid
   * values are provided for start location address or latitude/longitude. If a
   * valid start location address ID is provided, address/latitude/longitude will
   * be used from the address book entry. Name of the address book entry will
   * only be used if the start location name is not provided.
   *
   * @param {number} [createDispatchRouteParams.startLocationLat] Latitude of the
   * start location in decimal degrees. Optional if a valid start location
   * address ID is provided.
   *
   * @param {number} [createDispatchRouteParams.startLocationLng] Longitude of
   * the start location in decimal degrees. Optional if a valid start location
   * address ID is provided.
   *
   * @param {string} [createDispatchRouteParams.startLocationName] The name of
   * the route's starting location. If provided, it will take precedence over the
   * name of the address book entry.
   *
   * @param {number} [createDispatchRouteParams.trailerId] ID of the trailer
   * assigned to the dispatch route. Note that trailers can only be assigned to
   * routes that have a Vehicle or Driver assigned to them.
   *
   * @param {number} [createDispatchRouteParams.vehicleId] ID of the vehicle
   * assigned to the dispatch route. Note that vehicle_id and driver_id are
   * mutually exclusive. If neither is specified, then the route is unassigned.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {DispatchRoute} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link DispatchRoute} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  createDispatchRoute(createDispatchRouteParams, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._createDispatchRoute(createDispatchRouteParams, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._createDispatchRoute(createDispatchRouteParams, options, optionalCallback);
    }
  }

  /**
   * @summary /fleet/dispatch/routes/job_updates
   *
   * Fetch all updates to a job including route data in the last 24 hours or
   * subsequent to an sequence ID
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<AllRouteJobUpdates>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  fetchAllRouteJobUpdatesWithHttpOperationResponse(options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._fetchAllRouteJobUpdates(options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary /fleet/dispatch/routes/job_updates
   *
   * Fetch all updates to a job including route data in the last 24 hours or
   * subsequent to an sequence ID
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {AllRouteJobUpdates} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link AllRouteJobUpdates} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  fetchAllRouteJobUpdates(options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._fetchAllRouteJobUpdates(options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._fetchAllRouteJobUpdates(options, optionalCallback);
    }
  }

  /**
   * @summary /fleet/dispatch/routes/{route_id:[0-9]+}
   *
   * Fetch a dispatch route by id.
   *
   * @param {number} routeId ID of the dispatch route.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<DispatchRoute>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getDispatchRouteByIdWithHttpOperationResponse(routeId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getDispatchRouteById(routeId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary /fleet/dispatch/routes/{route_id:[0-9]+}
   *
   * Fetch a dispatch route by id.
   *
   * @param {number} routeId ID of the dispatch route.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {DispatchRoute} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link DispatchRoute} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getDispatchRouteById(routeId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getDispatchRouteById(routeId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getDispatchRouteById(routeId, options, optionalCallback);
    }
  }

  /**
   * @summary /fleet/dispatch/routes/{route_id:[0-9]+}/
   *
   * Update a dispatch route and its associated jobs.
   *
   * @param {object} updateDispatchRouteParams
   *
   * @param {array} updateDispatchRouteParams.dispatchJobs The dispatch jobs
   * associated with this route.
   *
   * @param {number} updateDispatchRouteParams.id ID of the Samsara dispatch
   * route.
   *
   * @param {number} [updateDispatchRouteParams.actualEndMs] The time in Unix
   * epoch milliseconds that the route actually ended.
   *
   * @param {number} [updateDispatchRouteParams.actualStartMs] The time in Unix
   * epoch milliseconds that the route actually started.
   *
   * @param {number} [updateDispatchRouteParams.driverId] ID of the driver
   * assigned to the dispatch route. Note that driver_id and vehicle_id are
   * mutually exclusive. If neither is specified, then the route is unassigned.
   *
   * @param {number} [updateDispatchRouteParams.groupId] ID of the group if the
   * organization has multiple groups (optional).
   *
   * @param {string} updateDispatchRouteParams.name Descriptive name of this
   * route.
   *
   * @param {number} updateDispatchRouteParams.scheduledEndMs The time in Unix
   * epoch milliseconds that the last job in the route is scheduled to end.
   *
   * @param {number} [updateDispatchRouteParams.scheduledMeters] The distance
   * expected to be traveled for this route in meters.
   *
   * @param {number} updateDispatchRouteParams.scheduledStartMs The time in Unix
   * epoch milliseconds that the route is scheduled to start.
   *
   * @param {string} [updateDispatchRouteParams.startLocationAddress] The address
   * of the route's starting location, as it would be recognized if provided to
   * maps.google.com. Optional if a valid start location address ID is provided.
   *
   * @param {number} [updateDispatchRouteParams.startLocationAddressId] ID of the
   * start location associated with an address book entry. Optional if valid
   * values are provided for start location address or latitude/longitude. If a
   * valid start location address ID is provided, address/latitude/longitude will
   * be used from the address book entry. Name of the address book entry will
   * only be used if the start location name is not provided.
   *
   * @param {number} [updateDispatchRouteParams.startLocationLat] Latitude of the
   * start location in decimal degrees. Optional if a valid start location
   * address ID is provided.
   *
   * @param {number} [updateDispatchRouteParams.startLocationLng] Longitude of
   * the start location in decimal degrees. Optional if a valid start location
   * address ID is provided.
   *
   * @param {string} [updateDispatchRouteParams.startLocationName] The name of
   * the route's starting location. If provided, it will take precedence over the
   * name of the address book entry.
   *
   * @param {number} [updateDispatchRouteParams.trailerId] ID of the trailer
   * assigned to the dispatch route. Note that trailers can only be assigned to
   * routes that have a Vehicle or Driver assigned to them.
   *
   * @param {number} [updateDispatchRouteParams.vehicleId] ID of the vehicle
   * assigned to the dispatch route. Note that vehicle_id and driver_id are
   * mutually exclusive. If neither is specified, then the route is unassigned.
   *
   * @param {number} routeId ID of the dispatch route.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<DispatchRoute>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  updateDispatchRouteByIdWithHttpOperationResponse(updateDispatchRouteParams, routeId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._updateDispatchRouteById(updateDispatchRouteParams, routeId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary /fleet/dispatch/routes/{route_id:[0-9]+}/
   *
   * Update a dispatch route and its associated jobs.
   *
   * @param {object} updateDispatchRouteParams
   *
   * @param {array} updateDispatchRouteParams.dispatchJobs The dispatch jobs
   * associated with this route.
   *
   * @param {number} updateDispatchRouteParams.id ID of the Samsara dispatch
   * route.
   *
   * @param {number} [updateDispatchRouteParams.actualEndMs] The time in Unix
   * epoch milliseconds that the route actually ended.
   *
   * @param {number} [updateDispatchRouteParams.actualStartMs] The time in Unix
   * epoch milliseconds that the route actually started.
   *
   * @param {number} [updateDispatchRouteParams.driverId] ID of the driver
   * assigned to the dispatch route. Note that driver_id and vehicle_id are
   * mutually exclusive. If neither is specified, then the route is unassigned.
   *
   * @param {number} [updateDispatchRouteParams.groupId] ID of the group if the
   * organization has multiple groups (optional).
   *
   * @param {string} updateDispatchRouteParams.name Descriptive name of this
   * route.
   *
   * @param {number} updateDispatchRouteParams.scheduledEndMs The time in Unix
   * epoch milliseconds that the last job in the route is scheduled to end.
   *
   * @param {number} [updateDispatchRouteParams.scheduledMeters] The distance
   * expected to be traveled for this route in meters.
   *
   * @param {number} updateDispatchRouteParams.scheduledStartMs The time in Unix
   * epoch milliseconds that the route is scheduled to start.
   *
   * @param {string} [updateDispatchRouteParams.startLocationAddress] The address
   * of the route's starting location, as it would be recognized if provided to
   * maps.google.com. Optional if a valid start location address ID is provided.
   *
   * @param {number} [updateDispatchRouteParams.startLocationAddressId] ID of the
   * start location associated with an address book entry. Optional if valid
   * values are provided for start location address or latitude/longitude. If a
   * valid start location address ID is provided, address/latitude/longitude will
   * be used from the address book entry. Name of the address book entry will
   * only be used if the start location name is not provided.
   *
   * @param {number} [updateDispatchRouteParams.startLocationLat] Latitude of the
   * start location in decimal degrees. Optional if a valid start location
   * address ID is provided.
   *
   * @param {number} [updateDispatchRouteParams.startLocationLng] Longitude of
   * the start location in decimal degrees. Optional if a valid start location
   * address ID is provided.
   *
   * @param {string} [updateDispatchRouteParams.startLocationName] The name of
   * the route's starting location. If provided, it will take precedence over the
   * name of the address book entry.
   *
   * @param {number} [updateDispatchRouteParams.trailerId] ID of the trailer
   * assigned to the dispatch route. Note that trailers can only be assigned to
   * routes that have a Vehicle or Driver assigned to them.
   *
   * @param {number} [updateDispatchRouteParams.vehicleId] ID of the vehicle
   * assigned to the dispatch route. Note that vehicle_id and driver_id are
   * mutually exclusive. If neither is specified, then the route is unassigned.
   *
   * @param {number} routeId ID of the dispatch route.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {DispatchRoute} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link DispatchRoute} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  updateDispatchRouteById(updateDispatchRouteParams, routeId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._updateDispatchRouteById(updateDispatchRouteParams, routeId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._updateDispatchRouteById(updateDispatchRouteParams, routeId, options, optionalCallback);
    }
  }

  /**
   * @summary /fleet/dispatch/routes/{route_id:[0-9]+}/
   *
   * Delete a dispatch route and its associated jobs.
   *
   * @param {number} routeId ID of the dispatch route.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deleteDispatchRouteByIdWithHttpOperationResponse(routeId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deleteDispatchRouteById(routeId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary /fleet/dispatch/routes/{route_id:[0-9]+}/
   *
   * Delete a dispatch route and its associated jobs.
   *
   * @param {number} routeId ID of the dispatch route.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteDispatchRouteById(routeId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deleteDispatchRouteById(routeId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deleteDispatchRouteById(routeId, options, optionalCallback);
    }
  }

  /**
   * @summary /fleet/dispatch/routes/{route_id:[0-9]+}/history
   *
   * Fetch the history of a dispatch route.
   *
   * @param {number} routeId ID of the route with history.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<DispatchRouteHistory>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getDispatchRouteHistoryWithHttpOperationResponse(routeId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getDispatchRouteHistory(routeId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary /fleet/dispatch/routes/{route_id:[0-9]+}/history
   *
   * Fetch the history of a dispatch route.
   *
   * @param {number} routeId ID of the route with history.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {DispatchRouteHistory} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link DispatchRouteHistory} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getDispatchRouteHistory(routeId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getDispatchRouteHistory(routeId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getDispatchRouteHistory(routeId, options, optionalCallback);
    }
  }

  /**
   * @summary /fleet/drivers/create
   *
   * Create a new driver.
   *
   * @param {object} createDriverParam Driver creation body
   *
   * @param {string} createDriverParam.password Driver's password for the driver
   * app.
   *
   * @param {array} [createDriverParam.tagIds]
   *
   * @param {boolean} [createDriverParam.eldAdverseWeatherExemptionEnabled] Flag
   * indicating this driver may use Adverse Weather exemptions in ELD logs.
   *
   * @param {boolean} [createDriverParam.eldBigDayExemptionEnabled] Flag
   * indicating this driver may use Big Day excemptions in ELD logs.
   *
   * @param {number} [createDriverParam.eldDayStartHour] 0 indicating
   * midnight-to-midnight ELD driving hours, 12 to indicate noon-to-noon driving
   * hours.
   *
   * @param {boolean} [createDriverParam.eldExempt] Flag indicating this driver
   * is exempt from the Electronic Logging Mandate.
   *
   * @param {string} [createDriverParam.eldExemptReason] Reason that this driver
   * is exempt from the Electronic Logging Mandate (see eldExempt).
   *
   * @param {boolean} [createDriverParam.eldPcEnabled] Flag indicating this
   * driver may select the Personal Conveyance duty status in ELD logs.
   *
   * @param {boolean} [createDriverParam.eldYmEnabled] Flag indicating this
   * driver may select the Yard Move duty status in ELD logs.
   *
   * @param {object} [createDriverParam.externalIds] Dictionary of external IDs
   * (string key-value pairs)
   *
   * @param {number} [createDriverParam.groupId] ID of the group if the
   * organization has multiple groups (uncommon).
   *
   * @param {string} [createDriverParam.licenseNumber] Driver's state issued
   * license number.
   *
   * @param {string} [createDriverParam.licenseState] Abbreviation of state that
   * issued driver's license.
   *
   * @param {string} createDriverParam.name Driver's name.
   *
   * @param {string} [createDriverParam.notes] Notes about the driver.
   *
   * @param {string} [createDriverParam.phone] Driver's phone number. Please
   * include only digits, ex. 4157771234
   *
   * @param {string} [createDriverParam.username] Driver's login username into
   * the driver app.
   *
   * @param {number} [createDriverParam.vehicleId] ID of the vehicle assigned to
   * the driver for static vehicle assignments. (uncommon).
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<CurrentDriver>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  createDriverWithHttpOperationResponse(createDriverParam, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._createDriver(createDriverParam, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary /fleet/drivers/create
   *
   * Create a new driver.
   *
   * @param {object} createDriverParam Driver creation body
   *
   * @param {string} createDriverParam.password Driver's password for the driver
   * app.
   *
   * @param {array} [createDriverParam.tagIds]
   *
   * @param {boolean} [createDriverParam.eldAdverseWeatherExemptionEnabled] Flag
   * indicating this driver may use Adverse Weather exemptions in ELD logs.
   *
   * @param {boolean} [createDriverParam.eldBigDayExemptionEnabled] Flag
   * indicating this driver may use Big Day excemptions in ELD logs.
   *
   * @param {number} [createDriverParam.eldDayStartHour] 0 indicating
   * midnight-to-midnight ELD driving hours, 12 to indicate noon-to-noon driving
   * hours.
   *
   * @param {boolean} [createDriverParam.eldExempt] Flag indicating this driver
   * is exempt from the Electronic Logging Mandate.
   *
   * @param {string} [createDriverParam.eldExemptReason] Reason that this driver
   * is exempt from the Electronic Logging Mandate (see eldExempt).
   *
   * @param {boolean} [createDriverParam.eldPcEnabled] Flag indicating this
   * driver may select the Personal Conveyance duty status in ELD logs.
   *
   * @param {boolean} [createDriverParam.eldYmEnabled] Flag indicating this
   * driver may select the Yard Move duty status in ELD logs.
   *
   * @param {object} [createDriverParam.externalIds] Dictionary of external IDs
   * (string key-value pairs)
   *
   * @param {number} [createDriverParam.groupId] ID of the group if the
   * organization has multiple groups (uncommon).
   *
   * @param {string} [createDriverParam.licenseNumber] Driver's state issued
   * license number.
   *
   * @param {string} [createDriverParam.licenseState] Abbreviation of state that
   * issued driver's license.
   *
   * @param {string} createDriverParam.name Driver's name.
   *
   * @param {string} [createDriverParam.notes] Notes about the driver.
   *
   * @param {string} [createDriverParam.phone] Driver's phone number. Please
   * include only digits, ex. 4157771234
   *
   * @param {string} [createDriverParam.username] Driver's login username into
   * the driver app.
   *
   * @param {number} [createDriverParam.vehicleId] ID of the vehicle assigned to
   * the driver for static vehicle assignments. (uncommon).
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {CurrentDriver} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link CurrentDriver} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  createDriver(createDriverParam, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._createDriver(createDriverParam, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._createDriver(createDriverParam, options, optionalCallback);
    }
  }

  /**
   * @summary /fleet/drivers/document_types
   *
   * Fetch all of the document types.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getDriverDocumentTypesByOrgIdWithHttpOperationResponse(options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getDriverDocumentTypesByOrgId(options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary /fleet/drivers/document_types
   *
   * Fetch all of the document types.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getDriverDocumentTypesByOrgId(options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getDriverDocumentTypesByOrgId(options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getDriverDocumentTypesByOrgId(options, optionalCallback);
    }
  }

  /**
   * @summary /fleet/drivers/documents
   *
   * Fetch all of the documents.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getDriverDocumentsByOrgIdWithHttpOperationResponse(options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getDriverDocumentsByOrgId(options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary /fleet/drivers/documents
   *
   * Fetch all of the documents.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getDriverDocumentsByOrgId(options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getDriverDocumentsByOrgId(options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getDriverDocumentsByOrgId(options, optionalCallback);
    }
  }

  /**
   * @summary /fleet/drivers/inactive
   *
   * Fetch all deactivated drivers for the group.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getAllDeactivatedDriversWithHttpOperationResponse(options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getAllDeactivatedDrivers(options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary /fleet/drivers/inactive
   *
   * Fetch all deactivated drivers for the group.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getAllDeactivatedDrivers(options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getAllDeactivatedDrivers(options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getAllDeactivatedDrivers(options, optionalCallback);
    }
  }

  /**
   * @summary /fleet/drivers/inactive/{driver_id:[0-9]+ |
   * external_id:[a-zA-Z0-9]+}
   *
   * Fetch deactivated driver by id.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<CurrentDriver>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getDeactivatedDriverByIdWithHttpOperationResponse(options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getDeactivatedDriverById(options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary /fleet/drivers/inactive/{driver_id:[0-9]+ |
   * external_id:[a-zA-Z0-9]+}
   *
   * Fetch deactivated driver by id.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {CurrentDriver} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link CurrentDriver} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getDeactivatedDriverById(options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getDeactivatedDriverById(options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getDeactivatedDriverById(options, optionalCallback);
    }
  }

  /**
   * @summary /fleet/drivers/inactive/{driver_id:[0-9]+ |
   * external_id:[a-zA-Z0-9]+}
   *
   * Reactivate the inactive driver having id.
   *
   * @param {object} reactivateDriverParam Driver reactivation body
   *
   * @param {boolean} reactivateDriverParam.reactivate True indicates that this
   * driver should be reactivated.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<CurrentDriver>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  reactivateDriverByIdWithHttpOperationResponse(reactivateDriverParam, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._reactivateDriverById(reactivateDriverParam, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary /fleet/drivers/inactive/{driver_id:[0-9]+ |
   * external_id:[a-zA-Z0-9]+}
   *
   * Reactivate the inactive driver having id.
   *
   * @param {object} reactivateDriverParam Driver reactivation body
   *
   * @param {boolean} reactivateDriverParam.reactivate True indicates that this
   * driver should be reactivated.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {CurrentDriver} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link CurrentDriver} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  reactivateDriverById(reactivateDriverParam, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._reactivateDriverById(reactivateDriverParam, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._reactivateDriverById(reactivateDriverParam, options, optionalCallback);
    }
  }

  /**
   * @summary /fleet/drivers/{driverId:[0-9]+}/safety/score
   *
   * Fetch the safety score for the driver.
   *
   * @param {number} driverId ID of the driver
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<DriverSafetyScoreResponse>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getDriverSafetyScoreWithHttpOperationResponse(driverId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getDriverSafetyScore(driverId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary /fleet/drivers/{driverId:[0-9]+}/safety/score
   *
   * Fetch the safety score for the driver.
   *
   * @param {number} driverId ID of the driver
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {DriverSafetyScoreResponse} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link DriverSafetyScoreResponse} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getDriverSafetyScore(driverId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getDriverSafetyScore(driverId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getDriverSafetyScore(driverId, options, optionalCallback);
    }
  }

  /**
   * @summary /fleet/drivers/{driver_id:[0-9]+ | external_id:[a-zA-Z0-9]+}
   *
   * Fetch driver by id.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<CurrentDriver>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getDriverByIdWithHttpOperationResponse(options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getDriverById(options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary /fleet/drivers/{driver_id:[0-9]+ | external_id:[a-zA-Z0-9]+}
   *
   * Fetch driver by id.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {CurrentDriver} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link CurrentDriver} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getDriverById(options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getDriverById(options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getDriverById(options, optionalCallback);
    }
  }

  /**
   * @summary /fleet/drivers/{driver_id:[0-9]+ | external_id:[a-zA-Z0-9]+}
   *
   * Deactivate a driver with the given id.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deactivateDriverWithHttpOperationResponse(options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deactivateDriver(options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary /fleet/drivers/{driver_id:[0-9]+ | external_id:[a-zA-Z0-9]+}
   *
   * Deactivate a driver with the given id.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deactivateDriver(options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deactivateDriver(options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deactivateDriver(options, optionalCallback);
    }
  }

  /**
   * @summary /fleet/drivers/{driver_id:[0-9]+}/dispatch/routes
   *
   * Fetch all of the dispatch routes for a given driver.
   *
   * @param {number} driverId ID of the driver with the associated routes.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getDispatchRoutesByDriverIdWithHttpOperationResponse(driverId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getDispatchRoutesByDriverId(driverId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary /fleet/drivers/{driver_id:[0-9]+}/dispatch/routes
   *
   * Fetch all of the dispatch routes for a given driver.
   *
   * @param {number} driverId ID of the driver with the associated routes.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getDispatchRoutesByDriverId(driverId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getDispatchRoutesByDriverId(driverId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getDispatchRoutesByDriverId(driverId, options, optionalCallback);
    }
  }

  /**
   * @summary /fleet/drivers/{driver_id:[0-9]+}/dispatch/routes
   *
   * Create a new dispatch route for the driver with driver_id.
   *
   * @param {object} createDispatchRouteParams
   *
   * @param {array} createDispatchRouteParams.dispatchJobs The dispatch jobs to
   * create for this route.
   *
   * @param {number} [createDispatchRouteParams.actualEndMs] The time in Unix
   * epoch milliseconds that the route actually ended.
   *
   * @param {number} [createDispatchRouteParams.actualStartMs] The time in Unix
   * epoch milliseconds that the route actually started.
   *
   * @param {number} [createDispatchRouteParams.driverId] ID of the driver
   * assigned to the dispatch route. Note that driver_id and vehicle_id are
   * mutually exclusive. If neither is specified, then the route is unassigned.
   *
   * @param {number} [createDispatchRouteParams.groupId] ID of the group if the
   * organization has multiple groups (optional).
   *
   * @param {string} createDispatchRouteParams.name Descriptive name of this
   * route.
   *
   * @param {number} createDispatchRouteParams.scheduledEndMs The time in Unix
   * epoch milliseconds that the last job in the route is scheduled to end.
   *
   * @param {number} [createDispatchRouteParams.scheduledMeters] The distance
   * expected to be traveled for this route in meters.
   *
   * @param {number} createDispatchRouteParams.scheduledStartMs The time in Unix
   * epoch milliseconds that the route is scheduled to start.
   *
   * @param {string} [createDispatchRouteParams.startLocationAddress] The address
   * of the route's starting location, as it would be recognized if provided to
   * maps.google.com. Optional if a valid start location address ID is provided.
   *
   * @param {number} [createDispatchRouteParams.startLocationAddressId] ID of the
   * start location associated with an address book entry. Optional if valid
   * values are provided for start location address or latitude/longitude. If a
   * valid start location address ID is provided, address/latitude/longitude will
   * be used from the address book entry. Name of the address book entry will
   * only be used if the start location name is not provided.
   *
   * @param {number} [createDispatchRouteParams.startLocationLat] Latitude of the
   * start location in decimal degrees. Optional if a valid start location
   * address ID is provided.
   *
   * @param {number} [createDispatchRouteParams.startLocationLng] Longitude of
   * the start location in decimal degrees. Optional if a valid start location
   * address ID is provided.
   *
   * @param {string} [createDispatchRouteParams.startLocationName] The name of
   * the route's starting location. If provided, it will take precedence over the
   * name of the address book entry.
   *
   * @param {number} [createDispatchRouteParams.trailerId] ID of the trailer
   * assigned to the dispatch route. Note that trailers can only be assigned to
   * routes that have a Vehicle or Driver assigned to them.
   *
   * @param {number} [createDispatchRouteParams.vehicleId] ID of the vehicle
   * assigned to the dispatch route. Note that vehicle_id and driver_id are
   * mutually exclusive. If neither is specified, then the route is unassigned.
   *
   * @param {number} driverId ID of the driver with the associated routes.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<DispatchRoute>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  createDriverDispatchRouteWithHttpOperationResponse(createDispatchRouteParams, driverId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._createDriverDispatchRoute(createDispatchRouteParams, driverId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary /fleet/drivers/{driver_id:[0-9]+}/dispatch/routes
   *
   * Create a new dispatch route for the driver with driver_id.
   *
   * @param {object} createDispatchRouteParams
   *
   * @param {array} createDispatchRouteParams.dispatchJobs The dispatch jobs to
   * create for this route.
   *
   * @param {number} [createDispatchRouteParams.actualEndMs] The time in Unix
   * epoch milliseconds that the route actually ended.
   *
   * @param {number} [createDispatchRouteParams.actualStartMs] The time in Unix
   * epoch milliseconds that the route actually started.
   *
   * @param {number} [createDispatchRouteParams.driverId] ID of the driver
   * assigned to the dispatch route. Note that driver_id and vehicle_id are
   * mutually exclusive. If neither is specified, then the route is unassigned.
   *
   * @param {number} [createDispatchRouteParams.groupId] ID of the group if the
   * organization has multiple groups (optional).
   *
   * @param {string} createDispatchRouteParams.name Descriptive name of this
   * route.
   *
   * @param {number} createDispatchRouteParams.scheduledEndMs The time in Unix
   * epoch milliseconds that the last job in the route is scheduled to end.
   *
   * @param {number} [createDispatchRouteParams.scheduledMeters] The distance
   * expected to be traveled for this route in meters.
   *
   * @param {number} createDispatchRouteParams.scheduledStartMs The time in Unix
   * epoch milliseconds that the route is scheduled to start.
   *
   * @param {string} [createDispatchRouteParams.startLocationAddress] The address
   * of the route's starting location, as it would be recognized if provided to
   * maps.google.com. Optional if a valid start location address ID is provided.
   *
   * @param {number} [createDispatchRouteParams.startLocationAddressId] ID of the
   * start location associated with an address book entry. Optional if valid
   * values are provided for start location address or latitude/longitude. If a
   * valid start location address ID is provided, address/latitude/longitude will
   * be used from the address book entry. Name of the address book entry will
   * only be used if the start location name is not provided.
   *
   * @param {number} [createDispatchRouteParams.startLocationLat] Latitude of the
   * start location in decimal degrees. Optional if a valid start location
   * address ID is provided.
   *
   * @param {number} [createDispatchRouteParams.startLocationLng] Longitude of
   * the start location in decimal degrees. Optional if a valid start location
   * address ID is provided.
   *
   * @param {string} [createDispatchRouteParams.startLocationName] The name of
   * the route's starting location. If provided, it will take precedence over the
   * name of the address book entry.
   *
   * @param {number} [createDispatchRouteParams.trailerId] ID of the trailer
   * assigned to the dispatch route. Note that trailers can only be assigned to
   * routes that have a Vehicle or Driver assigned to them.
   *
   * @param {number} [createDispatchRouteParams.vehicleId] ID of the vehicle
   * assigned to the dispatch route. Note that vehicle_id and driver_id are
   * mutually exclusive. If neither is specified, then the route is unassigned.
   *
   * @param {number} driverId ID of the driver with the associated routes.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {DispatchRoute} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link DispatchRoute} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  createDriverDispatchRoute(createDispatchRouteParams, driverId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._createDriverDispatchRoute(createDispatchRouteParams, driverId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._createDriverDispatchRoute(createDispatchRouteParams, driverId, options, optionalCallback);
    }
  }

  /**
   * @summary /fleet/drivers/{driver_id:[0-9]+}/documents
   *
   * Create a driver document for the given driver.
   *
   * @param {object} createDocumentParams To create a document for a given
   * document type, the document type's uuid needs to be passed in to
   * documentTypeUuid. The list of fields passed in should match the document
   * types list of field types in the correct order. In other words, a field's
   * valueType and value (i.e. only one of: stringValue, numberValue, or
   * photoValue) at index _i_ should match with the document field types
   * valueType at index _i_.
   *
   * @param {string} createDocumentParams.documentTypeUuid Universally unique
   * identifier for the document type this document is being created for.
   *
   * @param {array} createDocumentParams.fields List of fields should match the
   * document types list of field types in the correct order. In other words, a
   * field's valueType and value (i.e. only one of: stringValue, numberValue, or
   * photoValue) at index _i_ should match with the document field types
   * valueType at index _i_.
   *
   * @param {number} [createDocumentParams.dispatchJobId] ID of the Samsara
   * dispatch job for which the document is submitted
   *
   * @param {string} [createDocumentParams.notes] Notes submitted with this
   * document.
   *
   * @param {number} driverId ID of the driver for whom the document is created.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Document>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  createDriverDocumentWithHttpOperationResponse(createDocumentParams, driverId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._createDriverDocument(createDocumentParams, driverId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary /fleet/drivers/{driver_id:[0-9]+}/documents
   *
   * Create a driver document for the given driver.
   *
   * @param {object} createDocumentParams To create a document for a given
   * document type, the document type's uuid needs to be passed in to
   * documentTypeUuid. The list of fields passed in should match the document
   * types list of field types in the correct order. In other words, a field's
   * valueType and value (i.e. only one of: stringValue, numberValue, or
   * photoValue) at index _i_ should match with the document field types
   * valueType at index _i_.
   *
   * @param {string} createDocumentParams.documentTypeUuid Universally unique
   * identifier for the document type this document is being created for.
   *
   * @param {array} createDocumentParams.fields List of fields should match the
   * document types list of field types in the correct order. In other words, a
   * field's valueType and value (i.e. only one of: stringValue, numberValue, or
   * photoValue) at index _i_ should match with the document field types
   * valueType at index _i_.
   *
   * @param {number} [createDocumentParams.dispatchJobId] ID of the Samsara
   * dispatch job for which the document is submitted
   *
   * @param {string} [createDocumentParams.notes] Notes submitted with this
   * document.
   *
   * @param {number} driverId ID of the driver for whom the document is created.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Document} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Document} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  createDriverDocument(createDocumentParams, driverId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._createDriverDocument(createDocumentParams, driverId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._createDriverDocument(createDocumentParams, driverId, options, optionalCallback);
    }
  }

  /**
   * @summary /fleet/vehicles/locations
   *
   * Fetch locations for a given vehicle between a start/end time. The maximum
   * query duration is 30 minutes.
   *
   * @param {number} startMs Time in Unix epoch milliseconds for the start of the
   * query (cannot exceed 30 minutes)
   *
   * @param {number} endMs Time in Unix epoch milliseconds for the end of the
   * query (cannot exceed 30 minutes)
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getVehiclesLocationsWithHttpOperationResponse(startMs, endMs, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getVehiclesLocations(startMs, endMs, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary /fleet/vehicles/locations
   *
   * Fetch locations for a given vehicle between a start/end time. The maximum
   * query duration is 30 minutes.
   *
   * @param {number} startMs Time in Unix epoch milliseconds for the start of the
   * query (cannot exceed 30 minutes)
   *
   * @param {number} endMs Time in Unix epoch milliseconds for the end of the
   * query (cannot exceed 30 minutes)
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getVehiclesLocations(startMs, endMs, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getVehiclesLocations(startMs, endMs, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getVehiclesLocations(startMs, endMs, options, optionalCallback);
    }
  }

  /**
   * @summary /fleet/vehicles/stats
   *
   * Fetch engine state and aux input data for all vehicles in the group between
   * a start/end time. Data returned may be affected by device connectivity and
   * processing time.
   *
   * @param {number} startMs Time in Unix epoch milliseconds for the start of the
   * query.
   *
   * @param {number} endMs Time in Unix epoch milliseconds for the end of the
   * query.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.series] Comma-separated list of stat types. Options
   * are engineState, auxInput1, and auxInput2. If this parameter is excluded,
   * all 3 stat types will be returned. Example: series=engineState,auxInput2.
   * Possible values include: 'engineState', 'auxInput1', 'auxInput2'
   *
   * @param {string} [options.tagIds] Comma-separated list of tag ids. Example:
   * tagIds=1,2,3
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<GetVehicleStatsOKResponse>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getVehicleStatsWithHttpOperationResponse(startMs, endMs, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getVehicleStats(startMs, endMs, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary /fleet/vehicles/stats
   *
   * Fetch engine state and aux input data for all vehicles in the group between
   * a start/end time. Data returned may be affected by device connectivity and
   * processing time.
   *
   * @param {number} startMs Time in Unix epoch milliseconds for the start of the
   * query.
   *
   * @param {number} endMs Time in Unix epoch milliseconds for the end of the
   * query.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.series] Comma-separated list of stat types. Options
   * are engineState, auxInput1, and auxInput2. If this parameter is excluded,
   * all 3 stat types will be returned. Example: series=engineState,auxInput2.
   * Possible values include: 'engineState', 'auxInput1', 'auxInput2'
   *
   * @param {string} [options.tagIds] Comma-separated list of tag ids. Example:
   * tagIds=1,2,3
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {GetVehicleStatsOKResponse} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link GetVehicleStatsOKResponse} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getVehicleStats(startMs, endMs, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getVehicleStats(startMs, endMs, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getVehicleStats(startMs, endMs, options, optionalCallback);
    }
  }

  /**
   * @summary /fleet/vehicles/{vehicleId:[0-9]+}/safety/harsh_event
   *
   * Fetch harsh event details for a vehicle.
   *
   * @param {number} vehicleId ID of the vehicle
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<VehicleHarshEventResponse>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getVehicleHarshEventWithHttpOperationResponse(vehicleId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getVehicleHarshEvent(vehicleId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary /fleet/vehicles/{vehicleId:[0-9]+}/safety/harsh_event
   *
   * Fetch harsh event details for a vehicle.
   *
   * @param {number} vehicleId ID of the vehicle
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {VehicleHarshEventResponse} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link VehicleHarshEventResponse} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getVehicleHarshEvent(vehicleId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getVehicleHarshEvent(vehicleId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getVehicleHarshEvent(vehicleId, options, optionalCallback);
    }
  }

  /**
   * @summary /fleet/vehicles/{vehicleId:[0-9]+}/safety/score
   *
   * Fetch the safety score for the vehicle.
   *
   * @param {number} vehicleId ID of the vehicle
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<VehicleSafetyScoreResponse>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getVehicleSafetyScoreWithHttpOperationResponse(vehicleId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getVehicleSafetyScore(vehicleId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary /fleet/vehicles/{vehicleId:[0-9]+}/safety/score
   *
   * Fetch the safety score for the vehicle.
   *
   * @param {number} vehicleId ID of the vehicle
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {VehicleSafetyScoreResponse} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link VehicleSafetyScoreResponse} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getVehicleSafetyScore(vehicleId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getVehicleSafetyScore(vehicleId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getVehicleSafetyScore(vehicleId, options, optionalCallback);
    }
  }

  /**
   * @summary /fleet/vehicles/{vehicle_id:[0-9]+ | external_id:[a-zA-Z0-9]+}
   *
   * Gets a specific vehicle.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<FleetVehicleResponse>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getFleetVehicleWithHttpOperationResponse(options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getFleetVehicle(options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary /fleet/vehicles/{vehicle_id:[0-9]+ | external_id:[a-zA-Z0-9]+}
   *
   * Gets a specific vehicle.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {FleetVehicleResponse} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link FleetVehicleResponse} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getFleetVehicle(options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getFleetVehicle(options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getFleetVehicle(options, optionalCallback);
    }
  }

  /**
   * @summary /fleet/vehicles/{vehicle_id:[0-9]+ | external_id:[a-zA-Z0-9]+}
   *
   * Updates the specified vehicle using JSON merge patch format. See IETF RFC
   * 7396: https://tools.ietf.org/html/rfc7396.
   *
   * @param {object} data
   *
   * @param {object} [data.externalIds]
   *
   * @param {number} [data.harshAccelSetting] Harsh Event Detection Setting
   * * 0: Passenger
   * * 1: Light Truck
   * * 2: Heavy
   * * 3: Off
   * * 4: Automatic
   *
   * @param {string} [data.name] Name
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<FleetVehicleResponse>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  patchFleetVehicleWithHttpOperationResponse(data, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._patchFleetVehicle(data, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary /fleet/vehicles/{vehicle_id:[0-9]+ | external_id:[a-zA-Z0-9]+}
   *
   * Updates the specified vehicle using JSON merge patch format. See IETF RFC
   * 7396: https://tools.ietf.org/html/rfc7396.
   *
   * @param {object} data
   *
   * @param {object} [data.externalIds]
   *
   * @param {number} [data.harshAccelSetting] Harsh Event Detection Setting
   * * 0: Passenger
   * * 1: Light Truck
   * * 2: Heavy
   * * 3: Off
   * * 4: Automatic
   *
   * @param {string} [data.name] Name
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {FleetVehicleResponse} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link FleetVehicleResponse} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  patchFleetVehicle(data, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._patchFleetVehicle(data, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._patchFleetVehicle(data, options, optionalCallback);
    }
  }

  /**
   * @summary /fleet/vehicles/{vehicle_id:[0-9]+}/dispatch/routes
   *
   * Fetch all of the dispatch routes for a given vehicle.
   *
   * @param {number} vehicleId ID of the vehicle with the associated routes.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getDispatchRoutesByVehicleIdWithHttpOperationResponse(vehicleId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getDispatchRoutesByVehicleId(vehicleId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary /fleet/vehicles/{vehicle_id:[0-9]+}/dispatch/routes
   *
   * Fetch all of the dispatch routes for a given vehicle.
   *
   * @param {number} vehicleId ID of the vehicle with the associated routes.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getDispatchRoutesByVehicleId(vehicleId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getDispatchRoutesByVehicleId(vehicleId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getDispatchRoutesByVehicleId(vehicleId, options, optionalCallback);
    }
  }

  /**
   * @summary /fleet/vehicles/{vehicle_id:[0-9]+}/dispatch/routes
   *
   * Create a new dispatch route for the vehicle with vehicle_id.
   *
   * @param {object} createDispatchRouteParams
   *
   * @param {array} createDispatchRouteParams.dispatchJobs The dispatch jobs to
   * create for this route.
   *
   * @param {number} [createDispatchRouteParams.actualEndMs] The time in Unix
   * epoch milliseconds that the route actually ended.
   *
   * @param {number} [createDispatchRouteParams.actualStartMs] The time in Unix
   * epoch milliseconds that the route actually started.
   *
   * @param {number} [createDispatchRouteParams.driverId] ID of the driver
   * assigned to the dispatch route. Note that driver_id and vehicle_id are
   * mutually exclusive. If neither is specified, then the route is unassigned.
   *
   * @param {number} [createDispatchRouteParams.groupId] ID of the group if the
   * organization has multiple groups (optional).
   *
   * @param {string} createDispatchRouteParams.name Descriptive name of this
   * route.
   *
   * @param {number} createDispatchRouteParams.scheduledEndMs The time in Unix
   * epoch milliseconds that the last job in the route is scheduled to end.
   *
   * @param {number} [createDispatchRouteParams.scheduledMeters] The distance
   * expected to be traveled for this route in meters.
   *
   * @param {number} createDispatchRouteParams.scheduledStartMs The time in Unix
   * epoch milliseconds that the route is scheduled to start.
   *
   * @param {string} [createDispatchRouteParams.startLocationAddress] The address
   * of the route's starting location, as it would be recognized if provided to
   * maps.google.com. Optional if a valid start location address ID is provided.
   *
   * @param {number} [createDispatchRouteParams.startLocationAddressId] ID of the
   * start location associated with an address book entry. Optional if valid
   * values are provided for start location address or latitude/longitude. If a
   * valid start location address ID is provided, address/latitude/longitude will
   * be used from the address book entry. Name of the address book entry will
   * only be used if the start location name is not provided.
   *
   * @param {number} [createDispatchRouteParams.startLocationLat] Latitude of the
   * start location in decimal degrees. Optional if a valid start location
   * address ID is provided.
   *
   * @param {number} [createDispatchRouteParams.startLocationLng] Longitude of
   * the start location in decimal degrees. Optional if a valid start location
   * address ID is provided.
   *
   * @param {string} [createDispatchRouteParams.startLocationName] The name of
   * the route's starting location. If provided, it will take precedence over the
   * name of the address book entry.
   *
   * @param {number} [createDispatchRouteParams.trailerId] ID of the trailer
   * assigned to the dispatch route. Note that trailers can only be assigned to
   * routes that have a Vehicle or Driver assigned to them.
   *
   * @param {number} [createDispatchRouteParams.vehicleId] ID of the vehicle
   * assigned to the dispatch route. Note that vehicle_id and driver_id are
   * mutually exclusive. If neither is specified, then the route is unassigned.
   *
   * @param {number} vehicleId ID of the vehicle with the associated routes.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<DispatchRoute>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  createVehicleDispatchRouteWithHttpOperationResponse(createDispatchRouteParams, vehicleId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._createVehicleDispatchRoute(createDispatchRouteParams, vehicleId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary /fleet/vehicles/{vehicle_id:[0-9]+}/dispatch/routes
   *
   * Create a new dispatch route for the vehicle with vehicle_id.
   *
   * @param {object} createDispatchRouteParams
   *
   * @param {array} createDispatchRouteParams.dispatchJobs The dispatch jobs to
   * create for this route.
   *
   * @param {number} [createDispatchRouteParams.actualEndMs] The time in Unix
   * epoch milliseconds that the route actually ended.
   *
   * @param {number} [createDispatchRouteParams.actualStartMs] The time in Unix
   * epoch milliseconds that the route actually started.
   *
   * @param {number} [createDispatchRouteParams.driverId] ID of the driver
   * assigned to the dispatch route. Note that driver_id and vehicle_id are
   * mutually exclusive. If neither is specified, then the route is unassigned.
   *
   * @param {number} [createDispatchRouteParams.groupId] ID of the group if the
   * organization has multiple groups (optional).
   *
   * @param {string} createDispatchRouteParams.name Descriptive name of this
   * route.
   *
   * @param {number} createDispatchRouteParams.scheduledEndMs The time in Unix
   * epoch milliseconds that the last job in the route is scheduled to end.
   *
   * @param {number} [createDispatchRouteParams.scheduledMeters] The distance
   * expected to be traveled for this route in meters.
   *
   * @param {number} createDispatchRouteParams.scheduledStartMs The time in Unix
   * epoch milliseconds that the route is scheduled to start.
   *
   * @param {string} [createDispatchRouteParams.startLocationAddress] The address
   * of the route's starting location, as it would be recognized if provided to
   * maps.google.com. Optional if a valid start location address ID is provided.
   *
   * @param {number} [createDispatchRouteParams.startLocationAddressId] ID of the
   * start location associated with an address book entry. Optional if valid
   * values are provided for start location address or latitude/longitude. If a
   * valid start location address ID is provided, address/latitude/longitude will
   * be used from the address book entry. Name of the address book entry will
   * only be used if the start location name is not provided.
   *
   * @param {number} [createDispatchRouteParams.startLocationLat] Latitude of the
   * start location in decimal degrees. Optional if a valid start location
   * address ID is provided.
   *
   * @param {number} [createDispatchRouteParams.startLocationLng] Longitude of
   * the start location in decimal degrees. Optional if a valid start location
   * address ID is provided.
   *
   * @param {string} [createDispatchRouteParams.startLocationName] The name of
   * the route's starting location. If provided, it will take precedence over the
   * name of the address book entry.
   *
   * @param {number} [createDispatchRouteParams.trailerId] ID of the trailer
   * assigned to the dispatch route. Note that trailers can only be assigned to
   * routes that have a Vehicle or Driver assigned to them.
   *
   * @param {number} [createDispatchRouteParams.vehicleId] ID of the vehicle
   * assigned to the dispatch route. Note that vehicle_id and driver_id are
   * mutually exclusive. If neither is specified, then the route is unassigned.
   *
   * @param {number} vehicleId ID of the vehicle with the associated routes.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {DispatchRoute} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link DispatchRoute} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  createVehicleDispatchRoute(createDispatchRouteParams, vehicleId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._createVehicleDispatchRoute(createDispatchRouteParams, vehicleId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._createVehicleDispatchRoute(createDispatchRouteParams, vehicleId, options, optionalCallback);
    }
  }

  /**
   * @summary /fleet/vehicles/{vehicle_id:[0-9]+}/locations
   *
   * Fetch locations for a given vehicle between a start/end time. The maximum
   * query duration is one hour.
   *
   * @param {number} vehicleId ID of the vehicle with the associated routes.
   *
   * @param {number} startMs Time in Unix epoch milliseconds for the start of the
   * query (cannot exceed 1 hour)
   *
   * @param {number} endMs Time in Unix epoch milliseconds for the end of the
   * query (cannot exceed 1 hour)
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getVehicleLocationsWithHttpOperationResponse(vehicleId, startMs, endMs, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getVehicleLocations(vehicleId, startMs, endMs, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary /fleet/vehicles/{vehicle_id:[0-9]+}/locations
   *
   * Fetch locations for a given vehicle between a start/end time. The maximum
   * query duration is one hour.
   *
   * @param {number} vehicleId ID of the vehicle with the associated routes.
   *
   * @param {number} startMs Time in Unix epoch milliseconds for the start of the
   * query (cannot exceed 1 hour)
   *
   * @param {number} endMs Time in Unix epoch milliseconds for the end of the
   * query (cannot exceed 1 hour)
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getVehicleLocations(vehicleId, startMs, endMs, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getVehicleLocations(vehicleId, startMs, endMs, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getVehicleLocations(vehicleId, startMs, endMs, options, optionalCallback);
    }
  }

  /**
   * @summary /industrial/data
   *
   * Fetch all of the data inputs for a group.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<GetAllDataInputsOKResponse>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getAllDataInputsWithHttpOperationResponse(options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getAllDataInputs(options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary /industrial/data
   *
   * Fetch all of the data inputs for a group.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {GetAllDataInputsOKResponse} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link GetAllDataInputsOKResponse} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getAllDataInputs(options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getAllDataInputs(options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getAllDataInputs(options, optionalCallback);
    }
  }

  /**
   * @summary /industrial/data/{data_input_id:[0-9]+}
   *
   * Fetch datapoints from a given data input.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<DataInputHistoryResponse>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getDataInputWithHttpOperationResponse(options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getDataInput(options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary /industrial/data/{data_input_id:[0-9]+}
   *
   * Fetch datapoints from a given data input.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {DataInputHistoryResponse} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link DataInputHistoryResponse} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getDataInput(options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getDataInput(options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getDataInput(options, optionalCallback);
    }
  }

  /**
   * @summary /tags
   *
   * Fetch all of the tags for a group.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<GetAllTagsOKResponse>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getAllTagsWithHttpOperationResponse(options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getAllTags(options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary /tags
   *
   * Fetch all of the tags for a group.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {GetAllTagsOKResponse} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link GetAllTagsOKResponse} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getAllTags(options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getAllTags(options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getAllTags(options, optionalCallback);
    }
  }

  /**
   * @summary /tags
   *
   * Create a new tag for the group.
   *
   * @param {object} tagCreateParams
   *
   * @param {array} [tagCreateParams.assets] The assets that belong to this tag.
   *
   * @param {array} [tagCreateParams.drivers] The drivers that belong to this
   * tag.
   *
   * @param {array} [tagCreateParams.machines] The machines that belong to this
   * tag.
   *
   * @param {string} tagCreateParams.name Name of this tag.
   *
   * @param {number} [tagCreateParams.parentTagId] If this tag is part a
   * hierarchical tag tree as a child tag, the parentTagId is the ID of this
   * tag's parent tag.
   *
   * @param {array} [tagCreateParams.sensors] The sensors that belong to this
   * tag.
   *
   * @param {array} [tagCreateParams.vehicles] The vehicles that belong to this
   * tag.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Tag>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  createTagWithHttpOperationResponse(tagCreateParams, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._createTag(tagCreateParams, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary /tags
   *
   * Create a new tag for the group.
   *
   * @param {object} tagCreateParams
   *
   * @param {array} [tagCreateParams.assets] The assets that belong to this tag.
   *
   * @param {array} [tagCreateParams.drivers] The drivers that belong to this
   * tag.
   *
   * @param {array} [tagCreateParams.machines] The machines that belong to this
   * tag.
   *
   * @param {string} tagCreateParams.name Name of this tag.
   *
   * @param {number} [tagCreateParams.parentTagId] If this tag is part a
   * hierarchical tag tree as a child tag, the parentTagId is the ID of this
   * tag's parent tag.
   *
   * @param {array} [tagCreateParams.sensors] The sensors that belong to this
   * tag.
   *
   * @param {array} [tagCreateParams.vehicles] The vehicles that belong to this
   * tag.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Tag} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Tag} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  createTag(tagCreateParams, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._createTag(tagCreateParams, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._createTag(tagCreateParams, options, optionalCallback);
    }
  }

  /**
   * @summary /tags/{tag_id:[0-9]+}
   *
   * Fetch a tag by id.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Tag>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getTagByIdWithHttpOperationResponse(options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getTagById(options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary /tags/{tag_id:[0-9]+}
   *
   * Fetch a tag by id.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Tag} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Tag} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getTagById(options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getTagById(options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getTagById(options, optionalCallback);
    }
  }

  /**
   * @summary /tags/{tag_id:[0-9]+}
   *
   * Update a tag with a new name and new members. This API call would replace
   * all old members of a tag with new members specified in the request body. To
   * modify only a few devices associated with a tag use the PATCH endpoint.
   *
   * @param {object} updateTagParams
   *
   * @param {array} [updateTagParams.assets] The assets that belong to this tag.
   *
   * @param {array} [updateTagParams.drivers] The drivers that belong to this
   * tag.
   *
   * @param {array} [updateTagParams.machines] The machines that belong to this
   * tag.
   *
   * @param {string} [updateTagParams.name] Updated name of this tag.
   *
   * @param {number} [updateTagParams.parentTagId] If this tag is part a
   * hierarchical tag tree as a child tag, the parentTagId is the ID of this
   * tag's parent tag.
   *
   * @param {array} [updateTagParams.sensors] The sensors that belong to this
   * tag.
   *
   * @param {array} [updateTagParams.vehicles] The vehicles that belong to this
   * tag.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Tag>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  updateTagByIdWithHttpOperationResponse(updateTagParams, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._updateTagById(updateTagParams, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary /tags/{tag_id:[0-9]+}
   *
   * Update a tag with a new name and new members. This API call would replace
   * all old members of a tag with new members specified in the request body. To
   * modify only a few devices associated with a tag use the PATCH endpoint.
   *
   * @param {object} updateTagParams
   *
   * @param {array} [updateTagParams.assets] The assets that belong to this tag.
   *
   * @param {array} [updateTagParams.drivers] The drivers that belong to this
   * tag.
   *
   * @param {array} [updateTagParams.machines] The machines that belong to this
   * tag.
   *
   * @param {string} [updateTagParams.name] Updated name of this tag.
   *
   * @param {number} [updateTagParams.parentTagId] If this tag is part a
   * hierarchical tag tree as a child tag, the parentTagId is the ID of this
   * tag's parent tag.
   *
   * @param {array} [updateTagParams.sensors] The sensors that belong to this
   * tag.
   *
   * @param {array} [updateTagParams.vehicles] The vehicles that belong to this
   * tag.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Tag} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Tag} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  updateTagById(updateTagParams, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._updateTagById(updateTagParams, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._updateTagById(updateTagParams, options, optionalCallback);
    }
  }

  /**
   * @summary /tags/{tag_id:[0-9]+}
   *
   * Permanently deletes a tag.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deleteTagByIdWithHttpOperationResponse(options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deleteTagById(options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary /tags/{tag_id:[0-9]+}
   *
   * Permanently deletes a tag.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteTagById(options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deleteTagById(options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deleteTagById(options, optionalCallback);
    }
  }

  /**
   * @summary /tags/{tag_id:[0-9]+}
   *
   * Add or delete specific members from a tag, or modify the name of a tag.
   *
   * @param {object} tagModifyParams
   *
   * @param {object} [tagModifyParams.add] Specify devices, etc. that should be
   * added to the tag.
   *
   * @param {array} [tagModifyParams.add.assets] The assets to be added to this
   * tag.
   *
   * @param {array} [tagModifyParams.add.drivers] The drivers to be added to this
   * tag.
   *
   * @param {array} [tagModifyParams.add.machines] The machines to be added to
   * this tag.
   *
   * @param {array} [tagModifyParams.add.sensors] The sensors to be added to this
   * tag.
   *
   * @param {array} [tagModifyParams.add.vehicles] The vehicles to be added to
   * this tag.
   *
   * @param {object} [tagModifyParams.deleteProperty] Specify devices, etc. that
   * should be removed from the tag.
   *
   * @param {array} [tagModifyParams.deleteProperty.assets] The assets to be
   * removed from this tag.
   *
   * @param {array} [tagModifyParams.deleteProperty.drivers] The drivers to be
   * removed from this tag.
   *
   * @param {array} [tagModifyParams.deleteProperty.machines] The machines to be
   * removed from this tag.
   *
   * @param {array} [tagModifyParams.deleteProperty.sensors] The sensors to be
   * removed from this tag.
   *
   * @param {array} [tagModifyParams.deleteProperty.vehicles] The vehicles to be
   * removed from this tag.
   *
   * @param {string} [tagModifyParams.name] Updated name of this tag.
   *
   * @param {number} [tagModifyParams.parentTagId] If this tag is part a
   * hierarchical tag tree as a child tag, the parentTagId is the ID of this
   * tag's parent tag.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Tag>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  modifyTagByIdWithHttpOperationResponse(tagModifyParams, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._modifyTagById(tagModifyParams, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary /tags/{tag_id:[0-9]+}
   *
   * Add or delete specific members from a tag, or modify the name of a tag.
   *
   * @param {object} tagModifyParams
   *
   * @param {object} [tagModifyParams.add] Specify devices, etc. that should be
   * added to the tag.
   *
   * @param {array} [tagModifyParams.add.assets] The assets to be added to this
   * tag.
   *
   * @param {array} [tagModifyParams.add.drivers] The drivers to be added to this
   * tag.
   *
   * @param {array} [tagModifyParams.add.machines] The machines to be added to
   * this tag.
   *
   * @param {array} [tagModifyParams.add.sensors] The sensors to be added to this
   * tag.
   *
   * @param {array} [tagModifyParams.add.vehicles] The vehicles to be added to
   * this tag.
   *
   * @param {object} [tagModifyParams.deleteProperty] Specify devices, etc. that
   * should be removed from the tag.
   *
   * @param {array} [tagModifyParams.deleteProperty.assets] The assets to be
   * removed from this tag.
   *
   * @param {array} [tagModifyParams.deleteProperty.drivers] The drivers to be
   * removed from this tag.
   *
   * @param {array} [tagModifyParams.deleteProperty.machines] The machines to be
   * removed from this tag.
   *
   * @param {array} [tagModifyParams.deleteProperty.sensors] The sensors to be
   * removed from this tag.
   *
   * @param {array} [tagModifyParams.deleteProperty.vehicles] The vehicles to be
   * removed from this tag.
   *
   * @param {string} [tagModifyParams.name] Updated name of this tag.
   *
   * @param {number} [tagModifyParams.parentTagId] If this tag is part a
   * hierarchical tag tree as a child tag, the parentTagId is the ID of this
   * tag's parent tag.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Tag} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Tag} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  modifyTagById(tagModifyParams, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._modifyTagById(tagModifyParams, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._modifyTagById(tagModifyParams, options, optionalCallback);
    }
  }

  /**
   * @summary /user_roles
   *
   * Get all roles in the organization.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listUserRolesWithHttpOperationResponse(options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listUserRoles(options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary /user_roles
   *
   * Get all roles in the organization.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listUserRoles(options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listUserRoles(options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listUserRoles(options, optionalCallback);
    }
  }

  /**
   * @summary /users/{userId:[0-9]+}
   *
   * Get a user.
   *
   * @param {number} userId ID of the user.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<User>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getUserByIdWithHttpOperationResponse(userId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getUserById(userId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary /users/{userId:[0-9]+}
   *
   * Get a user.
   *
   * @param {number} userId ID of the user.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {User} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link User} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getUserById(userId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getUserById(userId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getUserById(userId, options, optionalCallback);
    }
  }

  /**
   * @summary /users/{userId:[0-9]+}
   *
   * Remove a user from the organization.
   *
   * @param {number} userId ID of the user.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deleteUserByIdWithHttpOperationResponse(userId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deleteUserById(userId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary /users/{userId:[0-9]+}
   *
   * Remove a user from the organization.
   *
   * @param {number} userId ID of the user.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteUserById(userId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deleteUserById(userId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deleteUserById(userId, options, optionalCallback);
    }
  }

}

module.exports = SamsaraAPI;
module.exports['default'] = SamsaraAPI;
module.exports.SamsaraAPI = SamsaraAPI;
module.exports.SamsaraAPIModels = models;
