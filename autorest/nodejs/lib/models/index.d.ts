/*
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */

import * as moment from "moment";

/**
 * Information about a notification contact for alerts.
 */
export interface Contact {
  /**
   * Email address of the contact
   */
  email?: string;
  /**
   * First name of the contact
   */
  firstName?: string;
  /**
   * ID of the contact
   */
  id?: number;
  /**
   * Last name of the contact
   */
  lastName?: string;
  /**
   * Phone number of the contact
   */
  phone?: string;
}

/**
 * Information about a circular geofence. This field is only populated if the geofence is a circle.
 */
export interface AddressGeofenceCircle {
  /**
   * The latitude of the center of the circular geofence
   */
  latitude?: number;
  /**
   * The longitude of the center of the circular geofence
   */
  longitude?: number;
  /**
   * The radius of the circular geofence
   */
  radiusMeters?: number;
}

export interface AddressGeofencePolygonVerticesItem {
  /**
   * The longitude of a geofence vertex
  */
  latitude?: number;
  /**
   * The longitude of a geofence vertex
  */
  longitude?: number;
}

/**
 * Information about a polygon geofence. This field is only populated if the geofence is a polygon.
*/
export interface AddressGeofencePolygon {
  /**
   * The vertices of the polygon geofence. These geofence vertices describe the perimeter of the
   * polygon, and must consist of at least 3 vertices and less than 40.
  */
  vertices?: AddressGeofencePolygonVerticesItem[];
}

/**
 * The geofence that defines this address and its bounds. This can either be a circle, or a polygon
 * - only one key should be provided, depending on the geofence type.
*/
export interface AddressGeofence {
  /**
   * Information about a circular geofence. This field is only populated if the geofence is a
   * circle.
  */
  circle?: AddressGeofenceCircle;
  /**
   * Information about a polygon geofence. This field is only populated if the geofence is a
   * polygon.
  */
  polygon?: AddressGeofencePolygon;
}

export interface TagMetadata {
  /**
   * The ID of this tag.
  */
  id: number;
  /**
   * Name of this tag.
  */
  name: string;
}

/**
 * Information about an address/geofence. Geofences are either a circle or a polygon.
*/
export interface Address {
  contacts?: Contact[];
  /**
   * The full address associated with this address/geofence, as it might be recognized by
   * maps.google.com
  */
  formattedAddress?: string;
  geofence?: AddressGeofence;
  /**
   * ID of the address
  */
  id?: number;
  /**
   * Name of the address or geofence
  */
  name?: string;
  notes?: string;
  tags?: TagMetadata[];
}

export interface AssetCableItem {
  /**
   * Asset type
  */
  assetType?: string;
}

/**
 * Basic information of an asset
*/
export interface Asset {
  /**
   * Serial number of the host asset
  */
  assetSerialNumber?: string;
  /**
   * The cable connected to the asset
  */
  cable?: AssetCableItem[];
  /**
   * Engine hours
  */
  engineHours?: number;
  /**
   * Asset ID
  */
  id: number;
  /**
   * Asset name
  */
  name?: string;
}

/**
 * Current location of an asset
*/
export interface AssetCurrentLocation {
  /**
   * The latitude of the location in degrees.
  */
  latitude?: number;
  /**
   * The best effort (street,city,state) for the latitude and longitude.
  */
  location?: string;
  /**
   * The longitude of the location in degrees.
  */
  longitude?: number;
  /**
   * The speed calculated from GPS that the asset was traveling at in miles per hour.
  */
  speedMilesPerHour?: number;
  /**
   * Time in Unix milliseconds since epoch when the asset was at the location.
  */
  timeMs?: number;
}

export interface AssetCurrentLocationsResponseCableItem {
  /**
   * Asset type
  */
  assetType?: string;
}

/**
 * Basic information of an asset
*/
export interface AssetCurrentLocationsResponse {
  /**
   * The cable connected to the asset
  */
  cable?: AssetCurrentLocationsResponseCableItem[];
  /**
   * Engine hours
  */
  engineHours?: number;
  /**
   * Asset ID
  */
  id: number;
  /**
   * Current location of an asset
  */
  location?: AssetCurrentLocation[];
  /**
   * Asset name
  */
  name?: string;
}

/**
 * Asset location details.
*/
export interface AssetLocationResponseItem {
  /**
   * The latitude of the location in degrees.
  */
  latitude?: number;
  /**
   * The best effort (street,city,state) for the latitude and longitude.
  */
  location?: string;
  /**
   * The longitude of the location in degrees.
  */
  longitude?: number;
  /**
   * The speed calculated from GPS that the asset was traveling at in miles per hour.
  */
  speedMilesPerHour?: number;
  /**
   * Time in Unix milliseconds since epoch when the asset was at the location.
  */
  time?: number;
}

export interface AssetReeferResponseReeferStatsAlarmsItemAlarmsItem {
  /**
   * ID of the alarm
  */
  alarmCode?: number;
  /**
   * Description of the alarm
  */
  description?: string;
  /**
   * Recommended operator action
  */
  operatorAction?: string;
  /**
   * Severity of the alarm: 1: OK to run, 2: Check as specified, 3: Take immediate action
  */
  severity?: number;
}

export interface AssetReeferResponseReeferStatsAlarmsItem {
  alarms?: AssetReeferResponseReeferStatsAlarmsItemAlarmsItem[];
  /**
   * Timestamp when the alarms were reported, in Unix milliseconds since epoch
  */
  changedAtMs?: number;
}

export interface AssetReeferResponseReeferStatsEngineHoursItem {
  /**
   * Timestamp in Unix milliseconds since epoch.
  */
  changedAtMs?: number;
  /**
   * Engine hours of the reefer.
  */
  engineHours?: number;
}

export interface AssetReeferResponseReeferStatsFuelPercentageItem {
  /**
   * Timestamp in Unix milliseconds since epoch.
  */
  changedAtMs?: number;
  /**
   * Fuel percentage of the reefer.
  */
  fuelPercentage?: number;
}

export interface AssetReeferResponseReeferStatsPowerStatusItem {
  /**
   * Timestamp in Unix milliseconds since epoch.
  */
  changedAtMs?: number;
  /**
   * Power status of the reefer.
  */
  status?: string;
}

export interface AssetReeferResponseReeferStatsReturnAirTempItem {
  /**
   * Timestamp in Unix milliseconds since epoch.
  */
  changedAtMs?: number;
  /**
   * Return air temperature in millidegree Celsius.
  */
  tempInMilliC?: number;
}

export interface AssetReeferResponseReeferStatsSetPointItem {
  /**
   * Timestamp in Unix milliseconds since epoch.
  */
  changedAtMs?: number;
  /**
   * Set point temperature in millidegree Celsius.
  */
  tempInMilliC?: number;
}

export interface AssetReeferResponseReeferStats {
  /**
   * Reefer alarms
  */
  alarms?: AssetReeferResponseReeferStatsAlarmsItem[];
  /**
   * Engine hours of the reefer
  */
  engineHours?: AssetReeferResponseReeferStatsEngineHoursItem[];
  /**
   * Fuel percentage of the reefer
  */
  fuelPercentage?: AssetReeferResponseReeferStatsFuelPercentageItem[];
  /**
   * Power status of the reefer
  */
  powerStatus?: AssetReeferResponseReeferStatsPowerStatusItem[];
  /**
   * Return air temperature of the reefer
  */
  returnAirTemp?: AssetReeferResponseReeferStatsReturnAirTempItem[];
  /**
   * Set point temperature of the reefer
  */
  setPoint?: AssetReeferResponseReeferStatsSetPointItem[];
}

/**
 * Reefer-specific asset details
*/
export interface AssetReeferResponse {
  /**
   * Asset type
  */
  assetType?: string;
  /**
   * Asset ID
  */
  id?: number;
  /**
   * Asset name
  */
  name?: string;
  reeferStats?: AssetReeferResponseReeferStats;
}

/**
 * Digital value of an aux input.
*/
export interface AuxInput {
  /**
   * Timestamp in Unix epoch milliseconds.
  */
  timeMs: number;
  /**
   * Boolean representing the digital value of the aux input.
  */
  value: boolean;
}

/**
 * A list of aux input values over a timerange.
*/
export interface AuxInputSeries {
  /**
   * The name of the aux input. Possible values include: 'Emergency Lights', 'Emergency Alarm',
   * 'Stop Paddle', 'Power Take-Off', 'Plow', 'Sweeper', 'Salter', 'Boom'
  */
  name: string;
  values: AuxInput[];
}

export interface CargoResponseSensorsItem {
  /**
   * Flag indicating whether the current cargo is empty or loaded.
  */
  cargoEmpty?: boolean;
  /**
   * ID of the sensor.
  */
  id?: number;
  /**
   * Name of the sensor.
  */
  name?: string;
}

/**
 * Contains the current cargo status of a sensor.
*/
export interface CargoResponse {
  groupId?: number;
  sensors?: CargoResponseSensorsItem[];
}

export interface DriverBase {
  /**
   * Flag indicating this driver may use Adverse Weather exemptions in ELD logs.
  */
  eldAdverseWeatherExemptionEnabled?: boolean;
  /**
   * Flag indicating this driver may use Big Day excemptions in ELD logs.
  */
  eldBigDayExemptionEnabled?: boolean;
  /**
   * 0 indicating midnight-to-midnight ELD driving hours, 12 to indicate noon-to-noon driving
   * hours.
  */
  eldDayStartHour?: number;
  /**
   * Flag indicating this driver is exempt from the Electronic Logging Mandate.
  */
  eldExempt?: boolean;
  /**
   * Reason that this driver is exempt from the Electronic Logging Mandate (see eldExempt).
  */
  eldExemptReason?: string;
  /**
   * Flag indicating this driver may select the Personal Conveyance duty status in ELD logs.
  */
  eldPcEnabled?: boolean;
  /**
   * Flag indicating this driver may select the Yard Move duty status in ELD logs.
  */
  eldYmEnabled?: boolean;
  /**
   * Dictionary of external IDs (string key-value pairs)
  */
  externalIds?: { [propertyName: string]: string };
  /**
   * ID of the group if the organization has multiple groups (uncommon).
  */
  groupId?: number;
  /**
   * Driver's state issued license number.
  */
  licenseNumber?: string;
  /**
   * Abbreviation of state that issued driver's license.
  */
  licenseState?: string;
  /**
   * Driver's name.
  */
  name: string;
  /**
   * Notes about the driver.
  */
  notes?: string;
  /**
   * Driver's phone number. Please include only digits, ex. 4157771234
  */
  phone?: string;
  /**
   * Driver's login username into the driver app.
  */
  username?: string;
  /**
   * ID of the vehicle assigned to the driver for static vehicle assignments. (uncommon).
  */
  vehicleId?: number;
}

export interface CurrentDriver extends DriverBase {
  /**
   * ID of the driver.
  */
  id: number;
  /**
   * True if the driver account has been deactivated.
  */
  isDeactivated?: boolean;
  tags?: TagMetadata[];
  /**
   * ID of the vehicle that this driver is currently assigned to. Omitted if there is no current
   * vehicle assignment for this driver.
  */
  currentVehicleId?: number;
}

export interface DataInputHistoryResponsePointsItem {
  timeMs?: number;
  value?: number;
}

export interface DataInputHistoryResponse {
  /**
   * The ID of this data input
  */
  id?: number;
  /**
   * Name of this data input
  */
  name: string;
  /**
   * Data points from this data input
  */
  points?: DataInputHistoryResponsePointsItem[];
}

export interface DispatchJobCreate {
  /**
   * The address of the job destination, as it would be recognized if provided to maps.google.com.
   * Optional if a valid destination address ID is provided.
  */
  destinationAddress?: string;
  /**
   * ID of the job destination associated with an address book entry. Optional if valid values are
   * provided for destination address or latitude/longitude. If a valid destination address ID is
   * provided, address/latitude/longitude will be used from the address book entry. Name of the
   * address book entry will only be used if the destination name is not provided.
  */
  destinationAddressId?: number;
  /**
   * Latitude of the destination in decimal degrees. Optional if a valid destination address ID is
   * provided.
  */
  destinationLat?: number;
  /**
   * Longitude of the destination in decimal degrees. Optional if a valid destination address ID is
   * provided.
  */
  destinationLng?: number;
  /**
   * The name of the job destination. If provided, it will take precedence over the name of the
   * address book entry.
  */
  destinationName?: string;
  /**
   * Notes regarding the details of this job.
  */
  notes?: string;
  /**
   * The time at which the assigned driver is scheduled to arrive at the job destination.
  */
  scheduledArrivalTimeMs: number;
  /**
   * The time at which the assigned driver is scheduled to depart from the job destination.
  */
  scheduledDepartureTimeMs?: number;
}

export interface DispatchJob extends DispatchJobCreate {
  /**
   * The time at which the driver arrived at the job destination.
  */
  arrivedAtMs?: number;
  /**
   * The time at which the job was marked complete (e.g. started driving to the next destination).
  */
  completedAtMs?: number;
  /**
   * ID of the route that this job belongs to.
  */
  dispatchRouteId: number;
  /**
   * ID of the driver assigned to the dispatch job.
  */
  driverId?: number;
  /**
   * The time at which the assigned driver started fulfilling the job (e.g. started driving to the
   * destination).
  */
  enRouteAtMs?: number;
  /**
   * The time at which the assigned driver is estimated to arrive at the job destination. Only
   * valid for en-route jobs.
  */
  estimatedArrivalMs?: number;
  /**
   * Fleet viewer url of the dispatch job.
  */
  fleetViewerUrl?: string;
  groupId: number;
  /**
   * ID of the Samsara dispatch job.
  */
  id: number;
  /**
   * Possible values include: 'JobState_Unassigned', 'JobState_Scheduled', 'JobState_EnRoute',
   * 'JobState_Arrived', 'JobState_Completed', 'JobState_Skipped'
  */
  jobState: string;
  /**
   * The time at which the job was marked skipped.
  */
  skippedAtMs?: number;
  /**
   * ID of the vehicle used for the dispatch job.
  */
  vehicleId?: number;
}

export interface DispatchRouteBase {
  /**
   * The time in Unix epoch milliseconds that the route actually ended.
  */
  actualEndMs?: number;
  /**
   * The time in Unix epoch milliseconds that the route actually started.
  */
  actualStartMs?: number;
  /**
   * ID of the driver assigned to the dispatch route. Note that driver_id and vehicle_id are
   * mutually exclusive. If neither is specified, then the route is unassigned.
  */
  driverId?: number;
  /**
   * ID of the group if the organization has multiple groups (optional).
  */
  groupId?: number;
  /**
   * Descriptive name of this route.
  */
  name: string;
  /**
   * The time in Unix epoch milliseconds that the last job in the route is scheduled to end.
  */
  scheduledEndMs: number;
  /**
   * The distance expected to be traveled for this route in meters.
  */
  scheduledMeters?: number;
  /**
   * The time in Unix epoch milliseconds that the route is scheduled to start.
  */
  scheduledStartMs: number;
  /**
   * The address of the route's starting location, as it would be recognized if provided to
   * maps.google.com. Optional if a valid start location address ID is provided.
  */
  startLocationAddress?: string;
  /**
   * ID of the start location associated with an address book entry. Optional if valid values are
   * provided for start location address or latitude/longitude. If a valid start location address
   * ID is provided, address/latitude/longitude will be used from the address book entry. Name of
   * the address book entry will only be used if the start location name is not provided.
  */
  startLocationAddressId?: number;
  /**
   * Latitude of the start location in decimal degrees. Optional if a valid start location address
   * ID is provided.
  */
  startLocationLat?: number;
  /**
   * Longitude of the start location in decimal degrees. Optional if a valid start location address
   * ID is provided.
  */
  startLocationLng?: number;
  /**
   * The name of the route's starting location. If provided, it will take precedence over the name
   * of the address book entry.
  */
  startLocationName?: string;
  /**
   * ID of the trailer assigned to the dispatch route. Note that trailers can only be assigned to
   * routes that have a Vehicle or Driver assigned to them.
  */
  trailerId?: number;
  /**
   * ID of the vehicle assigned to the dispatch route. Note that vehicle_id and driver_id are
   * mutually exclusive. If neither is specified, then the route is unassigned.
  */
  vehicleId?: number;
}

export interface DispatchRoute extends DispatchRouteBase {
  /**
   * The dispatch jobs associated with this route.
  */
  dispatchJobs: DispatchJob[];
  /**
   * ID of the Samsara dispatch route.
  */
  id: number;
}

export interface DispatchRouteCreate extends DispatchRouteBase {
  /**
   * The dispatch jobs to create for this route.
  */
  dispatchJobs: DispatchJobCreate[];
}

export interface DispatchRouteHistoricalEntry {
  /**
   * Timestamp that the route was updated, represented as Unix milliseconds since epoch.
  */
  changedAtMs?: number;
  route?: DispatchRoute;
}

export interface DispatchRouteHistory {
  /**
   * History of the route's state changes.
  */
  history?: DispatchRouteHistoricalEntry[];
}

export interface DocumentFieldCreate {
  /**
   * Value of this field if this document field has valueType: ValueType_Number.
  */
  numberValue?: number;
  /**
   * Value of this field if this document field has valueType: ValueType_Photo. Array of photo
   * objects where each object contains a URL for a photo.
  */
  photoValue?: DocumentFieldCreatePhotoValueItem[];
  /**
   * Value of this field if this document field has valueType: ValueType_String.
  */
  stringValue?: string;
  /**
   * Determines the type of this field and what type of value this field has. It should be either
   * ValueType_Number, ValueType_String, or ValueType_Photo.
  */
  valueType: string;
}

export interface DocumentField extends DocumentFieldCreate {
  /**
   * Descriptive name of this field.
  */
  label: string;
  /**
   * DEPRECATED: Please use stringValue, numberValue, or photoValue instead. Value of this field.
   * Depending on what kind of field it is, this may be one of the following: an array of image
   * urls, a float, an integer, or a string.
  */
  value?: any;
}

export interface DocumentBase {
  /**
   * ID of the Samsara dispatch job for which the document is submitted
  */
  dispatchJobId?: number;
  /**
   * Notes submitted with this document.
  */
  notes?: string;
}

export interface Document extends DocumentBase {
  /**
   * Descriptive name of this type of document.
  */
  documentType: string;
  /**
   * The time in Unix epoch milliseconds that the document is created.
  */
  driverCreatedAtMs: number;
  /**
   * ID of the driver for whom the document is submitted
  */
  driverId: number;
  /**
   * The fields associated with this document.
  */
  fields: DocumentField[];
  /**
   * VehicleID of the driver at document creation.
  */
  vehicleId?: number;
}

export interface DocumentCreate extends DocumentBase {
  /**
   * Universally unique identifier for the document type this document is being created for.
  */
  documentTypeUuid: string;
  /**
   * List of fields should match the document type’s list of field types in the correct order. In
   * other words, a field's valueType and value (i.e. only one of: stringValue, numberValue, or
   * photoValue) at index _i_ should match with the document field type’s valueType at index _i_.
  */
  fields: DocumentField[];
}

export interface DocumentFieldCreatePhotoValueItem {
  /**
   * Photo URL for a JPG image
  */
  url?: string;
}

/**
 * Additional metadata information for a number field type. Only defined when a field type has
 * valueType: ValueType_Number.
*/
export interface DocumentFieldTypeNumberValueTypeMetadata {
  /**
   * Number of decimal places that values for this field type can have.
  */
  numDecimalPlaces?: number;
}

export interface DocumentFieldType {
  /**
   * Descriptive name of this field type.
  */
  label: string;
  /**
   * Additional metadata information for a number field type. Only defined when a field type has
   * valueType: ValueType_Number.
  */
  numberValueTypeMetadata?: DocumentFieldTypeNumberValueTypeMetadata;
  /**
   * The kind of value that can be submitted for this fieldType. It should be either
   * ValueType_Number, ValueType_String, or ValueType_Photo.
  */
  valueType: string;
}

export interface DocumentType {
  /**
   * The field types determine the names of fields for this document type. They also determine the
   * types of values a document submitted for this document type can have.
  */
  fieldTypes?: DocumentFieldType[][];
  /**
   * Name of the document type.
  */
  name: string;
  /**
   * ID for the organization this document belongs to.
  */
  orgId: number;
  /**
   * Universally unique identifier for the document type. Can be passed in as a documentTypeUuid
   * when creating a document for this document type.
  */
  uuid: string;
}

export interface DoorResponseSensorsItem {
  /**
   * Flag indicating whether the current door is closed or open.
  */
  doorClosed?: boolean;
  /**
   * ID of the sensor.
  */
  id?: number;
  /**
   * Name of the sensor.
  */
  name?: string;
}

/**
 * Contains the current door status of a sensor.
*/
export interface DoorResponse {
  groupId?: number;
  sensors?: DoorResponseSensorsItem[];
}

export interface DriverDailyLogResponseDaysItem {
  /**
   * Hours spent on duty or driving, rounded to two decimal places.
  */
  activeHours?: number;
  /**
   * Milliseconds spent on duty or driving.
  */
  activeMs?: number;
  /**
   * Whether this HOS day chart was certified by the driver.
  */
  certified?: boolean;
  /**
   * Unix epoch time (in ms) of time when this chart was certified. If this chart is uncertified,
   * 0.
  */
  certifiedAtMs?: number;
  /**
   * Distance driven in miles, rounded to two decimal places.
  */
  distanceMiles?: number;
  /**
   * End of the HOS day, specified in milliseconds UNIX time.
  */
  endMs?: number;
  /**
   * End of the HOS day, specified in milliseconds UNIX time.
  */
  startMs?: number;
  /**
   * List of trailer ID's associated with the driver for the day.
  */
  trailerIds?: any;
  /**
   * List of vehicle ID's associated with the driver for the day.
  */
  vehicleIds?: any;
}

export interface DriverDailyLogResponse {
  days?: DriverDailyLogResponseDaysItem[];
}

export interface DriverForCreate extends DriverBase {
  /**
   * Driver's password for the driver app.
  */
  password: string;
  tagIds?: number[];
}

/**
 * List of harsh events
*/
export interface SafetyReportHarshEvent {
  /**
   * Type of the harsh event
  */
  harshEventType?: string;
  /**
   * Timestamp that the harsh event occurred in Unix milliseconds since epoch
  */
  timestampMs?: number;
  /**
   * Vehicle associated with the harsh event
  */
  vehicleId?: number;
}

/**
 * Safety score details for a driver
*/
export interface DriverSafetyScoreResponse {
  /**
   * Crash event count
  */
  crashCount?: number;
  /**
   * Driver ID
  */
  driverId?: number;
  /**
   * Harsh acceleration event count
  */
  harshAccelCount?: number;
  /**
   * Harsh braking event count
  */
  harshBrakingCount?: number;
  harshEvents?: SafetyReportHarshEvent[];
  /**
   * Harsh turning event count
  */
  harshTurningCount?: number;
  /**
   * Safety Score
  */
  safetyScore?: number;
  /**
   * Safety Score Rank
  */
  safetyScoreRank?: string;
  /**
   * Amount of time driven over the speed limit in milliseconds
  */
  timeOverSpeedLimitMs?: number;
  /**
   * Total distance driven in meters
  */
  totalDistanceDrivenMeters?: number;
  /**
   * Total harsh event count
  */
  totalHarshEventCount?: number;
  /**
   * Amount of time driven in milliseconds
  */
  totalTimeDrivenMs?: number;
}

export interface DriversResponse {
  drivers?: CurrentDriver[];
}

export interface DriversSummaryResponseSummariesItem {
  /**
   * Duration in milliseconds that driver was on duty or driving during the requested time range
  */
  activeMs?: number;
  /**
   * Distance driven in miles, rounded to two decimal places.
  */
  distanceMiles?: number;
  /**
   * Duration in milliseconds that driver was driving during the requested time range
  */
  driveMs?: number;
  /**
   * ID of the driver.
  */
  driverId?: number;
  /**
   * Name of the driver.
  */
  driverName?: string;
  /**
   * Username of the driver.
  */
  driverUsername?: string;
  /**
   * Group of the driver.
  */
  groupId?: number;
  /**
   * Duration in milliseconds that driver was on duty during the requested time range
  */
  onDutyMs?: number;
}

export interface DriversSummaryResponse {
  summaries?: DriversSummaryResponseSummariesItem[];
}

/**
 * The authors signature for the DVIR.
*/
export interface DvirBaseAuthorSignature {
  /**
   * ID of the driver who signed the DVIR. Will not be returned if mechanicUserId is returned.
  */
  driverId?: number;
  /**
   * Email of the  driver|mechanic who signed the DVIR.
  */
  email?: string;
  /**
   * ID of the mechanic who signed the DVIR. Will not be returned if driverId is returned.
  */
  mechanicUserId?: number;
  /**
   * The name of the driver or mechanic who signed the DVIR.
  */
  name?: string;
  /**
   * The time in millis when the DVIR was signed
  */
  signedAt?: number;
  /**
   * Type corresponds to whether the signature corresponds to driver|mechanic.
  */
  type?: string;
  /**
   * Username of the  driver|mechanic who signed the DVIR.
  */
  username?: string;
}

/**
 * The mechanic's or agent's signature for the DVIR.
*/
export interface DvirBaseMechanicOrAgentSignature {
  /**
   * ID of the driver who signed the DVIR. Will not be returned if mechanicUserId is returned.
  */
  driverId?: number;
  /**
   * Email of the  agent|mechanic who signed the DVIR.
  */
  email?: string;
  /**
   * ID of the mechanic who signed the DVIR. Will not be returned if driverId is returned.
  */
  mechanicUserId?: number;
  /**
   * The name of the agent or mechanic who signed the DVIR.
  */
  name?: string;
  /**
   * The time in millis when the DVIR was signed
  */
  signedAt?: number;
  /**
   * Type corresponds to whether the signature corresponds to driver|mechanic.
  */
  type?: string;
  /**
   * Username of the  agent|mechanic who signed the DVIR.
  */
  username?: string;
}

/**
 * The next driver signature for the DVIR.
*/
export interface DvirBaseNextDriverSignature {
  /**
   * ID of the driver who signed the DVIR
  */
  driverId?: number;
  /**
   * Email of the  driver who signed the next DVIR on this vehicle.
  */
  email?: string;
  /**
   * The name of the driver who signed the next DVIR on this vehicle.
  */
  name?: string;
  /**
   * The time in millis when the next driver signed the DVIR on this vehicle.
  */
  signedAt?: number;
  /**
   * Type corresponds to driver.
  */
  type?: string;
  /**
   * Username of the  driver who signed the next DVIR on this vehicle.
  */
  username?: string;
}

export interface DvirBaseTrailerDefectsItem {
  /**
   * The comment describing the type of DVIR defect
  */
  comment?: string;
  /**
   * The type of DVIR defect
  */
  defectType?: string;
}

/**
 * The vehicle on which DVIR was done.
*/
export interface DvirBaseVehicle {
  /**
   * The vehicle id on which DVIR was done.
  */
  id?: number;
  /**
   * The vehicle on which DVIR was done.
  */
  name?: string;
}

export interface DvirBaseVehicleDefectsItem {
  /**
   * The comment describing the type of DVIR defect
  */
  comment?: string;
  /**
   * The type of DVIR defect
  */
  defectType?: string;
}

export interface DvirBase {
  /**
   * The authors signature for the DVIR.
  */
  authorSignature?: DvirBaseAuthorSignature;
  /**
   * Signifies if the defects on the vehicle corrected after the DVIR is done.
  */
  defectsCorrected?: boolean;
  /**
   * Signifies if the defects on this vehicle can be ignored.
  */
  defectsNeedNotBeCorrected?: boolean;
  /**
   * The id of this DVIR record.
  */
  id?: number;
  /**
   * Inspection type of the DVIR.
  */
  inspectionType?: string;
  /**
   * The mechanics notes on the DVIR.
  */
  mechanicNotes?: string;
  /**
   * The mechanic's or agent's signature for the DVIR.
  */
  mechanicOrAgentSignature?: DvirBaseMechanicOrAgentSignature;
  /**
   * The next driver signature for the DVIR.
  */
  nextDriverSignature?: DvirBaseNextDriverSignature;
  /**
   * The odometer reading in miles for the vehicle when the DVIR was done.
  */
  odometerMiles?: number;
  /**
   * Timestamp of this DVIR in UNIX milliseconds.
  */
  timeMs?: number;
  /**
   * Defects registered for the trailer which was part of the DVIR.
  */
  trailerDefects?: DvirBaseTrailerDefectsItem[];
  /**
   * The id of the trailer which was part of the DVIR.
  */
  trailerId?: number;
  /**
   * The name of the trailer which was part of the DVIR.
  */
  trailerName?: string;
  /**
   * The vehicle on which DVIR was done.
  */
  vehicle?: DvirBaseVehicle;
  /**
   * The condition of vechile on which DVIR was done.
  */
  vehicleCondition?: string;
  /**
   * Defects registered for the vehicle which was part of the DVIR.
  */
  vehicleDefects?: DvirBaseVehicleDefectsItem[];
}

export interface DvirListResponse {
  dvirs?: DvirBase[];
}

/**
 * The state of the vehicle over time. State can be Running, Off, or Idle.
*/
export interface EngineState {
  /**
   * Timestamp in Unix epoch milliseconds.
  */
  timeMs: number;
  /**
   * Possible values include: 'Running', 'Off', 'Idle'
  */
  value: string;
}

/**
 * Contains the location and speed of a vehicle at a particular time
*/
export interface FleetVehicleLocation {
  /**
   * The latitude of the location in degrees.
  */
  latitude?: number;
  /**
   * The best effort (street,city,state) for the latitude and longitude.
  */
  location?: string;
  /**
   * The longitude of the location in degrees.
  */
  longitude?: number;
  /**
   * The speed calculated from GPS that the asset was traveling at in miles per hour.
  */
  speedMilesPerHour?: number;
  /**
   * Time in Unix milliseconds since epoch when the asset was at the location.
  */
  timeMs?: number;
}

export interface FleetVehicleResponseVehicleInfo {
  /**
   * Make of the vehicle.
  */
  make?: string;
  /**
   * Model of the Vehicle.
  */
  model?: string;
  /**
   * Vehicle Identification Number.
  */
  vin?: string;
  /**
   * Year of the vehicle.
  */
  year?: number;
}

/**
 * A vehicle object as returned for fleet/vehicle
*/
export interface FleetVehicleResponse {
  externalIds?: { [propertyName: string]: string };
  /**
   * Harsh event detection setting.
  */
  harshAccelSetting?: string;
  /**
   * ID of the vehicle.
  */
  id: number;
  /**
   * Name of the vehicle.
  */
  name: string;
  vehicleInfo?: FleetVehicleResponseVehicleInfo;
}

export interface FleetVehiclesLocationsItem {
  /**
   * ID of the vehicle.
  */
  id?: number;
  locations?: FleetVehicleLocation[];
  /**
   * Name of the vehicle.
  */
  name?: string;
}

export interface HosAuthenticationLogsResponseAuthenticationLogsItem {
  /**
   * The log type - one of 'signin' or 'signout'
  */
  actionType?: string;
  /**
   * Address at which the log was recorded, if applicable.
  */
  address?: string;
  /**
   * Address name from the group address book at which the log was recorded, if applicable.
  */
  addressName?: string;
  /**
   * City in which the log was recorded, if applicable.
  */
  city?: string;
  /**
   * The time at which the event was recorded in UNIX milliseconds.
  */
  happenedAtMs?: number;
  /**
   * State in which the log was recorded, if applicable.
  */
  state?: string;
}

export interface HosAuthenticationLogsResponse {
  authenticationLogs?: HosAuthenticationLogsResponseAuthenticationLogsItem[];
}

export interface HosLogsResponseLogsItem {
  codriverIds?: number[];
  /**
   * ID of the driver.
  */
  driverId?: number;
  /**
   * ID of the group.
  */
  groupId?: number;
  /**
   * City in which the log was recorded.
  */
  locCity?: string;
  /**
   * Latitude at which the log was recorded.
  */
  locLat?: number;
  /**
   * Longitude at which the log was recorded.
  */
  locLng?: number;
  /**
   * Name of location at which the log was recorded.
  */
  locName?: string;
  /**
   * State in which the log was recorded.
  */
  locState?: string;
  /**
   * The time at which the log/HOS status started in UNIX milliseconds.
  */
  logStartMs?: number;
  /**
   * Remark associated with the log entry.
  */
  remark?: string;
  /**
   * The Hours of Service status type. One of `OFF_DUTY`, `SLEEPER_BED`, `DRIVING`, `ON_DUTY`,
   * `YARD_MOVE`, `PERSONAL_CONVEYANCE`.
  */
  statusType?: string;
  /**
   * ID of the vehicle.
  */
  vehicleId?: number;
}

export interface HosLogsResponse {
  logs?: HosLogsResponseLogsItem[];
}

export interface HosLogsSummaryResponseDriversItem {
  /**
   * The amount of remaining cycle time (in ms).
  */
  cycleRemaining?: number;
  /**
   * The amount of cycle time (in ms) available tomorrow.
  */
  cycleTomorrow?: number;
  /**
   * ID of the driver.
  */
  driverId?: number;
  /**
   * Name of the driver.
  */
  driverName?: string;
  /**
   * The amount of driving time in violation in this cycle (in ms).
  */
  drivingInViolationCycle?: number;
  /**
   * The amount of driving time in violation today (in ms).
  */
  drivingInViolationToday?: number;
  /**
   * The Hours of Service status type. One of `OFF_DUTY`, `SLEEPER_BED`, `DRIVING`, `ON_DUTY`,
   * `YARD_MOVE`, `PERSONAL_CONVEYANCE`.
  */
  dutyStatus?: string;
  /**
   * The amount of remaining shift drive time (in ms).
  */
  shiftDriveRemaining?: number;
  /**
   * The amount of remaining shift time (in ms).
  */
  shiftRemaining?: number;
  /**
   * The amount of time (in ms) that the driver has been in the current `dutyStatus`.
  */
  timeInCurrentStatus?: number;
  /**
   * The amount of time (in ms) remaining until the driver cannot drive without a rest break.
  */
  timeUntilBreak?: number;
  /**
   * Name of the vehicle.
  */
  vehicleName?: string;
}

export interface HosLogsSummaryResponse {
  drivers?: HosLogsSummaryResponseDriversItem[];
}

export interface HumidityResponseSensorsItem {
  /**
   * Currently reported relative humidity in percent, from 0-100.
  */
  humidity?: number;
  /**
   * ID of the sensor.
  */
  id?: number;
  /**
   * Name of the sensor.
  */
  name?: string;
}

/**
 * Contains the current humidity of a sensor.
*/
export interface HumidityResponse {
  groupId?: number;
  sensors?: HumidityResponseSensorsItem[];
}

/**
 * Contains information about a machine.
*/
export interface Machine {
  /**
   * ID of the machine.
  */
  id: number;
  /**
   * Name of the machine.
  */
  name?: string;
  /**
   * Notes about the machine
  */
  notes?: string;
}

export interface MachineHistoryResponseMachinesItemVibrationsItem {
  x?: number;
  y?: number;
  z?: number;
  time?: number;
}

export interface MachineHistoryResponseMachinesItem {
  /**
   * Machine ID
  */
  id?: number;
  /**
   * Machine name
  */
  name?: string;
  /**
   * List of vibration datapoints, with timestamp and vibration measurement for x/y/z axis in mm/s
  */
  vibrations?: MachineHistoryResponseMachinesItemVibrationsItem[];
}

/**
 * Contains the results for a machine history request
*/
export interface MachineHistoryResponse {
  machines?: MachineHistoryResponseMachinesItem[];
}

export interface Pagination {
  /**
   * Cursor identifier representing the last element in the response. This value should be used in
   * conjunction with a subsequent request's 'starting_after' query parameter.
  */
  endCursor: string;
  /**
   * True if there are more pages of results after this response.
  */
  hasNextPage: boolean;
  /**
   * True if there are more pages of results before this response.
  */
  hasPrevPage: boolean;
  /**
   * Cursor identifier representing the first element in the response. This value should be used in
   * conjunction with a subsequent request's 'ending_before' query parameter.
  */
  startCursor: string;
}

/**
 * Contains information about a sensor.
*/
export interface Sensor {
  /**
   * ID of the sensor.
  */
  id: number;
  /**
   * MAC address of the sensor.
  */
  macAddress?: string;
  /**
   * Name of the sensor.
  */
  name?: string;
}

export interface SensorHistoryResponseResultsItem {
  /**
   * List of datapoints, one for each requested (sensor, field) pair.
  */
  series?: number[];
  /**
   * Timestamp in UNIX milliseconds.
  */
  timeMs?: number;
}

/**
 * Contains the results for a sensor history request. Each result contains a timestamp and
 * datapoint for each requested (sensor, field) pair.
*/
export interface SensorHistoryResponse {
  results?: SensorHistoryResponseResultsItem[];
}

export interface TaggedAddressBase {
  /**
   * The ID of the address being tagged.
  */
  id: number;
}

export interface TaggedAddress extends TaggedAddressBase {
  /**
   * Name of the address being tagged.
  */
  name?: string;
}

export interface TaggedAssetBase {
  /**
   * The ID of the Asset being tagged.
  */
  id: number;
}

export interface TaggedAsset extends TaggedAssetBase {
  /**
   * Name of the Asset being tagged.
  */
  name?: string;
}

export interface TaggedDriverBase {
  /**
   * The ID of the Driver being tagged.
  */
  id: number;
}

export interface TaggedDriver extends TaggedDriverBase {
  /**
   * Name of the Driver being tagged.
  */
  name?: string;
}

export interface TaggedMachineBase {
  /**
   * The ID of the Machine being tagged.
  */
  id: number;
}

export interface TaggedMachine extends TaggedMachineBase {
  /**
   * Name of the Machine being tagged.
  */
  name?: string;
}

export interface TaggedSensorBase {
  /**
   * The ID of the Sensor being tagged.
  */
  id: number;
}

export interface TaggedSensor extends TaggedSensorBase {
  /**
   * Name of the Sensor being tagged.
  */
  name?: string;
}

export interface TaggedVehicleBase {
  /**
   * The ID of the Vehicle being tagged.
  */
  id: number;
}

export interface TaggedVehicle extends TaggedVehicleBase {
  /**
   * Name of the Vehicle being tagged.
  */
  name?: string;
}

export interface Tag {
  /**
   * The addresses that belong to this tag.
  */
  addresses?: TaggedAddress[];
  /**
   * The assets that belong to this tag.
  */
  assets?: TaggedAsset[];
  /**
   * The drivers that belong to this tag.
  */
  drivers?: TaggedDriver[];
  /**
   * The GroupID that this tag belongs to.
  */
  groupId?: number;
  /**
   * The ID of this tag.
  */
  id: number;
  /**
   * The machines that belong to this tag.
  */
  machines?: TaggedMachine[];
  /**
   * Name of this tag.
  */
  name: string;
  /**
   * If this tag is part a hierarchical tag tree as a child tag, the parentTagId is the ID of this
   * tag's parent tag.
  */
  parentTagId?: number;
  /**
   * The sensors that belong to this tag.
  */
  sensors?: TaggedSensor[];
  /**
   * The vehicles that belong to this tag.
  */
  vehicles?: TaggedVehicle[];
}

export interface TagCreate {
  /**
   * The assets that belong to this tag.
  */
  assets?: TaggedAssetBase[];
  /**
   * The drivers that belong to this tag.
  */
  drivers?: TaggedDriverBase[];
  /**
   * The machines that belong to this tag.
  */
  machines?: TaggedMachineBase[];
  /**
   * Name of this tag.
  */
  name: string;
  /**
   * If this tag is part a hierarchical tag tree as a child tag, the parentTagId is the ID of this
   * tag's parent tag.
  */
  parentTagId?: number;
  /**
   * The sensors that belong to this tag.
  */
  sensors?: TaggedSensorBase[];
  /**
   * The vehicles that belong to this tag.
  */
  vehicles?: TaggedVehicleBase[];
}

/**
 * Specify devices, etc. that should be added to the tag.
*/
export interface TagModifyAdd {
  /**
   * The assets to be added to this tag.
  */
  assets?: TaggedAssetBase[];
  /**
   * The drivers to be added to this tag.
  */
  drivers?: TaggedDriverBase[];
  /**
   * The machines to be added to this tag.
  */
  machines?: TaggedMachineBase[];
  /**
   * The sensors to be added to this tag.
  */
  sensors?: TaggedSensorBase[];
  /**
   * The vehicles to be added to this tag.
  */
  vehicles?: TaggedVehicleBase[];
}

/**
 * Specify devices, etc. that should be removed from the tag.
*/
export interface TagModifyDelete {
  /**
   * The assets to be removed from this tag.
  */
  assets?: TaggedAssetBase[];
  /**
   * The drivers to be removed from this tag.
  */
  drivers?: TaggedDriverBase[];
  /**
   * The machines to be removed from this tag.
  */
  machines?: TaggedMachineBase[];
  /**
   * The sensors to be removed from this tag.
  */
  sensors?: TaggedSensorBase[];
  /**
   * The vehicles to be removed from this tag.
  */
  vehicles?: TaggedVehicleBase[];
}

export interface TagModify {
  /**
   * Specify devices, etc. that should be added to the tag.
  */
  add?: TagModifyAdd;
  /**
   * Specify devices, etc. that should be removed from the tag.
  */
  deleteProperty?: TagModifyDelete;
  /**
   * Updated name of this tag.
  */
  name?: string;
  /**
   * If this tag is part a hierarchical tag tree as a child tag, the parentTagId is the ID of this
   * tag's parent tag.
  */
  parentTagId?: number;
}

export interface TagUpdate {
  /**
   * The assets that belong to this tag.
  */
  assets?: TaggedAssetBase[];
  /**
   * The drivers that belong to this tag.
  */
  drivers?: TaggedDriverBase[];
  /**
   * The machines that belong to this tag.
  */
  machines?: TaggedMachineBase[];
  /**
   * Updated name of this tag.
  */
  name?: string;
  /**
   * If this tag is part a hierarchical tag tree as a child tag, the parentTagId is the ID of this
   * tag's parent tag.
  */
  parentTagId?: number;
  /**
   * The sensors that belong to this tag.
  */
  sensors?: TaggedSensorBase[];
  /**
   * The vehicles that belong to this tag.
  */
  vehicles?: TaggedVehicleBase[];
}

export interface TemperatureResponseSensorsItem {
  /**
   * Currently reported ambient temperature in millidegrees celsius.
  */
  ambientTemperature?: number;
  /**
   * ID of the sensor.
  */
  id?: number;
  /**
   * Name of the sensor.
  */
  name?: string;
  /**
   * Currently reported probe temperature in millidegrees celsius. If no probe is connected, this
   * parameter will not be reported.
  */
  probeTemperature?: number;
}

/**
 * Contains the current temperatures of a sensor.
*/
export interface TemperatureResponse {
  groupId?: number;
  sensors?: TemperatureResponseSensorsItem[];
}

/**
 * End (latitude, longitude) in decimal degrees.
*/
export interface TripResponseTripsItemEndCoordinates {
  latitude?: number;
  longitude?: number;
}

/**
 * Start (latitude, longitude) in decimal degrees.
*/
export interface TripResponseTripsItemStartCoordinates {
  latitude?: number;
  longitude?: number;
}

export interface TripResponseTripsItem {
  /**
   * Length of the trip in meters.
  */
  distanceMeters?: number;
  /**
   * ID of the driver.
  */
  driverId?: number;
  /**
   * Text representation of nearest identifiable location to the end (latitude, longitude)
   * coordinates.
  */
  endAddress?: string;
  /**
   * End (latitude, longitude) in decimal degrees.
  */
  endCoordinates?: TripResponseTripsItemEndCoordinates;
  /**
   * Geocoded street address of start (latitude, longitude) coordinates.
  */
  endLocation?: string;
  /**
   * End of the trip in UNIX milliseconds.
  */
  endMs?: number;
  /**
   * Odometer reading at the end of the trip.
  */
  endOdometer?: number;
  /**
   * Amount in milliliters of fuel consumed on this trip.
  */
  fuelConsumedMl?: number;
  /**
   * Text representation of nearest identifiable location to the start (latitude, longitude)
   * coordinates.
  */
  startAddress?: string;
  /**
   * Start (latitude, longitude) in decimal degrees.
  */
  startCoordinates?: TripResponseTripsItemStartCoordinates;
  /**
   * Geocoded street address of start (latitude, longitude) coordinates.
  */
  startLocation?: string;
  /**
   * Beginning of the trip in UNIX milliseconds.
  */
  startMs?: number;
  /**
   * Odometer reading at the beginning of the trip.
  */
  startOdometer?: number;
  /**
   * Length in meters trip spent on toll roads.
  */
  tollMeters?: number;
}

/**
 * Contains the trips for the vehicle in the requested timeframe. A trip is represented as an
 * object that contains startMs, startLocation, startAddress, startCoordinates, endMs, endLocation,
 * endAddress and endCoordinates.
*/
export interface TripResponse {
  trips?: TripResponseTripsItem[];
}

export interface UserTagRoleTag {
  /**
   * The ID of this tag.
  */
  id: number;
  /**
   * Name of this tag.
  */
  name: string;
  /**
   * The ID of this tag.
  */
  parentTagId?: number;
}

export interface UserTagRole {
  /**
   * The name of the role the user has been granted on this tag.
  */
  role?: string;
  /**
   * The id of the role the user has been granted on this tag.
  */
  roleId: string;
  tag: UserTagRoleTag;
}

export interface UserBase {
  /**
   * The authentication type the user uses to authenticate. To use SAML this organization must have
   * a configured SAML integration. Possible values include: 'default', 'saml'
  */
  authType: string;
  /**
   * The email address of this user.
  */
  email: string;
  /**
   * The first and last name of the user.
  */
  name?: string;
  /**
   * The id of the role the user is assigned to at the organization level. This will be blank for
   * users that only have access to specific tags.
  */
  organizationRoleId?: string;
}

export interface User extends UserBase {
  /**
   * The ID of the User record.
  */
  id?: number;
  /**
   * The name of the role the user is assigned to at the organization level. This will be blank for
   * users that only have access to specific tags.
  */
  organizationRole?: string;
  /**
   * The specific tags this user has access to. This will be blank for users that have full access
   * to the organization.
  */
  tagRoles?: UserTagRole[];
}

export interface UserRole {
  id?: string;
  name?: string;
}

/**
 * A vehicle object.
*/
export interface Vehicle {
  /**
   * Total engine hours for the vehicle.
  */
  engineHours?: number;
  /**
   * The fuel level of the vehicle as a percentage. (0.0 to 1.0)
  */
  fuelLevelPercent?: number;
  /**
   * ID of the vehicle.
  */
  id: number;
  /**
   * Name of the vehicle.
  */
  name?: string;
  note?: string;
  /**
   * The number of meters reported by the odometer.
  */
  odometerMeters?: number;
  /**
   * Vehicle Identification Number.
  */
  vin?: string;
}

export interface VehicleHarshEventResponseLocation {
  /**
   * Address of location where the harsh event occurred
  */
  address?: string;
  /**
   * Latitude of location where the harsh event occurred
  */
  latitude?: string;
  /**
   * Longitude of location where the harsh event occurred
  */
  longitude?: string;
}

/**
 * Harsh event details for a vehicle
*/
export interface VehicleHarshEventResponse {
  /**
   * URL for downloading the forward facing video
  */
  downloadForwardVideoUrl?: string;
  /**
   * URL for downloading the inward facing video
  */
  downloadInwardVideoUrl?: string;
  /**
   * URL for downloading the tracked inward facing video
  */
  downloadTrackedInwardVideoUrl?: string;
  /**
   * Type of the harsh event. One of: [Crash, Harsh Acceleration, Harsh Braking, Harsh Turn, ROP
   * Engine, ROP Brake, YC Engine, YC Brake, Harsh Event]
  */
  harshEventType: string;
  /**
   * URL of the associated incident report page
  */
  incidentReportUrl: string;
  /**
   * Whether the driver was deemed distracted during this harsh event
  */
  isDistracted?: boolean;
  location?: VehicleHarshEventResponseLocation;
}

/**
 * Contains the location, in latitude and longitude, of a vehicle.
*/
export interface VehicleLocation {
  /**
   * Heading in degrees.
  */
  heading?: number;
  /**
   * ID of the vehicle.
  */
  id: number;
  /**
   * Latitude in decimal degrees.
  */
  latitude?: number;
  /**
   * Text representation of nearest identifiable location to (latitude, longitude) coordinates.
  */
  location?: string;
  /**
   * Longitude in decimal degrees.
  */
  longitude?: number;
  /**
   * Name of the vehicle.
  */
  name?: string;
  /**
   * The number of meters reported by the odometer.
  */
  odometerMeters?: number;
  /**
   * Whether or not a trip is currently in progress for this vehicle. More information available
   * via /fleet/trips endpoint.
  */
  onTrip?: boolean;
  /**
   * Speed in miles per hour.
  */
  speed?: number;
  /**
   * The time the reported location was logged, reported as a UNIX timestamp in milliseconds.
  */
  time?: number;
  /**
   * Vehicle Identification Number (VIN) of the vehicle.
  */
  vin?: string;
}

/**
 * J1939 check engine lights.
*/
export interface VehicleMaintenanceJ1939CheckEngineLight {
  emissionsIsOn?: boolean;
  protectIsOn?: boolean;
  stopIsOn?: boolean;
  warningIsOn?: boolean;
}

export interface VehicleMaintenanceJ1939DiagnosticTroubleCodesItem {
  fmiId?: number;
  fmiText?: string;
  occurrenceCount?: number;
  spnDescription?: string;
  spnId?: number;
  txId?: number;
}

/**
 * J1939 based data. Null if no data is available.
*/
export interface VehicleMaintenanceJ1939 {
  /**
   * J1939 check engine lights.
  */
  checkEngineLight?: VehicleMaintenanceJ1939CheckEngineLight;
  /**
   * J1939 DTCs.
  */
  diagnosticTroubleCodes?: VehicleMaintenanceJ1939DiagnosticTroubleCodesItem[];
}

/**
 * Passenger vehicle check engine light.
*/
export interface VehicleMaintenancePassengerCheckEngineLight {
  isOn?: boolean;
}

export interface VehicleMaintenancePassengerDiagnosticTroubleCodesItem {
  dtcDescription?: string;
  dtcId?: number;
  dtcShortCode?: string;
}

/**
 * Passenger vehicle data. Null if no data is available.
*/
export interface VehicleMaintenancePassenger {
  /**
   * Passenger vehicle check engine light.
  */
  checkEngineLight?: VehicleMaintenancePassengerCheckEngineLight;
  /**
   * Passenger vehicle DTCs.
  */
  diagnosticTroubleCodes?: VehicleMaintenancePassengerDiagnosticTroubleCodesItem[];
}

/**
 * Contains any J1939/Passenger engine light warnings and engine faults.
*/
export interface VehicleMaintenance {
  /**
   * ID of the vehicle.
  */
  id: number;
  /**
   * J1939 based data. Null if no data is available.
  */
  j1939?: VehicleMaintenanceJ1939;
  /**
   * Passenger vehicle data. Null if no data is available.
  */
  passenger?: VehicleMaintenancePassenger;
}

/**
 * Safety score details for a vehicle
*/
export interface VehicleSafetyScoreResponse {
  /**
   * Crash event count
  */
  crashCount?: number;
  /**
   * Harsh acceleration event count
  */
  harshAccelCount?: number;
  /**
   * Harsh braking event count
  */
  harshBrakingCount?: number;
  harshEvents?: SafetyReportHarshEvent[];
  /**
   * Harsh turning event count
  */
  harshTurningCount?: number;
  /**
   * Safety Score
  */
  safetyScore?: number;
  /**
   * Safety Score Rank
  */
  safetyScoreRank?: string;
  /**
   * Amount of time driven over the speed limit in milliseconds
  */
  timeOverSpeedLimitMs?: number;
  /**
   * Total distance driven in meters
  */
  totalDistanceDrivenMeters?: number;
  /**
   * Total harsh event count
  */
  totalHarshEventCount?: number;
  /**
   * Amount of time driven in milliseconds
  */
  totalTimeDrivenMs?: number;
  /**
   * Vehicle ID
  */
  vehicleId?: number;
}

export interface JobUpdateObject {
  /**
   * Timestamp that this event was updated, represented as Unix milliseconds since epoch.
  */
  changedAtMs?: number;
  /**
   * ID of the Samsara job.
  */
  jobId?: number;
  /**
   * Possible values include: 'JobState_Unassigned', 'JobState_Scheduled', 'JobState_EnRoute',
   * 'JobState_Arrived', 'JobState_Completed', 'JobState_Skipped'
  */
  jobState?: string;
  /**
   * Possible values include: 'JobState_Unassigned', 'JobState_Scheduled', 'JobState_EnRoute',
   * 'JobState_Arrived', 'JobState_Completed', 'JobState_Skipped'
  */
  prevJobState?: string;
  route?: DispatchRoute;
  /**
   * ID of the Samsara dispatch route.
  */
  routeId?: number;
}

export interface AllRouteJobUpdates {
  jobUpdates?: JobUpdateObject[];
  /**
   * Sequence ID of the last update returned in the response
  */
  sequenceId?: string;
}

export interface AddressesAddressesItem {
  contactIds?: number[];
  /**
   * The full address associated with this address/geofence, as it might be recognized by
   * maps.google.com
  */
  formattedAddress: string;
  geofence: AddressGeofence;
  /**
   * The name of this address/geofence
  */
  name: string;
  notes?: string;
  tagIds?: number[];
}

export interface Addresses {
  addresses: AddressesAddressesItem[];
}

export interface AddressModel {
  contactIds?: number[];
  /**
   * The full address associated with this address/geofence, as it might be recognized by
   * maps.google.com
  */
  formattedAddress?: string;
  geofence?: AddressGeofence;
  /**
   * The name of this address/geofence
  */
  name?: string;
  notes?: string;
  tagIds?: number[];
}

export interface AddressParam {
  /**
   * The address of the entry to add, as it would be recognized if provided to maps.google.com.
  */
  address: string;
  /**
   * Group ID to query.
  */
  groupId: number;
  /**
   * Name of the location to add to the address book.
  */
  name: string;
  /**
   * Radius in meters of the address (used for matching vehicle trip stops to this location).
  */
  radius: number;
}

export interface GetAllAssetsOKResponse {
  assets?: Asset[];
}

export interface GetAllAssetCurrentLocationsOKResponse {
  assets?: AssetCurrentLocationsResponse[];
}

export interface GroupDriversParam {
  /**
   * Group ID to query.
  */
  groupId: number;
}

export interface ReactivateDriverParam {
  /**
   * True indicates that this driver should be reactivated.
  */
  reactivate: boolean;
}

export interface DriversSummaryParam {
  /**
   * End time (ms) of queried time period.
  */
  endMs: number;
  /**
   * Org ID to query.
  */
  orgId: number;
  /**
   * Start time (ms) of queried time period.
  */
  startMs: number;
}

export interface Body {
  /**
   * Driver ID to query.
  */
  driverId: number;
  /**
   * End of the time range, specified in milliseconds UNIX time.
  */
  endMs: number;
  /**
   * Group ID to query.
  */
  groupId: number;
  /**
   * Beginning of the time range, specified in milliseconds UNIX time.
  */
  startMs: number;
}

export interface HosAuthenticationLogsParam {
  /**
   * Driver ID to query.
  */
  driverId: number;
  /**
   * End of the time range, specified in milliseconds UNIX time.
  */
  endMs: number;
  /**
   * Group ID to query.
  */
  groupId: number;
  /**
   * Beginning of the time range, specified in milliseconds UNIX time.
  */
  startMs: number;
}

export interface HosLogsParam {
  /**
   * Group ID to query.
  */
  groupId: number;
}

export interface BodyModel {
  /**
   * Group ID to query.
  */
  groupId: number;
}

export interface FleetOKResponse {
  /**
   * Group ID to query.
  */
  groupId?: number;
  pagination?: Pagination;
  vehicles?: Vehicle[];
}

export interface LocationsOKResponse {
  /**
   * Group ID to query.
  */
  groupId?: number;
  vehicles?: VehicleLocation[];
}

export interface CreateDvirParam {
  /**
   * Any notes from the mechanic.
  */
  mechanicNotes?: string;
  /**
   * The current odometer of the vehicle.
  */
  odometerMiles?: number;
  /**
   * Whether any previous defects were corrected. If this vehicle or trailer was previously marked
   * unsafe, and this DVIR marks it as safe, either previousDefectsCorrected or
   * previousDefectsIgnored must be true.
  */
  previousDefectsCorrected?: boolean;
  /**
   * Whether any previous defects were ignored. If this vehicle or trailer was previously marked
   * unsafe, and this DVIR marks it as safe, either previousDefectsCorrected or
   * previousDefectsIgnored must be true.
  */
  previousDefectsIgnored?: boolean;
  /**
   * Whether or not this vehicle or trailer is safe to drive. Possible values include: 'safe',
   * 'unsafe'
  */
  safe: string;
  /**
   * Id of trailer being inspected. Either vehicleId or trailerId must be provided.
  */
  trailerId?: number;
  /**
   * The Samsara login email for the person creating the DVIR. The email must correspond to a
   * Samsara user's email.
  */
  userEmail: string;
  /**
   * Id of vehicle being inspected. Either vehicleId or trailerId must be provided.
  */
  vehicleId?: number;
}

export interface ListOKResponse {
  vehicles?: VehicleMaintenance[];
}

export interface VehicleUpdateParam {
  /**
   * Group ID to query.
  */
  groupId: number;
  vehicles: Vehicle[];
}

export interface TripsParam {
  /**
   * End of the time range, specified in milliseconds UNIX time.
  */
  endMs: number;
  /**
   * Group ID to query.
  */
  groupId: number;
  /**
   * Beginning of the time range, specified in milliseconds UNIX time. Limited to a 90 day window
   * with respect to startMs and endMs
  */
  startMs: number;
  /**
   * Vehicle ID to query.
  */
  vehicleId: number;
}

export interface GetVehicleStatsOKResponseVehicleStatsItem {
  auxInput1?: AuxInputSeries;
  auxInput2?: AuxInputSeries;
  engineState?: EngineState[];
  /**
   * ID of the vehicle.
  */
  vehicleId: number;
}

export interface GetVehicleStatsOKResponse {
  pagination?: Pagination;
  vehicleStats: GetVehicleStatsOKResponseVehicleStatsItem[];
}

export interface Data {
  externalIds?: { [propertyName: string]: string };
  /**
   * Harsh Event Detection Setting
   * * 0: Passenger
   * * 1: Light Truck
   * * 2: Heavy
   * * 3: Off
   * * 4: Automatic
  */
  harshAccelSetting?: number;
  /**
   * Name
  */
  name?: string;
}

export interface GetAllDataInputsOKResponse {
  dataInputs?: DataInputHistoryResponse[];
}

export interface HistoryParam {
  /**
   * End of the time range, specified in milliseconds UNIX time.
  */
  endMs: number;
  /**
   * Group ID to query.
  */
  groupId: number;
  /**
   * Beginning of the time range, specified in milliseconds UNIX time.
  */
  startMs: number;
}

export interface MachinesOKResponse {
  machines?: Machine[];
}

export interface BodyModelModel {
  /**
   * Group ID to query.
  */
  groupId: number;
  /**
   * List of sensor IDs to query.
  */
  sensors: number[];
}

/**
 * Sensor ID and field to query.
*/
export interface HistoryParamSeriesItem {
  /**
   * Field to query. Possible values include: 'ambientTemperature', 'probeTemperature',
   * 'currentLoop1Raw', 'currentLoop1Mapped', 'currentLoop2Raw', 'currentLoop2Mapped',
   * 'pmPowerTotal', 'pmPhase1Power', 'pmPhase2Power', 'pmPhase3Power', 'pmPhase1PowerFactor',
   * 'pmPhase2PowerFactor', 'pmPhase3PowerFactor'
  */
  field: string;
  /**
   * Sensor ID to query.
  */
  widgetId: number;
}

export interface HistoryParamModel {
  /**
   * End of the time range, specified in milliseconds UNIX time.
  */
  endMs: number;
  /**
   * Possible values include: 'withNull', 'withPrevious'
  */
  fillMissing?: string;
  /**
   * Group ID to query.
  */
  groupId: number;
  series: HistoryParamSeriesItem[];
  /**
   * Beginning of the time range, specified in milliseconds UNIX time.
  */
  startMs: number;
  /**
   * Time resolution for which data should be returned, in milliseconds. Specifying 3600000 will
   * return data at hour intervals.
  */
  stepMs: number;
}

export interface SensorsOKResponse {
  sensors?: Sensor[];
}

export interface GetAllTagsOKResponse {
  tags?: Tag[];
}
