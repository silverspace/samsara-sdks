# encoding: utf-8
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is
# regenerated.

module Swagger
  #
  # A service client - single point of access to the REST API.
  #
  class SamsaraAPI < MsRest::ServiceClient
    include MsRest::Serialization

    # @return [String] the base URI of the service.
    attr_accessor :base_url

    # @return [String] Samsara API access token.
    attr_accessor :access_token

    # @return [Addresses] List of addresses/geofences to add. Geofences can be
    # circular or a polygon.
    # For each address, only one of 'circle' or 'polygon' should be provided.
    # If both are provided, the geofence will be saved as a polygon.
    attr_accessor :addresses

    # @return [AddressModel] Update parts of an address's value. If the
    # geofence 'circle' or 'polygon' key is specified, the update will change
    # the type of geofence accordingly.
    attr_accessor :address

    # @return [Integer] Timestamp in milliseconds representing the end of the
    # period to fetch, inclusive. Used in combination with startMs.
    attr_accessor :end_ms

    # @return [Integer] Timestamp in milliseconds representing the start of the
    # period to fetch, inclusive. Used in combination with endMs.
    attr_accessor :start_ms

    # @return [Integer] ID of the asset
    attr_accessor :asset_id

    # @return [DriverForCreate] Driver creation body
    attr_accessor :create_driver_param

    # @return [CreateDvirParam] DVIR creation body
    attr_accessor :create_dvir_param

    # @return [Integer] Timestamp in unix milliseconds representing the end of
    # the period to fetch, inclusive. Used in combination with startMs.
    # Defaults to nowMs.
    attr_accessor :end_ms1

    # @return [Integer] ID of the data input
    attr_accessor :data_input_id

    # @return [Integer] Timestamp in unix milliseconds representing the start
    # of the period to fetch, inclusive. Used in combination with endMs.
    # defaults to nowMs.
    attr_accessor :start_ms1

    # @return [DocumentCreate] To create a document for a given document type,
    # the document type's uuid needs to be passed in to documentTypeUuid. The
    # list of fields passed in should match the document type’s list of field
    # types in the correct order. In other words, a field's valueType and value
    # (i.e. only one of: stringValue, numberValue, or photoValue) at index _i_
    # should match with the document field type’s valueType at index _i_.
    attr_accessor :create_document_params

    # @return [Integer] Time in milliseconds that represents the duration
    # before endMs to query. Defaults to 24 hours.
    attr_accessor :duration_ms

    # @return [Integer] Time in unix milliseconds that represents the oldest
    # documents to return. Used in combination with durationMs. Defaults to
    # now.
    attr_accessor :end_ms2

    # @return [String] ID of the driver.  This must be either the numeric ID
    # generated by Samsara or the external ID of the driver.  External IDs are
    # customer specified key-value pairs.
    attr_accessor :driver_id_or_external_id

    # @return [Integer] Optional group ID if the organization has multiple
    # groups (uncommon).
    attr_accessor :group_id

    # @return [GroupParam] Group ID to query.
    attr_accessor :group_param

    # @return [Integer] Timestamp in milliseconds representing the timestamp of
    # a harsh event.
    attr_accessor :timestamp

    # @return [String] Optionally set include=route to include route object in
    # response payload.
    attr_accessor :include

    # @return [String] Sequence ID from the response payload of the last
    # request. Defaults to fetching updates from last 24 hours.
    attr_accessor :sequence_id

    # @return [String] Pagination parameter indicating the cursor position to
    # return results before. Used in conjunction with the 'limit' parameter.
    # Mutually exclusive with 'startingAfter' parameter.
    attr_accessor :ending_before

    # @return [Float] Pagination parameter indicating the number of results to
    # return in this request. Used in conjunction with either 'startingAfter'
    # or 'endingBefore'.
    attr_accessor :limit

    # @return [String] Pagination parameter indicating the cursor position to
    # continue returning results after. Used in conjunction with the 'limit'
    # parameter. Mutually exclusive with 'endingBefore' parameter.
    attr_accessor :starting_after

    # @return [ReactivateDriverParam] Driver reactivation body
    attr_accessor :reactivate_driver_param

    # @return [DispatchRouteCreate]
    attr_accessor :create_dispatch_route_params

    # @return [Integer] Time in milliseconds that represents the duration
    # before end_time to query. Defaults to 24 hours.
    attr_accessor :duration

    # @return [Integer] Time in unix milliseconds that represents the oldest
    # routes to return. Used in combination with duration. Defaults to now.
    attr_accessor :end_time

    # @return [Integer] Timestamp representing the end of the period to fetch,
    # inclusive. Used in combination with start_time. Defaults to nowMs.
    attr_accessor :end_time1

    # @return [Integer] Timestamp representing the start of the period to
    # fetch, inclusive. Used in combination with end_time. Defaults to 0.
    attr_accessor :start_time

    # @return [DispatchRoute]
    attr_accessor :update_dispatch_route_params

    # @return [Integer] Timestamp in milliseconds representing the end of the
    # period to fetch, inclusive. Used in combination with startMs.
    attr_accessor :end_ms3

    # @return [Integer] Timestamp in milliseconds representing the start of the
    # period to fetch, inclusive. Used in combination with endMs.
    attr_accessor :start_ms2

    # @return [SensorParam] Group ID and list of sensor IDs to query.
    attr_accessor :sensor_param

    # @return [TagCreate]
    attr_accessor :tag_create_params

    # @return [TagModify]
    attr_accessor :tag_modify_params

    # @return [Integer] ID of the tag.
    attr_accessor :tag_id

    # @return [TagUpdate]
    attr_accessor :update_tag_params

    # @return [String] ID of the vehicle.  This must be either the numeric ID
    # generated by Samsara or the external ID of the vehicle.  External IDs are
    # customer specified key-value pairs.
    attr_accessor :vehicle_id_or_external_id

    # @return [Add] add
    attr_reader :add

    # @return [Get] get
    attr_reader :get

    # @return [List] list
    attr_reader :list

    # @return [Create] create
    attr_reader :create

    # @return [Update] update
    attr_reader :update

    #
    # Creates initializes a new instance of the SamsaraAPI class.
    # @param credentials [MsRest::ServiceClientCredentials] credentials to authorize HTTP requests made by the service client.
    # @param base_url [String] the base URI of the service.
    # @param options [Array] filters to be applied to the HTTP requests.
    #
    def initialize(credentials = nil, base_url = nil, options = nil)
      super(credentials, options)
      @base_url = base_url || 'https://api.samsara.com/v1'

      fail ArgumentError, 'invalid type of credentials input parameter' unless credentials.is_a?(MsRest::ServiceClientCredentials) unless credentials.nil?
      @credentials = credentials

      @add = Add.new(self)
      @get = Get.new(self)
      @list = List.new(self)
      @create = Create.new(self)
      @update = Update.new(self)
      add_telemetry
    end

    #
    # Makes a request and returns the body of the response.
    # @param method [Symbol] with any of the following values :get, :put, :post, :patch, :delete.
    # @param path [String] the path, relative to {base_url}.
    # @param options [Hash{String=>String}] specifying any request options like :body.
    # @return [Hash{String=>String}] containing the body of the response.
    # Example:
    #
    #  request_content = "{'location':'westus','tags':{'tag1':'val1','tag2':'val2'}}"
    #  path = "/path"
    #  options = {
    #    body: request_content,
    #    query_params: {'api-version' => '2016-02-01'}
    #  }
    #  result = @client.make_request(:put, path, options)
    #
    def make_request(method, path, options = {})
      result = make_request_with_http_info(method, path, options)
      result.body unless result.nil?
    end

    #
    # Makes a request and returns the operation response.
    # @param method [Symbol] with any of the following values :get, :put, :post, :patch, :delete.
    # @param path [String] the path, relative to {base_url}.
    # @param options [Hash{String=>String}] specifying any request options like :body.
    # @return [MsRest::HttpOperationResponse] Operation response containing the request, response and status.
    #
    def make_request_with_http_info(method, path, options = {})
      result = make_request_async(method, path, options).value!
      result.body = result.response.body.to_s.empty? ? nil : JSON.load(result.response.body)
      result
    end

    #
    # Makes a request asynchronously.
    # @param method [Symbol] with any of the following values :get, :put, :post, :patch, :delete.
    # @param path [String] the path, relative to {base_url}.
    # @param options [Hash{String=>String}] specifying any request options like :body.
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def make_request_async(method, path, options = {})
      fail ArgumentError, 'method is nil' if method.nil?
      fail ArgumentError, 'path is nil' if path.nil?

      request_url = options[:base_url] || @base_url
      if(!options[:headers].nil? && !options[:headers]['Content-Type'].nil?)
        @request_headers['Content-Type'] = options[:headers]['Content-Type']
      end

      request_headers = @request_headers
      options.merge!({headers: request_headers.merge(options[:headers] || {})})
      options.merge!({credentials: @credentials}) unless @credentials.nil?

      super(request_url, method, path, options)
    end

    #
    # /addresses
    #
    # Fetch all addresses/geofences for the organization. An address contains
    # either a circle or polygon geofence describing the address boundaries.
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array] operation results.
    #
    def get_organization_addresses(custom_headers:nil)
      response = get_organization_addresses_async(custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # /addresses
    #
    # Fetch all addresses/geofences for the organization. An address contains
    # either a circle or polygon geofence describing the address boundaries.
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_organization_addresses_with_http_info(custom_headers:nil)
      get_organization_addresses_async(custom_headers:custom_headers).value!
    end

    #
    # /addresses
    #
    # Fetch all addresses/geofences for the organization. An address contains
    # either a circle or polygon geofence describing the address boundaries.
    #
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_organization_addresses_async(custom_headers:nil)
      fail ArgumentError, 'access_token is nil' if access_token.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'addresses'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          query_params: {'access_token' => access_token},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = {
              client_side_validation: true,
              required: false,
              serialized_name: 'parsed_response',
              type: {
                name: 'Sequence',
                element: {
                    client_side_validation: true,
                    required: false,
                    serialized_name: 'AddressElementType',
                    type: {
                      name: 'Composite',
                      class_name: 'Address'
                    }
                }
              }
            }
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # /addresses
    #
    # Add one or more addresses to the organization
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array] operation results.
    #
    def add_organization_addresses(custom_headers:nil)
      response = add_organization_addresses_async(custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # /addresses
    #
    # Add one or more addresses to the organization
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def add_organization_addresses_with_http_info(custom_headers:nil)
      add_organization_addresses_async(custom_headers:custom_headers).value!
    end

    #
    # /addresses
    #
    # Add one or more addresses to the organization
    #
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def add_organization_addresses_async(custom_headers:nil)
      fail ArgumentError, 'access_token is nil' if access_token.nil?
      fail ArgumentError, 'addresses is nil' if addresses.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Serialize Request
      request_mapper = Swagger::Models::Addresses.mapper()
      request_content = self.serialize(request_mapper,  addresses)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'addresses'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          query_params: {'access_token' => access_token},
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:post, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = {
              client_side_validation: true,
              required: false,
              serialized_name: 'parsed_response',
              type: {
                name: 'Sequence',
                element: {
                    client_side_validation: true,
                    required: false,
                    serialized_name: 'AddressElementType',
                    type: {
                      name: 'Composite',
                      class_name: 'Address'
                    }
                }
              }
            }
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # /addresses/{addressId}
    #
    # Fetch an address by its id.
    #
    # @param address_id [Integer] ID of the address/geofence
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Address] operation results.
    #
    def get_organization_address(address_id, custom_headers:nil)
      response = get_organization_address_async(address_id, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # /addresses/{addressId}
    #
    # Fetch an address by its id.
    #
    # @param address_id [Integer] ID of the address/geofence
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_organization_address_with_http_info(address_id, custom_headers:nil)
      get_organization_address_async(address_id, custom_headers:custom_headers).value!
    end

    #
    # /addresses/{addressId}
    #
    # Fetch an address by its id.
    #
    # @param address_id [Integer] ID of the address/geofence
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_organization_address_async(address_id, custom_headers:nil)
      fail ArgumentError, 'access_token is nil' if access_token.nil?
      fail ArgumentError, 'address_id is nil' if address_id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'addresses/{addressId}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'addressId' => address_id},
          query_params: {'access_token' => access_token},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Swagger::Models::Address.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # /addresses/{addressId}
    #
    # Delete an address.
    #
    # @param address_id [Integer] ID of the address/geofence
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    #
    def delete_organization_address(address_id, custom_headers:nil)
      response = delete_organization_address_async(address_id, custom_headers:custom_headers).value!
      nil
    end

    #
    # /addresses/{addressId}
    #
    # Delete an address.
    #
    # @param address_id [Integer] ID of the address/geofence
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def delete_organization_address_with_http_info(address_id, custom_headers:nil)
      delete_organization_address_async(address_id, custom_headers:custom_headers).value!
    end

    #
    # /addresses/{addressId}
    #
    # Delete an address.
    #
    # @param address_id [Integer] ID of the address/geofence
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def delete_organization_address_async(address_id, custom_headers:nil)
      fail ArgumentError, 'access_token is nil' if access_token.nil?
      fail ArgumentError, 'address_id is nil' if address_id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'addresses/{addressId}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'addressId' => address_id},
          query_params: {'access_token' => access_token},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:delete, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # /addresses/{addressId}
    #
    # Update the name, formatted address, geofence, notes, or tag and contact Ids
    # for an address. The set of tags or contacts associated with this address will
    # be updated to exactly match the list of IDs passed in. To remove all tags or
    # contacts from an address, pass an empty list; to remove notes, pass an empty
    # string.
    #
    # @param address_id [Integer] ID of the address/geofence
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    #
    def update_organization_address(address_id, custom_headers:nil)
      response = update_organization_address_async(address_id, custom_headers:custom_headers).value!
      nil
    end

    #
    # /addresses/{addressId}
    #
    # Update the name, formatted address, geofence, notes, or tag and contact Ids
    # for an address. The set of tags or contacts associated with this address will
    # be updated to exactly match the list of IDs passed in. To remove all tags or
    # contacts from an address, pass an empty list; to remove notes, pass an empty
    # string.
    #
    # @param address_id [Integer] ID of the address/geofence
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def update_organization_address_with_http_info(address_id, custom_headers:nil)
      update_organization_address_async(address_id, custom_headers:custom_headers).value!
    end

    #
    # /addresses/{addressId}
    #
    # Update the name, formatted address, geofence, notes, or tag and contact Ids
    # for an address. The set of tags or contacts associated with this address will
    # be updated to exactly match the list of IDs passed in. To remove all tags or
    # contacts from an address, pass an empty list; to remove notes, pass an empty
    # string.
    #
    # @param address_id [Integer] ID of the address/geofence
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def update_organization_address_async(address_id, custom_headers:nil)
      fail ArgumentError, 'access_token is nil' if access_token.nil?
      fail ArgumentError, 'address is nil' if address.nil?
      fail ArgumentError, 'address_id is nil' if address_id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Serialize Request
      request_mapper = Swagger::Models::AddressModel.mapper()
      request_content = self.serialize(request_mapper,  address)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'addresses/{addressId}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'addressId' => address_id},
          query_params: {'access_token' => access_token},
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:patch, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # /contacts
    #
    # Fetch all contacts for the organization.
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array] operation results.
    #
    def list_contacts(custom_headers:nil)
      response = list_contacts_async(custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # /contacts
    #
    # Fetch all contacts for the organization.
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def list_contacts_with_http_info(custom_headers:nil)
      list_contacts_async(custom_headers:custom_headers).value!
    end

    #
    # /contacts
    #
    # Fetch all contacts for the organization.
    #
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def list_contacts_async(custom_headers:nil)
      fail ArgumentError, 'access_token is nil' if access_token.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'contacts'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          query_params: {'access_token' => access_token},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = {
              client_side_validation: true,
              required: false,
              serialized_name: 'parsed_response',
              type: {
                name: 'Sequence',
                element: {
                    client_side_validation: true,
                    required: false,
                    serialized_name: 'ContactElementType',
                    type: {
                      name: 'Composite',
                      class_name: 'Contact'
                    }
                }
              }
            }
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # /contacts/{contact_id}
    #
    # Fetch a contact by its id.
    #
    # @param contact_id [Integer] ID of the contact
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Contact] operation results.
    #
    def get_organization_contact(contact_id, custom_headers:nil)
      response = get_organization_contact_async(contact_id, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # /contacts/{contact_id}
    #
    # Fetch a contact by its id.
    #
    # @param contact_id [Integer] ID of the contact
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_organization_contact_with_http_info(contact_id, custom_headers:nil)
      get_organization_contact_async(contact_id, custom_headers:custom_headers).value!
    end

    #
    # /contacts/{contact_id}
    #
    # Fetch a contact by its id.
    #
    # @param contact_id [Integer] ID of the contact
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_organization_contact_async(contact_id, custom_headers:nil)
      fail ArgumentError, 'access_token is nil' if access_token.nil?
      fail ArgumentError, 'contact_id is nil' if contact_id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'contacts/{contact_id}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'contact_id' => contact_id},
          query_params: {'access_token' => access_token},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Swagger::Models::Contact.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # /fleet/assets
    #
    # Fetch all of the assets for the group.
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [GetAllAssetsOKResponse] operation results.
    #
    def get_all_assets(custom_headers:nil)
      response = get_all_assets_async(custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # /fleet/assets
    #
    # Fetch all of the assets for the group.
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_all_assets_with_http_info(custom_headers:nil)
      get_all_assets_async(custom_headers:custom_headers).value!
    end

    #
    # /fleet/assets
    #
    # Fetch all of the assets for the group.
    #
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_all_assets_async(custom_headers:nil)
      fail ArgumentError, 'access_token is nil' if access_token.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'fleet/assets'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          query_params: {'access_token' => access_token,'group_id' => group_id},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Swagger::Models::GetAllAssetsOKResponse.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # /fleet/assets/locations
    #
    # Fetch current locations of all assets for the group.
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [GetAllAssetCurrentLocationsOKResponse] operation results.
    #
    def get_all_asset_current_locations(custom_headers:nil)
      response = get_all_asset_current_locations_async(custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # /fleet/assets/locations
    #
    # Fetch current locations of all assets for the group.
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_all_asset_current_locations_with_http_info(custom_headers:nil)
      get_all_asset_current_locations_async(custom_headers:custom_headers).value!
    end

    #
    # /fleet/assets/locations
    #
    # Fetch current locations of all assets for the group.
    #
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_all_asset_current_locations_async(custom_headers:nil)
      fail ArgumentError, 'access_token is nil' if access_token.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'fleet/assets/locations'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          query_params: {'access_token' => access_token,'group_id' => group_id},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Swagger::Models::GetAllAssetCurrentLocationsOKResponse.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # /fleet/assets/{assetId:[0-9]+}/locations
    #
    # Fetch the historical locations for the asset.
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array] operation results.
    #
    def get_asset_location(custom_headers:nil)
      response = get_asset_location_async(custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # /fleet/assets/{assetId:[0-9]+}/locations
    #
    # Fetch the historical locations for the asset.
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_asset_location_with_http_info(custom_headers:nil)
      get_asset_location_async(custom_headers:custom_headers).value!
    end

    #
    # /fleet/assets/{assetId:[0-9]+}/locations
    #
    # Fetch the historical locations for the asset.
    #
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_asset_location_async(custom_headers:nil)
      fail ArgumentError, 'access_token is nil' if access_token.nil?
      fail ArgumentError, 'asset_id is nil' if asset_id.nil?
      fail ArgumentError, 'start_ms is nil' if start_ms.nil?
      fail ArgumentError, 'end_ms is nil' if end_ms.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'fleet/assets/{asset_id}/locations'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'asset_id' => asset_id},
          query_params: {'access_token' => access_token,'startMs' => start_ms,'endMs' => end_ms},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = {
              client_side_validation: true,
              required: false,
              serialized_name: 'parsed_response',
              type: {
                name: 'Sequence',
                element: {
                    client_side_validation: true,
                    required: false,
                    serialized_name: 'AssetLocationResponseItemElementType',
                    type: {
                      name: 'Composite',
                      class_name: 'AssetLocationResponseItem'
                    }
                }
              }
            }
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # /fleet/assets/{assetId:[0-9]+}/reefer
    #
    # Fetch the reefer-specific stats of an asset.
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [AssetReeferResponse] operation results.
    #
    def get_asset_reefer(custom_headers:nil)
      response = get_asset_reefer_async(custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # /fleet/assets/{assetId:[0-9]+}/reefer
    #
    # Fetch the reefer-specific stats of an asset.
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_asset_reefer_with_http_info(custom_headers:nil)
      get_asset_reefer_async(custom_headers:custom_headers).value!
    end

    #
    # /fleet/assets/{assetId:[0-9]+}/reefer
    #
    # Fetch the reefer-specific stats of an asset.
    #
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_asset_reefer_async(custom_headers:nil)
      fail ArgumentError, 'access_token is nil' if access_token.nil?
      fail ArgumentError, 'asset_id is nil' if asset_id.nil?
      fail ArgumentError, 'start_ms is nil' if start_ms.nil?
      fail ArgumentError, 'end_ms is nil' if end_ms.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'fleet/assets/{asset_id}/reefer'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'asset_id' => asset_id},
          query_params: {'access_token' => access_token,'startMs' => start_ms,'endMs' => end_ms},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Swagger::Models::AssetReeferResponse.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # /fleet/dispatch/routes
    #
    # Fetch all of the dispatch routes for the group.
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array] operation results.
    #
    def fetch_all_dispatch_routes(custom_headers:nil)
      response = fetch_all_dispatch_routes_async(custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # /fleet/dispatch/routes
    #
    # Fetch all of the dispatch routes for the group.
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def fetch_all_dispatch_routes_with_http_info(custom_headers:nil)
      fetch_all_dispatch_routes_async(custom_headers:custom_headers).value!
    end

    #
    # /fleet/dispatch/routes
    #
    # Fetch all of the dispatch routes for the group.
    #
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def fetch_all_dispatch_routes_async(custom_headers:nil)
      fail ArgumentError, 'access_token is nil' if access_token.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'fleet/dispatch/routes'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          query_params: {'access_token' => access_token,'group_id' => group_id,'end_time' => end_time,'duration' => duration},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = {
              client_side_validation: true,
              required: false,
              serialized_name: 'parsed_response',
              type: {
                name: 'Sequence',
                element: {
                    client_side_validation: true,
                    required: false,
                    serialized_name: 'DispatchRouteElementType',
                    type: {
                      name: 'Composite',
                      class_name: 'DispatchRoute'
                    }
                }
              }
            }
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # /fleet/dispatch/routes
    #
    # Create a new dispatch route.
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [DispatchRoute] operation results.
    #
    def create_dispatch_route(custom_headers:nil)
      response = create_dispatch_route_async(custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # /fleet/dispatch/routes
    #
    # Create a new dispatch route.
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def create_dispatch_route_with_http_info(custom_headers:nil)
      create_dispatch_route_async(custom_headers:custom_headers).value!
    end

    #
    # /fleet/dispatch/routes
    #
    # Create a new dispatch route.
    #
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def create_dispatch_route_async(custom_headers:nil)
      fail ArgumentError, 'access_token is nil' if access_token.nil?
      fail ArgumentError, 'create_dispatch_route_params is nil' if create_dispatch_route_params.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Serialize Request
      request_mapper = Swagger::Models::DispatchRouteCreate.mapper()
      request_content = self.serialize(request_mapper,  create_dispatch_route_params)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'fleet/dispatch/routes'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          query_params: {'access_token' => access_token},
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:post, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Swagger::Models::DispatchRoute.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # /fleet/dispatch/routes/job_updates
    #
    # Fetch all updates to a job including route data in the last 24 hours or
    # subsequent to an sequence ID
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [AllRouteJobUpdates] operation results.
    #
    def fetch_all_route_job_updates(custom_headers:nil)
      response = fetch_all_route_job_updates_async(custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # /fleet/dispatch/routes/job_updates
    #
    # Fetch all updates to a job including route data in the last 24 hours or
    # subsequent to an sequence ID
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def fetch_all_route_job_updates_with_http_info(custom_headers:nil)
      fetch_all_route_job_updates_async(custom_headers:custom_headers).value!
    end

    #
    # /fleet/dispatch/routes/job_updates
    #
    # Fetch all updates to a job including route data in the last 24 hours or
    # subsequent to an sequence ID
    #
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def fetch_all_route_job_updates_async(custom_headers:nil)
      fail ArgumentError, 'access_token is nil' if access_token.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'fleet/dispatch/routes/job_updates'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          query_params: {'access_token' => access_token,'group_id' => group_id,'sequence_id' => sequence_id,'include' => include},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Swagger::Models::AllRouteJobUpdates.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # /fleet/dispatch/routes/{route_id:[0-9]+}
    #
    # Fetch a dispatch route by id.
    #
    # @param route_id [Integer] ID of the dispatch route.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [DispatchRoute] operation results.
    #
    def get_dispatch_route_by_id(route_id, custom_headers:nil)
      response = get_dispatch_route_by_id_async(route_id, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # /fleet/dispatch/routes/{route_id:[0-9]+}
    #
    # Fetch a dispatch route by id.
    #
    # @param route_id [Integer] ID of the dispatch route.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_dispatch_route_by_id_with_http_info(route_id, custom_headers:nil)
      get_dispatch_route_by_id_async(route_id, custom_headers:custom_headers).value!
    end

    #
    # /fleet/dispatch/routes/{route_id:[0-9]+}
    #
    # Fetch a dispatch route by id.
    #
    # @param route_id [Integer] ID of the dispatch route.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_dispatch_route_by_id_async(route_id, custom_headers:nil)
      fail ArgumentError, 'access_token is nil' if access_token.nil?
      fail ArgumentError, 'route_id is nil' if route_id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'fleet/dispatch/routes/{route_id}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'route_id' => route_id},
          query_params: {'access_token' => access_token},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Swagger::Models::DispatchRoute.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # /fleet/dispatch/routes/{route_id:[0-9]+}/
    #
    # Update a dispatch route and its associated jobs.
    #
    # @param route_id [Integer] ID of the dispatch route.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [DispatchRoute] operation results.
    #
    def update_dispatch_route_by_id(route_id, custom_headers:nil)
      response = update_dispatch_route_by_id_async(route_id, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # /fleet/dispatch/routes/{route_id:[0-9]+}/
    #
    # Update a dispatch route and its associated jobs.
    #
    # @param route_id [Integer] ID of the dispatch route.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def update_dispatch_route_by_id_with_http_info(route_id, custom_headers:nil)
      update_dispatch_route_by_id_async(route_id, custom_headers:custom_headers).value!
    end

    #
    # /fleet/dispatch/routes/{route_id:[0-9]+}/
    #
    # Update a dispatch route and its associated jobs.
    #
    # @param route_id [Integer] ID of the dispatch route.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def update_dispatch_route_by_id_async(route_id, custom_headers:nil)
      fail ArgumentError, 'update_dispatch_route_params is nil' if update_dispatch_route_params.nil?
      fail ArgumentError, 'access_token is nil' if access_token.nil?
      fail ArgumentError, 'route_id is nil' if route_id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Serialize Request
      request_mapper = Swagger::Models::DispatchRoute.mapper()
      request_content = self.serialize(request_mapper,  update_dispatch_route_params)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'fleet/dispatch/routes/{route_id}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'route_id' => route_id},
          query_params: {'access_token' => access_token},
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:put, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Swagger::Models::DispatchRoute.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # /fleet/dispatch/routes/{route_id:[0-9]+}/
    #
    # Delete a dispatch route and its associated jobs.
    #
    # @param route_id [Integer] ID of the dispatch route.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    #
    def delete_dispatch_route_by_id(route_id, custom_headers:nil)
      response = delete_dispatch_route_by_id_async(route_id, custom_headers:custom_headers).value!
      nil
    end

    #
    # /fleet/dispatch/routes/{route_id:[0-9]+}/
    #
    # Delete a dispatch route and its associated jobs.
    #
    # @param route_id [Integer] ID of the dispatch route.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def delete_dispatch_route_by_id_with_http_info(route_id, custom_headers:nil)
      delete_dispatch_route_by_id_async(route_id, custom_headers:custom_headers).value!
    end

    #
    # /fleet/dispatch/routes/{route_id:[0-9]+}/
    #
    # Delete a dispatch route and its associated jobs.
    #
    # @param route_id [Integer] ID of the dispatch route.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def delete_dispatch_route_by_id_async(route_id, custom_headers:nil)
      fail ArgumentError, 'access_token is nil' if access_token.nil?
      fail ArgumentError, 'route_id is nil' if route_id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'fleet/dispatch/routes/{route_id}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'route_id' => route_id},
          query_params: {'access_token' => access_token},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:delete, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # /fleet/dispatch/routes/{route_id:[0-9]+}/history
    #
    # Fetch the history of a dispatch route.
    #
    # @param route_id [Integer] ID of the route with history.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [DispatchRouteHistory] operation results.
    #
    def get_dispatch_route_history(route_id, custom_headers:nil)
      response = get_dispatch_route_history_async(route_id, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # /fleet/dispatch/routes/{route_id:[0-9]+}/history
    #
    # Fetch the history of a dispatch route.
    #
    # @param route_id [Integer] ID of the route with history.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_dispatch_route_history_with_http_info(route_id, custom_headers:nil)
      get_dispatch_route_history_async(route_id, custom_headers:custom_headers).value!
    end

    #
    # /fleet/dispatch/routes/{route_id:[0-9]+}/history
    #
    # Fetch the history of a dispatch route.
    #
    # @param route_id [Integer] ID of the route with history.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_dispatch_route_history_async(route_id, custom_headers:nil)
      fail ArgumentError, 'access_token is nil' if access_token.nil?
      fail ArgumentError, 'route_id is nil' if route_id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'fleet/dispatch/routes/{route_id}/history'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'route_id' => route_id},
          query_params: {'access_token' => access_token,'start_time' => start_time,'end_time' => end_time},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Swagger::Models::DispatchRouteHistory.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # /fleet/drivers/create
    #
    # Create a new driver.
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [CurrentDriver] operation results.
    #
    def create_driver(custom_headers:nil)
      response = create_driver_async(custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # /fleet/drivers/create
    #
    # Create a new driver.
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def create_driver_with_http_info(custom_headers:nil)
      create_driver_async(custom_headers:custom_headers).value!
    end

    #
    # /fleet/drivers/create
    #
    # Create a new driver.
    #
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def create_driver_async(custom_headers:nil)
      fail ArgumentError, 'access_token is nil' if access_token.nil?
      fail ArgumentError, 'create_driver_param is nil' if create_driver_param.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Serialize Request
      request_mapper = Swagger::Models::DriverForCreate.mapper()
      request_content = self.serialize(request_mapper,  create_driver_param)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'fleet/drivers/create'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          query_params: {'access_token' => access_token},
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:post, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Swagger::Models::CurrentDriver.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # /fleet/drivers/document_types
    #
    # Fetch all of the document types.
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array] operation results.
    #
    def get_driver_document_types_by_org_id(custom_headers:nil)
      response = get_driver_document_types_by_org_id_async(custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # /fleet/drivers/document_types
    #
    # Fetch all of the document types.
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_driver_document_types_by_org_id_with_http_info(custom_headers:nil)
      get_driver_document_types_by_org_id_async(custom_headers:custom_headers).value!
    end

    #
    # /fleet/drivers/document_types
    #
    # Fetch all of the document types.
    #
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_driver_document_types_by_org_id_async(custom_headers:nil)


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'fleet/drivers/document_types'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = {
              client_side_validation: true,
              required: false,
              serialized_name: 'parsed_response',
              type: {
                name: 'Sequence',
                element: {
                    client_side_validation: true,
                    required: false,
                    serialized_name: 'DocumentTypeElementType',
                    type: {
                      name: 'Composite',
                      class_name: 'DocumentType'
                    }
                }
              }
            }
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # /fleet/drivers/documents
    #
    # Fetch all of the documents.
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array] operation results.
    #
    def get_driver_documents_by_org_id(custom_headers:nil)
      response = get_driver_documents_by_org_id_async(custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # /fleet/drivers/documents
    #
    # Fetch all of the documents.
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_driver_documents_by_org_id_with_http_info(custom_headers:nil)
      get_driver_documents_by_org_id_async(custom_headers:custom_headers).value!
    end

    #
    # /fleet/drivers/documents
    #
    # Fetch all of the documents.
    #
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_driver_documents_by_org_id_async(custom_headers:nil)
      fail ArgumentError, 'access_token is nil' if access_token.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'fleet/drivers/documents'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          query_params: {'endMs' => end_ms,'durationMs' => duration_ms,'access_token' => access_token},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = {
              client_side_validation: true,
              required: false,
              serialized_name: 'parsed_response',
              type: {
                name: 'Sequence',
                element: {
                    client_side_validation: true,
                    required: false,
                    serialized_name: 'DocumentElementType',
                    type: {
                      name: 'Composite',
                      class_name: 'Document'
                    }
                }
              }
            }
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # /fleet/drivers/inactive
    #
    # Fetch all deactivated drivers for the group.
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array] operation results.
    #
    def get_all_deactivated_drivers(custom_headers:nil)
      response = get_all_deactivated_drivers_async(custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # /fleet/drivers/inactive
    #
    # Fetch all deactivated drivers for the group.
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_all_deactivated_drivers_with_http_info(custom_headers:nil)
      get_all_deactivated_drivers_async(custom_headers:custom_headers).value!
    end

    #
    # /fleet/drivers/inactive
    #
    # Fetch all deactivated drivers for the group.
    #
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_all_deactivated_drivers_async(custom_headers:nil)
      fail ArgumentError, 'access_token is nil' if access_token.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'fleet/drivers/inactive'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          query_params: {'access_token' => access_token,'group_id' => group_id},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = {
              client_side_validation: true,
              required: false,
              serialized_name: 'parsed_response',
              type: {
                name: 'Sequence',
                element: {
                    client_side_validation: true,
                    required: false,
                    serialized_name: 'CurrentDriverElementType',
                    type: {
                      name: 'Composite',
                      class_name: 'CurrentDriver'
                    }
                }
              }
            }
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # /fleet/drivers/inactive/{driver_id:[0-9]+ | external_id:[a-zA-Z0-9]+}
    #
    # Fetch deactivated driver by id.
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [CurrentDriver] operation results.
    #
    def get_deactivated_driver_by_id(custom_headers:nil)
      response = get_deactivated_driver_by_id_async(custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # /fleet/drivers/inactive/{driver_id:[0-9]+ | external_id:[a-zA-Z0-9]+}
    #
    # Fetch deactivated driver by id.
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_deactivated_driver_by_id_with_http_info(custom_headers:nil)
      get_deactivated_driver_by_id_async(custom_headers:custom_headers).value!
    end

    #
    # /fleet/drivers/inactive/{driver_id:[0-9]+ | external_id:[a-zA-Z0-9]+}
    #
    # Fetch deactivated driver by id.
    #
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_deactivated_driver_by_id_async(custom_headers:nil)
      fail ArgumentError, 'access_token is nil' if access_token.nil?
      fail ArgumentError, 'driver_id_or_external_id is nil' if driver_id_or_external_id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'fleet/drivers/inactive/{driver_id_or_external_id}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'driver_id_or_external_id' => driver_id_or_external_id},
          query_params: {'access_token' => access_token},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Swagger::Models::CurrentDriver.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # /fleet/drivers/inactive/{driver_id:[0-9]+ | external_id:[a-zA-Z0-9]+}
    #
    # Reactivate the inactive driver having id.
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [CurrentDriver] operation results.
    #
    def reactivate_driver_by_id(custom_headers:nil)
      response = reactivate_driver_by_id_async(custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # /fleet/drivers/inactive/{driver_id:[0-9]+ | external_id:[a-zA-Z0-9]+}
    #
    # Reactivate the inactive driver having id.
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def reactivate_driver_by_id_with_http_info(custom_headers:nil)
      reactivate_driver_by_id_async(custom_headers:custom_headers).value!
    end

    #
    # /fleet/drivers/inactive/{driver_id:[0-9]+ | external_id:[a-zA-Z0-9]+}
    #
    # Reactivate the inactive driver having id.
    #
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def reactivate_driver_by_id_async(custom_headers:nil)
      fail ArgumentError, 'reactivate_driver_param is nil' if reactivate_driver_param.nil?
      fail ArgumentError, 'access_token is nil' if access_token.nil?
      fail ArgumentError, 'driver_id_or_external_id is nil' if driver_id_or_external_id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Serialize Request
      request_mapper = Swagger::Models::ReactivateDriverParam.mapper()
      request_content = self.serialize(request_mapper,  reactivate_driver_param)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'fleet/drivers/inactive/{driver_id_or_external_id}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'driver_id_or_external_id' => driver_id_or_external_id},
          query_params: {'access_token' => access_token},
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:put, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Swagger::Models::CurrentDriver.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # /fleet/drivers/{driverId:[0-9]+}/safety/score
    #
    # Fetch the safety score for the driver.
    #
    # @param driver_id [Integer] ID of the driver
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [DriverSafetyScoreResponse] operation results.
    #
    def get_driver_safety_score(driver_id, custom_headers:nil)
      response = get_driver_safety_score_async(driver_id, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # /fleet/drivers/{driverId:[0-9]+}/safety/score
    #
    # Fetch the safety score for the driver.
    #
    # @param driver_id [Integer] ID of the driver
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_driver_safety_score_with_http_info(driver_id, custom_headers:nil)
      get_driver_safety_score_async(driver_id, custom_headers:custom_headers).value!
    end

    #
    # /fleet/drivers/{driverId:[0-9]+}/safety/score
    #
    # Fetch the safety score for the driver.
    #
    # @param driver_id [Integer] ID of the driver
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_driver_safety_score_async(driver_id, custom_headers:nil)
      fail ArgumentError, 'access_token is nil' if access_token.nil?
      fail ArgumentError, 'start_ms is nil' if start_ms.nil?
      fail ArgumentError, 'end_ms is nil' if end_ms.nil?
      fail ArgumentError, 'driver_id is nil' if driver_id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'fleet/drivers/{driverId}/safety/score'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'driverId' => driver_id},
          query_params: {'access_token' => access_token,'startMs' => start_ms,'endMs' => end_ms},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Swagger::Models::DriverSafetyScoreResponse.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # /fleet/drivers/{driver_id:[0-9]+ | external_id:[a-zA-Z0-9]+}
    #
    # Fetch driver by id.
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [CurrentDriver] operation results.
    #
    def get_driver_by_id(custom_headers:nil)
      response = get_driver_by_id_async(custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # /fleet/drivers/{driver_id:[0-9]+ | external_id:[a-zA-Z0-9]+}
    #
    # Fetch driver by id.
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_driver_by_id_with_http_info(custom_headers:nil)
      get_driver_by_id_async(custom_headers:custom_headers).value!
    end

    #
    # /fleet/drivers/{driver_id:[0-9]+ | external_id:[a-zA-Z0-9]+}
    #
    # Fetch driver by id.
    #
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_driver_by_id_async(custom_headers:nil)
      fail ArgumentError, 'access_token is nil' if access_token.nil?
      fail ArgumentError, 'driver_id_or_external_id is nil' if driver_id_or_external_id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'fleet/drivers/{driver_id_or_external_id}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'driver_id_or_external_id' => driver_id_or_external_id},
          query_params: {'access_token' => access_token},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Swagger::Models::CurrentDriver.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # /fleet/drivers/{driver_id:[0-9]+ | external_id:[a-zA-Z0-9]+}
    #
    # Deactivate a driver with the given id.
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    #
    def deactivate_driver(custom_headers:nil)
      response = deactivate_driver_async(custom_headers:custom_headers).value!
      nil
    end

    #
    # /fleet/drivers/{driver_id:[0-9]+ | external_id:[a-zA-Z0-9]+}
    #
    # Deactivate a driver with the given id.
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def deactivate_driver_with_http_info(custom_headers:nil)
      deactivate_driver_async(custom_headers:custom_headers).value!
    end

    #
    # /fleet/drivers/{driver_id:[0-9]+ | external_id:[a-zA-Z0-9]+}
    #
    # Deactivate a driver with the given id.
    #
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def deactivate_driver_async(custom_headers:nil)
      fail ArgumentError, 'access_token is nil' if access_token.nil?
      fail ArgumentError, 'driver_id_or_external_id is nil' if driver_id_or_external_id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'fleet/drivers/{driver_id_or_external_id}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'driver_id_or_external_id' => driver_id_or_external_id},
          query_params: {'access_token' => access_token},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:delete, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # /fleet/drivers/{driver_id:[0-9]+}/dispatch/routes
    #
    # Fetch all of the dispatch routes for a given driver.
    #
    # @param driver_id [Integer] ID of the driver with the associated routes.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array] operation results.
    #
    def get_dispatch_routes_by_driver_id(driver_id, custom_headers:nil)
      response = get_dispatch_routes_by_driver_id_async(driver_id, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # /fleet/drivers/{driver_id:[0-9]+}/dispatch/routes
    #
    # Fetch all of the dispatch routes for a given driver.
    #
    # @param driver_id [Integer] ID of the driver with the associated routes.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_dispatch_routes_by_driver_id_with_http_info(driver_id, custom_headers:nil)
      get_dispatch_routes_by_driver_id_async(driver_id, custom_headers:custom_headers).value!
    end

    #
    # /fleet/drivers/{driver_id:[0-9]+}/dispatch/routes
    #
    # Fetch all of the dispatch routes for a given driver.
    #
    # @param driver_id [Integer] ID of the driver with the associated routes.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_dispatch_routes_by_driver_id_async(driver_id, custom_headers:nil)
      fail ArgumentError, 'access_token is nil' if access_token.nil?
      fail ArgumentError, 'driver_id is nil' if driver_id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'fleet/drivers/{driver_id}/dispatch/routes'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'driver_id' => driver_id},
          query_params: {'end_time' => end_time,'duration' => duration,'access_token' => access_token},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = {
              client_side_validation: true,
              required: false,
              serialized_name: 'parsed_response',
              type: {
                name: 'Sequence',
                element: {
                    client_side_validation: true,
                    required: false,
                    serialized_name: 'DispatchRouteElementType',
                    type: {
                      name: 'Composite',
                      class_name: 'DispatchRoute'
                    }
                }
              }
            }
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # /fleet/drivers/{driver_id:[0-9]+}/dispatch/routes
    #
    # Create a new dispatch route for the driver with driver_id.
    #
    # @param driver_id [Integer] ID of the driver with the associated routes.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [DispatchRoute] operation results.
    #
    def create_driver_dispatch_route(driver_id, custom_headers:nil)
      response = create_driver_dispatch_route_async(driver_id, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # /fleet/drivers/{driver_id:[0-9]+}/dispatch/routes
    #
    # Create a new dispatch route for the driver with driver_id.
    #
    # @param driver_id [Integer] ID of the driver with the associated routes.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def create_driver_dispatch_route_with_http_info(driver_id, custom_headers:nil)
      create_driver_dispatch_route_async(driver_id, custom_headers:custom_headers).value!
    end

    #
    # /fleet/drivers/{driver_id:[0-9]+}/dispatch/routes
    #
    # Create a new dispatch route for the driver with driver_id.
    #
    # @param driver_id [Integer] ID of the driver with the associated routes.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def create_driver_dispatch_route_async(driver_id, custom_headers:nil)
      fail ArgumentError, 'create_dispatch_route_params is nil' if create_dispatch_route_params.nil?
      fail ArgumentError, 'access_token is nil' if access_token.nil?
      fail ArgumentError, 'driver_id is nil' if driver_id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Serialize Request
      request_mapper = Swagger::Models::DispatchRouteCreate.mapper()
      request_content = self.serialize(request_mapper,  create_dispatch_route_params)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'fleet/drivers/{driver_id}/dispatch/routes'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'driver_id' => driver_id},
          query_params: {'access_token' => access_token},
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:post, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Swagger::Models::DispatchRoute.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # /fleet/drivers/{driver_id:[0-9]+}/documents
    #
    # Create a driver document for the given driver.
    #
    # @param driver_id [Integer] ID of the driver for whom the document is created.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Document] operation results.
    #
    def create_driver_document(driver_id, custom_headers:nil)
      response = create_driver_document_async(driver_id, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # /fleet/drivers/{driver_id:[0-9]+}/documents
    #
    # Create a driver document for the given driver.
    #
    # @param driver_id [Integer] ID of the driver for whom the document is created.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def create_driver_document_with_http_info(driver_id, custom_headers:nil)
      create_driver_document_async(driver_id, custom_headers:custom_headers).value!
    end

    #
    # /fleet/drivers/{driver_id:[0-9]+}/documents
    #
    # Create a driver document for the given driver.
    #
    # @param driver_id [Integer] ID of the driver for whom the document is created.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def create_driver_document_async(driver_id, custom_headers:nil)
      fail ArgumentError, 'create_document_params is nil' if create_document_params.nil?
      fail ArgumentError, 'access_token is nil' if access_token.nil?
      fail ArgumentError, 'driver_id is nil' if driver_id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Serialize Request
      request_mapper = Swagger::Models::DocumentCreate.mapper()
      request_content = self.serialize(request_mapper,  create_document_params)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'fleet/drivers/{driver_id}/documents'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'driver_id' => driver_id},
          query_params: {'access_token' => access_token},
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:post, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Swagger::Models::Document.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # /fleet/vehicles/locations
    #
    # Fetch locations for a given vehicle between a start/end time. The maximum
    # query duration is 30 minutes.
    #
    # @param start_ms [Integer] Time in Unix epoch milliseconds for the start of
    # the query (cannot exceed 30 minutes)
    # @param end_ms [Integer] Time in Unix epoch milliseconds for the end of the
    # query (cannot exceed 30 minutes)
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array] operation results.
    #
    def get_vehicles_locations(start_ms, end_ms, custom_headers:nil)
      response = get_vehicles_locations_async(start_ms, end_ms, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # /fleet/vehicles/locations
    #
    # Fetch locations for a given vehicle between a start/end time. The maximum
    # query duration is 30 minutes.
    #
    # @param start_ms [Integer] Time in Unix epoch milliseconds for the start of
    # the query (cannot exceed 30 minutes)
    # @param end_ms [Integer] Time in Unix epoch milliseconds for the end of the
    # query (cannot exceed 30 minutes)
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_vehicles_locations_with_http_info(start_ms, end_ms, custom_headers:nil)
      get_vehicles_locations_async(start_ms, end_ms, custom_headers:custom_headers).value!
    end

    #
    # /fleet/vehicles/locations
    #
    # Fetch locations for a given vehicle between a start/end time. The maximum
    # query duration is 30 minutes.
    #
    # @param start_ms [Integer] Time in Unix epoch milliseconds for the start of
    # the query (cannot exceed 30 minutes)
    # @param end_ms [Integer] Time in Unix epoch milliseconds for the end of the
    # query (cannot exceed 30 minutes)
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_vehicles_locations_async(start_ms, end_ms, custom_headers:nil)
      fail ArgumentError, 'access_token is nil' if access_token.nil?
      fail ArgumentError, 'start_ms is nil' if start_ms.nil?
      fail ArgumentError, 'end_ms is nil' if end_ms.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'fleet/vehicles/locations'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          query_params: {'access_token' => access_token,'startMs' => start_ms,'endMs' => end_ms},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = {
              client_side_validation: true,
              required: false,
              serialized_name: 'parsed_response',
              type: {
                name: 'Sequence',
                element: {
                    client_side_validation: true,
                    required: false,
                    serialized_name: 'FleetVehiclesLocationsItemElementType',
                    type: {
                      name: 'Composite',
                      class_name: 'FleetVehiclesLocationsItem'
                    }
                }
              }
            }
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # /fleet/vehicles/stats
    #
    # Fetch engine state and aux input data for all vehicles in the group between a
    # start/end time. Data returned may be affected by device connectivity and
    # processing time.
    #
    # @param start_ms [Integer] Time in Unix epoch milliseconds for the start of
    # the query.
    # @param end_ms [Integer] Time in Unix epoch milliseconds for the end of the
    # query.
    # @param series [Enum] Comma-separated list of stat types. Options are
    # engineState, auxInput1, and auxInput2. If this parameter is excluded, all 3
    # stat types will be returned. Example: series=engineState,auxInput2. Possible
    # values include: 'engineState', 'auxInput1', 'auxInput2'
    # @param tag_ids [String] Comma-separated list of tag ids. Example:
    # tagIds=1,2,3
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [GetVehicleStatsOKResponse] operation results.
    #
    def get_vehicle_stats(start_ms, end_ms, series:nil, tag_ids:nil, custom_headers:nil)
      response = get_vehicle_stats_async(start_ms, end_ms, series:series, tag_ids:tag_ids, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # /fleet/vehicles/stats
    #
    # Fetch engine state and aux input data for all vehicles in the group between a
    # start/end time. Data returned may be affected by device connectivity and
    # processing time.
    #
    # @param start_ms [Integer] Time in Unix epoch milliseconds for the start of
    # the query.
    # @param end_ms [Integer] Time in Unix epoch milliseconds for the end of the
    # query.
    # @param series [Enum] Comma-separated list of stat types. Options are
    # engineState, auxInput1, and auxInput2. If this parameter is excluded, all 3
    # stat types will be returned. Example: series=engineState,auxInput2. Possible
    # values include: 'engineState', 'auxInput1', 'auxInput2'
    # @param tag_ids [String] Comma-separated list of tag ids. Example:
    # tagIds=1,2,3
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_vehicle_stats_with_http_info(start_ms, end_ms, series:nil, tag_ids:nil, custom_headers:nil)
      get_vehicle_stats_async(start_ms, end_ms, series:series, tag_ids:tag_ids, custom_headers:custom_headers).value!
    end

    #
    # /fleet/vehicles/stats
    #
    # Fetch engine state and aux input data for all vehicles in the group between a
    # start/end time. Data returned may be affected by device connectivity and
    # processing time.
    #
    # @param start_ms [Integer] Time in Unix epoch milliseconds for the start of
    # the query.
    # @param end_ms [Integer] Time in Unix epoch milliseconds for the end of the
    # query.
    # @param series [Enum] Comma-separated list of stat types. Options are
    # engineState, auxInput1, and auxInput2. If this parameter is excluded, all 3
    # stat types will be returned. Example: series=engineState,auxInput2. Possible
    # values include: 'engineState', 'auxInput1', 'auxInput2'
    # @param tag_ids [String] Comma-separated list of tag ids. Example:
    # tagIds=1,2,3
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_vehicle_stats_async(start_ms, end_ms, series:nil, tag_ids:nil, custom_headers:nil)
      fail ArgumentError, 'access_token is nil' if access_token.nil?
      fail ArgumentError, 'start_ms is nil' if start_ms.nil?
      fail ArgumentError, 'end_ms is nil' if end_ms.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'fleet/vehicles/stats'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          query_params: {'access_token' => access_token,'startMs' => start_ms,'endMs' => end_ms,'series' => series,'tagIds' => tag_ids,'startingAfter' => starting_after,'endingBefore' => ending_before,'limit' => limit},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Swagger::Models::GetVehicleStatsOKResponse.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # /fleet/vehicles/{vehicleId:[0-9]+}/safety/harsh_event
    #
    # Fetch harsh event details for a vehicle.
    #
    # @param vehicle_id [Integer] ID of the vehicle
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [VehicleHarshEventResponse] operation results.
    #
    def get_vehicle_harsh_event(vehicle_id, custom_headers:nil)
      response = get_vehicle_harsh_event_async(vehicle_id, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # /fleet/vehicles/{vehicleId:[0-9]+}/safety/harsh_event
    #
    # Fetch harsh event details for a vehicle.
    #
    # @param vehicle_id [Integer] ID of the vehicle
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_vehicle_harsh_event_with_http_info(vehicle_id, custom_headers:nil)
      get_vehicle_harsh_event_async(vehicle_id, custom_headers:custom_headers).value!
    end

    #
    # /fleet/vehicles/{vehicleId:[0-9]+}/safety/harsh_event
    #
    # Fetch harsh event details for a vehicle.
    #
    # @param vehicle_id [Integer] ID of the vehicle
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_vehicle_harsh_event_async(vehicle_id, custom_headers:nil)
      fail ArgumentError, 'access_token is nil' if access_token.nil?
      fail ArgumentError, 'timestamp is nil' if timestamp.nil?
      fail ArgumentError, 'vehicle_id is nil' if vehicle_id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'fleet/vehicles/{vehicleId}/safety/harsh_event'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'vehicleId' => vehicle_id},
          query_params: {'access_token' => access_token,'timestamp' => timestamp},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Swagger::Models::VehicleHarshEventResponse.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # /fleet/vehicles/{vehicleId:[0-9]+}/safety/score
    #
    # Fetch the safety score for the vehicle.
    #
    # @param vehicle_id [Integer] ID of the vehicle
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [VehicleSafetyScoreResponse] operation results.
    #
    def get_vehicle_safety_score(vehicle_id, custom_headers:nil)
      response = get_vehicle_safety_score_async(vehicle_id, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # /fleet/vehicles/{vehicleId:[0-9]+}/safety/score
    #
    # Fetch the safety score for the vehicle.
    #
    # @param vehicle_id [Integer] ID of the vehicle
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_vehicle_safety_score_with_http_info(vehicle_id, custom_headers:nil)
      get_vehicle_safety_score_async(vehicle_id, custom_headers:custom_headers).value!
    end

    #
    # /fleet/vehicles/{vehicleId:[0-9]+}/safety/score
    #
    # Fetch the safety score for the vehicle.
    #
    # @param vehicle_id [Integer] ID of the vehicle
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_vehicle_safety_score_async(vehicle_id, custom_headers:nil)
      fail ArgumentError, 'access_token is nil' if access_token.nil?
      fail ArgumentError, 'start_ms is nil' if start_ms.nil?
      fail ArgumentError, 'end_ms is nil' if end_ms.nil?
      fail ArgumentError, 'vehicle_id is nil' if vehicle_id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'fleet/vehicles/{vehicleId}/safety/score'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'vehicleId' => vehicle_id},
          query_params: {'access_token' => access_token,'startMs' => start_ms,'endMs' => end_ms},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Swagger::Models::VehicleSafetyScoreResponse.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # /fleet/vehicles/{vehicle_id:[0-9]+ | external_id:[a-zA-Z0-9]+}
    #
    # Gets a specific vehicle.
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [FleetVehicleResponse] operation results.
    #
    def get_fleet_vehicle(custom_headers:nil)
      response = get_fleet_vehicle_async(custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # /fleet/vehicles/{vehicle_id:[0-9]+ | external_id:[a-zA-Z0-9]+}
    #
    # Gets a specific vehicle.
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_fleet_vehicle_with_http_info(custom_headers:nil)
      get_fleet_vehicle_async(custom_headers:custom_headers).value!
    end

    #
    # /fleet/vehicles/{vehicle_id:[0-9]+ | external_id:[a-zA-Z0-9]+}
    #
    # Gets a specific vehicle.
    #
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_fleet_vehicle_async(custom_headers:nil)
      fail ArgumentError, 'access_token is nil' if access_token.nil?
      fail ArgumentError, 'vehicle_id_or_external_id is nil' if vehicle_id_or_external_id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'fleet/vehicles/{vehicle_id_or_external_id}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'vehicle_id_or_external_id' => vehicle_id_or_external_id},
          query_params: {'access_token' => access_token},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Swagger::Models::FleetVehicleResponse.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # /fleet/vehicles/{vehicle_id:[0-9]+ | external_id:[a-zA-Z0-9]+}
    #
    # Updates the specified vehicle using JSON merge patch format. See IETF RFC
    # 7396: https://tools.ietf.org/html/rfc7396.
    #
    # @param data [Data]
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [FleetVehicleResponse] operation results.
    #
    def patch_fleet_vehicle(data, custom_headers:nil)
      response = patch_fleet_vehicle_async(data, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # /fleet/vehicles/{vehicle_id:[0-9]+ | external_id:[a-zA-Z0-9]+}
    #
    # Updates the specified vehicle using JSON merge patch format. See IETF RFC
    # 7396: https://tools.ietf.org/html/rfc7396.
    #
    # @param data [Data]
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def patch_fleet_vehicle_with_http_info(data, custom_headers:nil)
      patch_fleet_vehicle_async(data, custom_headers:custom_headers).value!
    end

    #
    # /fleet/vehicles/{vehicle_id:[0-9]+ | external_id:[a-zA-Z0-9]+}
    #
    # Updates the specified vehicle using JSON merge patch format. See IETF RFC
    # 7396: https://tools.ietf.org/html/rfc7396.
    #
    # @param data [Data]
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def patch_fleet_vehicle_async(data, custom_headers:nil)
      fail ArgumentError, 'access_token is nil' if access_token.nil?
      fail ArgumentError, 'vehicle_id_or_external_id is nil' if vehicle_id_or_external_id.nil?
      fail ArgumentError, 'data is nil' if data.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Serialize Request
      request_mapper = Swagger::Models::Data.mapper()
      request_content = self.serialize(request_mapper,  data)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'fleet/vehicles/{vehicle_id_or_external_id}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'vehicle_id_or_external_id' => vehicle_id_or_external_id},
          query_params: {'access_token' => access_token},
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:patch, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Swagger::Models::FleetVehicleResponse.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # /fleet/vehicles/{vehicle_id:[0-9]+}/dispatch/routes
    #
    # Fetch all of the dispatch routes for a given vehicle.
    #
    # @param vehicle_id [Integer] ID of the vehicle with the associated routes.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array] operation results.
    #
    def get_dispatch_routes_by_vehicle_id(vehicle_id, custom_headers:nil)
      response = get_dispatch_routes_by_vehicle_id_async(vehicle_id, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # /fleet/vehicles/{vehicle_id:[0-9]+}/dispatch/routes
    #
    # Fetch all of the dispatch routes for a given vehicle.
    #
    # @param vehicle_id [Integer] ID of the vehicle with the associated routes.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_dispatch_routes_by_vehicle_id_with_http_info(vehicle_id, custom_headers:nil)
      get_dispatch_routes_by_vehicle_id_async(vehicle_id, custom_headers:custom_headers).value!
    end

    #
    # /fleet/vehicles/{vehicle_id:[0-9]+}/dispatch/routes
    #
    # Fetch all of the dispatch routes for a given vehicle.
    #
    # @param vehicle_id [Integer] ID of the vehicle with the associated routes.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_dispatch_routes_by_vehicle_id_async(vehicle_id, custom_headers:nil)
      fail ArgumentError, 'access_token is nil' if access_token.nil?
      fail ArgumentError, 'vehicle_id is nil' if vehicle_id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'fleet/vehicles/{vehicle_id}/dispatch/routes'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'vehicle_id' => vehicle_id},
          query_params: {'end_time' => end_time,'duration' => duration,'access_token' => access_token},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = {
              client_side_validation: true,
              required: false,
              serialized_name: 'parsed_response',
              type: {
                name: 'Sequence',
                element: {
                    client_side_validation: true,
                    required: false,
                    serialized_name: 'DispatchRouteElementType',
                    type: {
                      name: 'Composite',
                      class_name: 'DispatchRoute'
                    }
                }
              }
            }
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # /fleet/vehicles/{vehicle_id:[0-9]+}/dispatch/routes
    #
    # Create a new dispatch route for the vehicle with vehicle_id.
    #
    # @param vehicle_id [Integer] ID of the vehicle with the associated routes.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [DispatchRoute] operation results.
    #
    def create_vehicle_dispatch_route(vehicle_id, custom_headers:nil)
      response = create_vehicle_dispatch_route_async(vehicle_id, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # /fleet/vehicles/{vehicle_id:[0-9]+}/dispatch/routes
    #
    # Create a new dispatch route for the vehicle with vehicle_id.
    #
    # @param vehicle_id [Integer] ID of the vehicle with the associated routes.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def create_vehicle_dispatch_route_with_http_info(vehicle_id, custom_headers:nil)
      create_vehicle_dispatch_route_async(vehicle_id, custom_headers:custom_headers).value!
    end

    #
    # /fleet/vehicles/{vehicle_id:[0-9]+}/dispatch/routes
    #
    # Create a new dispatch route for the vehicle with vehicle_id.
    #
    # @param vehicle_id [Integer] ID of the vehicle with the associated routes.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def create_vehicle_dispatch_route_async(vehicle_id, custom_headers:nil)
      fail ArgumentError, 'create_dispatch_route_params is nil' if create_dispatch_route_params.nil?
      fail ArgumentError, 'access_token is nil' if access_token.nil?
      fail ArgumentError, 'vehicle_id is nil' if vehicle_id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Serialize Request
      request_mapper = Swagger::Models::DispatchRouteCreate.mapper()
      request_content = self.serialize(request_mapper,  create_dispatch_route_params)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'fleet/vehicles/{vehicle_id}/dispatch/routes'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'vehicle_id' => vehicle_id},
          query_params: {'access_token' => access_token},
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:post, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Swagger::Models::DispatchRoute.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # /fleet/vehicles/{vehicle_id:[0-9]+}/locations
    #
    # Fetch locations for a given vehicle between a start/end time. The maximum
    # query duration is one hour.
    #
    # @param vehicle_id [Integer] ID of the vehicle with the associated routes.
    # @param start_ms [Integer] Time in Unix epoch milliseconds for the start of
    # the query (cannot exceed 1 hour)
    # @param end_ms [Integer] Time in Unix epoch milliseconds for the end of the
    # query (cannot exceed 1 hour)
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array] operation results.
    #
    def get_vehicle_locations(vehicle_id, start_ms, end_ms, custom_headers:nil)
      response = get_vehicle_locations_async(vehicle_id, start_ms, end_ms, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # /fleet/vehicles/{vehicle_id:[0-9]+}/locations
    #
    # Fetch locations for a given vehicle between a start/end time. The maximum
    # query duration is one hour.
    #
    # @param vehicle_id [Integer] ID of the vehicle with the associated routes.
    # @param start_ms [Integer] Time in Unix epoch milliseconds for the start of
    # the query (cannot exceed 1 hour)
    # @param end_ms [Integer] Time in Unix epoch milliseconds for the end of the
    # query (cannot exceed 1 hour)
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_vehicle_locations_with_http_info(vehicle_id, start_ms, end_ms, custom_headers:nil)
      get_vehicle_locations_async(vehicle_id, start_ms, end_ms, custom_headers:custom_headers).value!
    end

    #
    # /fleet/vehicles/{vehicle_id:[0-9]+}/locations
    #
    # Fetch locations for a given vehicle between a start/end time. The maximum
    # query duration is one hour.
    #
    # @param vehicle_id [Integer] ID of the vehicle with the associated routes.
    # @param start_ms [Integer] Time in Unix epoch milliseconds for the start of
    # the query (cannot exceed 1 hour)
    # @param end_ms [Integer] Time in Unix epoch milliseconds for the end of the
    # query (cannot exceed 1 hour)
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_vehicle_locations_async(vehicle_id, start_ms, end_ms, custom_headers:nil)
      fail ArgumentError, 'access_token is nil' if access_token.nil?
      fail ArgumentError, 'vehicle_id is nil' if vehicle_id.nil?
      fail ArgumentError, 'start_ms is nil' if start_ms.nil?
      fail ArgumentError, 'end_ms is nil' if end_ms.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'fleet/vehicles/{vehicle_id}/locations'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'vehicle_id' => vehicle_id},
          query_params: {'access_token' => access_token,'startMs' => start_ms,'endMs' => end_ms},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = {
              client_side_validation: true,
              required: false,
              serialized_name: 'parsed_response',
              type: {
                name: 'Sequence',
                element: {
                    client_side_validation: true,
                    required: false,
                    serialized_name: 'FleetVehicleLocationElementType',
                    type: {
                      name: 'Composite',
                      class_name: 'FleetVehicleLocation'
                    }
                }
              }
            }
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # /industrial/data
    #
    # Fetch all of the data inputs for a group.
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [GetAllDataInputsOKResponse] operation results.
    #
    def get_all_data_inputs(custom_headers:nil)
      response = get_all_data_inputs_async(custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # /industrial/data
    #
    # Fetch all of the data inputs for a group.
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_all_data_inputs_with_http_info(custom_headers:nil)
      get_all_data_inputs_async(custom_headers:custom_headers).value!
    end

    #
    # /industrial/data
    #
    # Fetch all of the data inputs for a group.
    #
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_all_data_inputs_async(custom_headers:nil)
      fail ArgumentError, 'access_token is nil' if access_token.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'industrial/data'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          query_params: {'access_token' => access_token,'group_id' => group_id,'startMs' => start_ms,'endMs' => end_ms},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Swagger::Models::GetAllDataInputsOKResponse.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # /industrial/data/{data_input_id:[0-9]+}
    #
    # Fetch datapoints from a given data input.
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [DataInputHistoryResponse] operation results.
    #
    def get_data_input(custom_headers:nil)
      response = get_data_input_async(custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # /industrial/data/{data_input_id:[0-9]+}
    #
    # Fetch datapoints from a given data input.
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_data_input_with_http_info(custom_headers:nil)
      get_data_input_async(custom_headers:custom_headers).value!
    end

    #
    # /industrial/data/{data_input_id:[0-9]+}
    #
    # Fetch datapoints from a given data input.
    #
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_data_input_async(custom_headers:nil)
      fail ArgumentError, 'access_token is nil' if access_token.nil?
      fail ArgumentError, 'data_input_id is nil' if data_input_id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'industrial/data/{data_input_id}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'data_input_id' => data_input_id},
          query_params: {'access_token' => access_token,'startMs' => start_ms,'endMs' => end_ms},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Swagger::Models::DataInputHistoryResponse.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # /tags
    #
    # Fetch all of the tags for a group.
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [GetAllTagsOKResponse] operation results.
    #
    def get_all_tags(custom_headers:nil)
      response = get_all_tags_async(custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # /tags
    #
    # Fetch all of the tags for a group.
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_all_tags_with_http_info(custom_headers:nil)
      get_all_tags_async(custom_headers:custom_headers).value!
    end

    #
    # /tags
    #
    # Fetch all of the tags for a group.
    #
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_all_tags_async(custom_headers:nil)
      fail ArgumentError, 'access_token is nil' if access_token.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'tags'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          query_params: {'access_token' => access_token,'group_id' => group_id},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Swagger::Models::GetAllTagsOKResponse.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # /tags
    #
    # Create a new tag for the group.
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Tag] operation results.
    #
    def create_tag(custom_headers:nil)
      response = create_tag_async(custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # /tags
    #
    # Create a new tag for the group.
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def create_tag_with_http_info(custom_headers:nil)
      create_tag_async(custom_headers:custom_headers).value!
    end

    #
    # /tags
    #
    # Create a new tag for the group.
    #
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def create_tag_async(custom_headers:nil)
      fail ArgumentError, 'access_token is nil' if access_token.nil?
      fail ArgumentError, 'tag_create_params is nil' if tag_create_params.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Serialize Request
      request_mapper = Swagger::Models::TagCreate.mapper()
      request_content = self.serialize(request_mapper,  tag_create_params)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'tags'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          query_params: {'access_token' => access_token},
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:post, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Swagger::Models::Tag.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # /tags/{tag_id:[0-9]+}
    #
    # Fetch a tag by id.
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Tag] operation results.
    #
    def get_tag_by_id(custom_headers:nil)
      response = get_tag_by_id_async(custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # /tags/{tag_id:[0-9]+}
    #
    # Fetch a tag by id.
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_tag_by_id_with_http_info(custom_headers:nil)
      get_tag_by_id_async(custom_headers:custom_headers).value!
    end

    #
    # /tags/{tag_id:[0-9]+}
    #
    # Fetch a tag by id.
    #
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_tag_by_id_async(custom_headers:nil)
      fail ArgumentError, 'access_token is nil' if access_token.nil?
      fail ArgumentError, 'tag_id is nil' if tag_id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'tags/{tag_id}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'tag_id' => tag_id},
          query_params: {'access_token' => access_token},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Swagger::Models::Tag.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # /tags/{tag_id:[0-9]+}
    #
    # Update a tag with a new name and new members. This API call would replace all
    # old members of a tag with new members specified in the request body. To
    # modify only a few devices associated with a tag use the PATCH endpoint.
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Tag] operation results.
    #
    def update_tag_by_id(custom_headers:nil)
      response = update_tag_by_id_async(custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # /tags/{tag_id:[0-9]+}
    #
    # Update a tag with a new name and new members. This API call would replace all
    # old members of a tag with new members specified in the request body. To
    # modify only a few devices associated with a tag use the PATCH endpoint.
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def update_tag_by_id_with_http_info(custom_headers:nil)
      update_tag_by_id_async(custom_headers:custom_headers).value!
    end

    #
    # /tags/{tag_id:[0-9]+}
    #
    # Update a tag with a new name and new members. This API call would replace all
    # old members of a tag with new members specified in the request body. To
    # modify only a few devices associated with a tag use the PATCH endpoint.
    #
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def update_tag_by_id_async(custom_headers:nil)
      fail ArgumentError, 'access_token is nil' if access_token.nil?
      fail ArgumentError, 'tag_id is nil' if tag_id.nil?
      fail ArgumentError, 'update_tag_params is nil' if update_tag_params.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Serialize Request
      request_mapper = Swagger::Models::TagUpdate.mapper()
      request_content = self.serialize(request_mapper,  update_tag_params)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'tags/{tag_id}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'tag_id' => tag_id},
          query_params: {'access_token' => access_token},
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:put, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Swagger::Models::Tag.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # /tags/{tag_id:[0-9]+}
    #
    # Permanently deletes a tag.
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    #
    def delete_tag_by_id(custom_headers:nil)
      response = delete_tag_by_id_async(custom_headers:custom_headers).value!
      nil
    end

    #
    # /tags/{tag_id:[0-9]+}
    #
    # Permanently deletes a tag.
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def delete_tag_by_id_with_http_info(custom_headers:nil)
      delete_tag_by_id_async(custom_headers:custom_headers).value!
    end

    #
    # /tags/{tag_id:[0-9]+}
    #
    # Permanently deletes a tag.
    #
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def delete_tag_by_id_async(custom_headers:nil)
      fail ArgumentError, 'access_token is nil' if access_token.nil?
      fail ArgumentError, 'tag_id is nil' if tag_id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'tags/{tag_id}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'tag_id' => tag_id},
          query_params: {'access_token' => access_token},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:delete, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end

    #
    # /tags/{tag_id:[0-9]+}
    #
    # Add or delete specific members from a tag, or modify the name of a tag.
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Tag] operation results.
    #
    def modify_tag_by_id(custom_headers:nil)
      response = modify_tag_by_id_async(custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # /tags/{tag_id:[0-9]+}
    #
    # Add or delete specific members from a tag, or modify the name of a tag.
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def modify_tag_by_id_with_http_info(custom_headers:nil)
      modify_tag_by_id_async(custom_headers:custom_headers).value!
    end

    #
    # /tags/{tag_id:[0-9]+}
    #
    # Add or delete specific members from a tag, or modify the name of a tag.
    #
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def modify_tag_by_id_async(custom_headers:nil)
      fail ArgumentError, 'access_token is nil' if access_token.nil?
      fail ArgumentError, 'tag_id is nil' if tag_id.nil?
      fail ArgumentError, 'tag_modify_params is nil' if tag_modify_params.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Serialize Request
      request_mapper = Swagger::Models::TagModify.mapper()
      request_content = self.serialize(request_mapper,  tag_modify_params)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'tags/{tag_id}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'tag_id' => tag_id},
          query_params: {'access_token' => access_token},
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:patch, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Swagger::Models::Tag.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # /user_roles
    #
    # Get all roles in the organization.
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [Array] operation results.
    #
    def list_user_roles(custom_headers:nil)
      response = list_user_roles_async(custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # /user_roles
    #
    # Get all roles in the organization.
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def list_user_roles_with_http_info(custom_headers:nil)
      list_user_roles_async(custom_headers:custom_headers).value!
    end

    #
    # /user_roles
    #
    # Get all roles in the organization.
    #
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def list_user_roles_async(custom_headers:nil)
      fail ArgumentError, 'access_token is nil' if access_token.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'user_roles'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          query_params: {'access_token' => access_token},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = {
              client_side_validation: true,
              required: false,
              serialized_name: 'parsed_response',
              type: {
                name: 'Sequence',
                element: {
                    client_side_validation: true,
                    required: false,
                    serialized_name: 'UserRoleElementType',
                    type: {
                      name: 'Composite',
                      class_name: 'UserRole'
                    }
                }
              }
            }
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # /users/{userId:[0-9]+}
    #
    # Get a user.
    #
    # @param user_id [Integer] ID of the user.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [User] operation results.
    #
    def get_user_by_id(user_id, custom_headers:nil)
      response = get_user_by_id_async(user_id, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # /users/{userId:[0-9]+}
    #
    # Get a user.
    #
    # @param user_id [Integer] ID of the user.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def get_user_by_id_with_http_info(user_id, custom_headers:nil)
      get_user_by_id_async(user_id, custom_headers:custom_headers).value!
    end

    #
    # /users/{userId:[0-9]+}
    #
    # Get a user.
    #
    # @param user_id [Integer] ID of the user.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def get_user_by_id_async(user_id, custom_headers:nil)
      fail ArgumentError, 'access_token is nil' if access_token.nil?
      fail ArgumentError, 'user_id is nil' if user_id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'users/{userId}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'userId' => user_id},
          query_params: {'access_token' => access_token},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Swagger::Models::User.mapper()
            result.body = self.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # /users/{userId:[0-9]+}
    #
    # Remove a user from the organization.
    #
    # @param user_id [Integer] ID of the user.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    #
    def delete_user_by_id(user_id, custom_headers:nil)
      response = delete_user_by_id_async(user_id, custom_headers:custom_headers).value!
      nil
    end

    #
    # /users/{userId:[0-9]+}
    #
    # Remove a user from the organization.
    #
    # @param user_id [Integer] ID of the user.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def delete_user_by_id_with_http_info(user_id, custom_headers:nil)
      delete_user_by_id_async(user_id, custom_headers:custom_headers).value!
    end

    #
    # /users/{userId:[0-9]+}
    #
    # Remove a user from the organization.
    #
    # @param user_id [Integer] ID of the user.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def delete_user_by_id_async(user_id, custom_headers:nil)
      fail ArgumentError, 'access_token is nil' if access_token.nil?
      fail ArgumentError, 'user_id is nil' if user_id.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'users/{userId}'

      request_url = @base_url || self.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'userId' => user_id},
          query_params: {'access_token' => access_token},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = self.make_request_async(:delete, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end


        result
      end

      promise.execute
    end


    private
    #
    # Adds telemetry information.
    #
    def add_telemetry
        sdk_information = 'swagger'
        add_user_agent_information(sdk_information)
    end
  end
end
