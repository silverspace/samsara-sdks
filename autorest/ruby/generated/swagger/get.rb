# encoding: utf-8
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is
# regenerated.

module Swagger
  #
  # # Introduction
  #
  # Samsara provides API endpoints for interacting with Samsara Cloud, so that
  # you can build powerful applications and custom solutions with sensor data.
  # Samsara has endpoints available to track and analyze sensors, vehicles, and
  # entire fleets.
  #
  # The Samsara Cloud API is a [RESTful
  # API](https://en.wikipedia.org/wiki/Representational_state_transfer)
  # accessed by an
  # [HTTP](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol) client
  # such as wget or curl, or HTTP libraries of most modern programming
  # languages including python, ruby, java. We use built-in HTTP features, like
  # HTTP authentication and HTTP verbs, which are understood by off-the-shelf
  # HTTP clients. We allow you to interact securely with our API from a
  # client-side web application (though you should never expose your secret API
  # key). [JSON](http://www.json.org/) is returned by all API responses,
  # including errors. If you’re familiar with what you can build with a REST
  # API, the following API reference guide will be your go-to resource.
  #
  # API access to the Samsara cloud is available to all Samsara administrators.
  # To start developing with Samsara APIs you will need to [obtain your API
  # keys](#section/Authentication) to authenticate your API requests.
  #
  # If you have any questions you can reach out to us on
  # [support@samsara.com](mailto:support@samsara.com)
  #
  # # Endpoints
  #
  # All our APIs can be accessed through HTTP requests to URLs like:
  #
  # ```curl
  # https://api.samsara.com/<version>/<endpoint>
  # ```
  #
  # All our APIs are [versioned](#section/Versioning). If we intend to make
  # breaking changes to an API which either changes the response format or
  # request parameter, we will increment the version.
  #
  # # Authentication
  #
  # To authenticate your API request you will need to include your secret
  # token. You can manage your API tokens in the
  # [Dashboard](https://cloud.samsara.com). They are visible under
  # `Settings->Organization->API Tokens`.
  #
  # Your API tokens carry many privileges, so be sure to keep them secure. Do
  # not share your secret API tokens in publicly accessible areas such as
  # GitHub, client-side code, and so on.
  #
  # Authentication to the API is performed via [HTTP Basic
  # Auth](https://en.wikipedia.org/wiki/Basic_access_authentication). Provide
  # your API token as the basic access_token value in the URL. You do not need
  # to provide a password.
  #
  # ```curl
  # https://api.samsara.com/<version>/<endpoint>?access_token={access_token}
  # ```
  #
  # All API requests must be made over
  # [HTTPS](https://en.wikipedia.org/wiki/HTTPS). Calls made over plain HTTP or
  # without authentication will fail.
  #
  # # Request Methods
  #
  # Our API endpoints use [HTTP request
  # methods](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Request_methods)
  # to specify the desired operation to be performed. The documentation below
  # specified request method supported by each endpoint and the resulting
  # action.
  #
  # ## GET
  #
  # GET requests are typically used for fetching data (like data for a
  # particular driver).
  #
  # ## POST
  #
  # POST requests are typically used for creating or updating a record (like
  # adding new tags to the system). With that being said, a few of our POST
  # requests can be used for fetching data (like current location data of your
  # fleet).
  #
  # ## PUT
  #
  # PUT requests are typically used for updating an existing record (like
  # updating all devices associated with a particular tag).
  #
  # ## PATCH
  #
  # PATCH requests are typically used for modifying an existing record (like
  # modifying a few devices associated with a particular tag).
  #
  # ## DELETE
  #
  # DELETE requests are used for deleting a record (like deleting a tag from
  # the system).
  #
  # # Response Codes
  #
  # All API requests will respond with appropriate [HTTP status
  # code](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes). Your API
  # client should handle each response class differently.
  #
  # ## 2XX
  #
  # These are successful responses and indicate that the API request returned
  # the expected response.
  #
  # ## 4XX
  #
  # These indicate that there was a problem with the request like a missing
  # parameter or invalid values. Check the response for specific [error
  # details](#section/Error-Responses). Requests that respond with a 4XX status
  # code, should be modified before retrying.
  #
  # ## 5XX
  #
  # These indicate server errors when the server is unreachable or is
  # misconfigured. In this case, you should retry the API request after some
  # delay.
  #
  # # Error Responses
  #
  # In case of a 4XX status code, the body of the response will contain
  # information to briefly explain the error reported. To help debugging the
  # error, you can refer to the following table for understanding the error
  # message.
  #
  # | Status Code | Message | Description |
  # |-------------|----------------|-------------------------------------------------------------------|
  # | 401 | Invalid token | The API token is invalid and could not be
  # authenticated. Please refer to the [authentication
  # section](#section/Authentication). |
  # | 404 | Page not found | The API endpoint being accessed is invalid. |
  # | 400 | Bad request | Default response for an invalid request. Please check
  # the request to make sure it follows the format specified in the
  # documentation. |
  #
  # # Versioning
  #
  # All our APIs are versioned. Our current API version is `v1` and we are
  # continuously working on improving it further and provide additional
  # endpoints. If we intend to make breaking changes to an API which either
  # changes the response format or request parameter, we will increment the
  # version. Thus, you can use our current API version worry free.
  #
  # # FAQs
  #
  # Check out our [responses to FAQs
  # here](https://kb.samsara.com/hc/en-us/sections/360000538054-APIs). Don’t
  # see an answer to your question? Reach out to us on
  # [support@samsara.com](mailto:support@samsara.com).
  #
  class Get

    #
    # Creates and initializes a new instance of the Get class.
    # @param client service class for accessing basic functionality.
    #
    def initialize(client)
      @client = client
    end

    # @return [SamsaraAPI] reference to the SamsaraAPI
    attr_reader :client

    #
    # /fleet/drivers
    #
    # Get all the drivers for the specified group.
    #
    # @param group_drivers_param [GroupDriversParam]
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [DriversResponse] operation results.
    #
    def drivers(group_drivers_param, custom_headers:nil)
      response = drivers_async(group_drivers_param, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # /fleet/drivers
    #
    # Get all the drivers for the specified group.
    #
    # @param group_drivers_param [GroupDriversParam]
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def drivers_with_http_info(group_drivers_param, custom_headers:nil)
      drivers_async(group_drivers_param, custom_headers:custom_headers).value!
    end

    #
    # /fleet/drivers
    #
    # Get all the drivers for the specified group.
    #
    # @param group_drivers_param [GroupDriversParam]
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def drivers_async(group_drivers_param, custom_headers:nil)
      fail ArgumentError, '@client.access_token is nil' if @client.access_token.nil?
      fail ArgumentError, 'group_drivers_param is nil' if group_drivers_param.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Serialize Request
      request_mapper = Swagger::Models::GroupDriversParam.mapper()
      request_content = @client.serialize(request_mapper,  group_drivers_param)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'fleet/drivers'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          query_params: {'access_token' => @client.access_token},
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:post, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Swagger::Models::DriversResponse.mapper()
            result.body = @client.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # /fleet/drivers/summary
    #
    # Get the distance and time each driver in an organization has driven in a
    # given time period.
    #
    # @param drivers_summary_param [DriversSummaryParam] Org ID and time range to
    # query.
    # @param snap_to_day_bounds [Boolean] Snap query result to HOS day boundaries.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [DriversSummaryResponse] operation results.
    #
    def summary(drivers_summary_param, snap_to_day_bounds:nil, custom_headers:nil)
      response = summary_async(drivers_summary_param, snap_to_day_bounds:snap_to_day_bounds, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # /fleet/drivers/summary
    #
    # Get the distance and time each driver in an organization has driven in a
    # given time period.
    #
    # @param drivers_summary_param [DriversSummaryParam] Org ID and time range to
    # query.
    # @param snap_to_day_bounds [Boolean] Snap query result to HOS day boundaries.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def summary_with_http_info(drivers_summary_param, snap_to_day_bounds:nil, custom_headers:nil)
      summary_async(drivers_summary_param, snap_to_day_bounds:snap_to_day_bounds, custom_headers:custom_headers).value!
    end

    #
    # /fleet/drivers/summary
    #
    # Get the distance and time each driver in an organization has driven in a
    # given time period.
    #
    # @param drivers_summary_param [DriversSummaryParam] Org ID and time range to
    # query.
    # @param snap_to_day_bounds [Boolean] Snap query result to HOS day boundaries.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def summary_async(drivers_summary_param, snap_to_day_bounds:nil, custom_headers:nil)
      fail ArgumentError, '@client.access_token is nil' if @client.access_token.nil?
      fail ArgumentError, 'drivers_summary_param is nil' if drivers_summary_param.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Serialize Request
      request_mapper = Swagger::Models::DriversSummaryParam.mapper()
      request_content = @client.serialize(request_mapper,  drivers_summary_param)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'fleet/drivers/summary'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          query_params: {'access_token' => @client.access_token,'snap_to_day_bounds' => snap_to_day_bounds},
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:post, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Swagger::Models::DriversSummaryResponse.mapper()
            result.body = @client.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # /fleet/drivers/{driver_id:[0-9]+}/hos_daily_logs
    #
    # Get summarized daily HOS charts for a specified driver.
    #
    # @param driver_id [Integer] ID of the driver with HOS logs.
    # @param hos_logs_param [HosLogsParam]
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [DriverDailyLogResponse] operation results.
    #
    def logs(driver_id, hos_logs_param, custom_headers:nil)
      response = logs_async(driver_id, hos_logs_param, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # /fleet/drivers/{driver_id:[0-9]+}/hos_daily_logs
    #
    # Get summarized daily HOS charts for a specified driver.
    #
    # @param driver_id [Integer] ID of the driver with HOS logs.
    # @param hos_logs_param [HosLogsParam]
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def logs_with_http_info(driver_id, hos_logs_param, custom_headers:nil)
      logs_async(driver_id, hos_logs_param, custom_headers:custom_headers).value!
    end

    #
    # /fleet/drivers/{driver_id:[0-9]+}/hos_daily_logs
    #
    # Get summarized daily HOS charts for a specified driver.
    #
    # @param driver_id [Integer] ID of the driver with HOS logs.
    # @param hos_logs_param [HosLogsParam]
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def logs_async(driver_id, hos_logs_param, custom_headers:nil)
      fail ArgumentError, '@client.access_token is nil' if @client.access_token.nil?
      fail ArgumentError, 'driver_id is nil' if driver_id.nil?
      fail ArgumentError, 'hos_logs_param is nil' if hos_logs_param.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Serialize Request
      request_mapper = Swagger::Models::HosLogsParam.mapper()
      request_content = @client.serialize(request_mapper,  hos_logs_param)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'fleet/drivers/{driver_id}/hos_daily_logs'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          path_params: {'driver_id' => driver_id},
          query_params: {'access_token' => @client.access_token},
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:post, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Swagger::Models::DriverDailyLogResponse.mapper()
            result.body = @client.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # /fleet/hos_authentication_logs
    #
    # Get the HOS (hours of service) signin and signout logs for the specified
    # driver. Only signout logs include location information.
    #
    # @param hos_authentication_logs_param [HosAuthenticationLogsParam]
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [HosAuthenticationLogsResponse] operation results.
    #
    def logs1(hos_authentication_logs_param, custom_headers:nil)
      response = logs1_async(hos_authentication_logs_param, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # /fleet/hos_authentication_logs
    #
    # Get the HOS (hours of service) signin and signout logs for the specified
    # driver. Only signout logs include location information.
    #
    # @param hos_authentication_logs_param [HosAuthenticationLogsParam]
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def logs1_with_http_info(hos_authentication_logs_param, custom_headers:nil)
      logs1_async(hos_authentication_logs_param, custom_headers:custom_headers).value!
    end

    #
    # /fleet/hos_authentication_logs
    #
    # Get the HOS (hours of service) signin and signout logs for the specified
    # driver. Only signout logs include location information.
    #
    # @param hos_authentication_logs_param [HosAuthenticationLogsParam]
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def logs1_async(hos_authentication_logs_param, custom_headers:nil)
      fail ArgumentError, '@client.access_token is nil' if @client.access_token.nil?
      fail ArgumentError, 'hos_authentication_logs_param is nil' if hos_authentication_logs_param.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Serialize Request
      request_mapper = Swagger::Models::HosAuthenticationLogsParam.mapper()
      request_content = @client.serialize(request_mapper,  hos_authentication_logs_param)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'fleet/hos_authentication_logs'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          query_params: {'access_token' => @client.access_token},
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:post, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Swagger::Models::HosAuthenticationLogsResponse.mapper()
            result.body = @client.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # /fleet/hos_logs
    #
    # Get the HOS (hours of service) logs for the specified driver. This method
    # returns all the HOS statuses that the driver was in during this time period.
    #
    # @param hos_logs_param [HosLogsParam]
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [HosLogsResponse] operation results.
    #
    def logs2(hos_logs_param, custom_headers:nil)
      response = logs2_async(hos_logs_param, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # /fleet/hos_logs
    #
    # Get the HOS (hours of service) logs for the specified driver. This method
    # returns all the HOS statuses that the driver was in during this time period.
    #
    # @param hos_logs_param [HosLogsParam]
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def logs2_with_http_info(hos_logs_param, custom_headers:nil)
      logs2_async(hos_logs_param, custom_headers:custom_headers).value!
    end

    #
    # /fleet/hos_logs
    #
    # Get the HOS (hours of service) logs for the specified driver. This method
    # returns all the HOS statuses that the driver was in during this time period.
    #
    # @param hos_logs_param [HosLogsParam]
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def logs2_async(hos_logs_param, custom_headers:nil)
      fail ArgumentError, '@client.access_token is nil' if @client.access_token.nil?
      fail ArgumentError, 'hos_logs_param is nil' if hos_logs_param.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Serialize Request
      request_mapper = Swagger::Models::HosLogsParam.mapper()
      request_content = @client.serialize(request_mapper,  hos_logs_param)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'fleet/hos_logs'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          query_params: {'access_token' => @client.access_token},
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:post, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Swagger::Models::HosLogsResponse.mapper()
            result.body = @client.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # /fleet/hos_logs_summary
    #
    # Get the current HOS status for all drivers in the group.
    #
    # @param hos_logs_param [HosLogsParamModel]
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [HosLogsSummaryResponse] operation results.
    #
    def summary1(hos_logs_param, custom_headers:nil)
      response = summary1_async(hos_logs_param, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # /fleet/hos_logs_summary
    #
    # Get the current HOS status for all drivers in the group.
    #
    # @param hos_logs_param [HosLogsParamModel]
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def summary1_with_http_info(hos_logs_param, custom_headers:nil)
      summary1_async(hos_logs_param, custom_headers:custom_headers).value!
    end

    #
    # /fleet/hos_logs_summary
    #
    # Get the current HOS status for all drivers in the group.
    #
    # @param hos_logs_param [HosLogsParamModel]
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def summary1_async(hos_logs_param, custom_headers:nil)
      fail ArgumentError, '@client.access_token is nil' if @client.access_token.nil?
      fail ArgumentError, 'hos_logs_param is nil' if hos_logs_param.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Serialize Request
      request_mapper = Swagger::Models::HosLogsParamModel.mapper()
      request_content = @client.serialize(request_mapper,  hos_logs_param)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'fleet/hos_logs_summary'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          query_params: {'access_token' => @client.access_token},
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:post, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Swagger::Models::HosLogsSummaryResponse.mapper()
            result.body = @client.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # /fleet/locations
    #
    # Get current location of vehicles in a group. This method returns the current
    # location in latitude and longitude of all vehicles in a requested group.
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [LocationsOKResponse] operation results.
    #
    def locations(custom_headers:nil)
      response = locations_async(custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # /fleet/locations
    #
    # Get current location of vehicles in a group. This method returns the current
    # location in latitude and longitude of all vehicles in a requested group.
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def locations_with_http_info(custom_headers:nil)
      locations_async(custom_headers:custom_headers).value!
    end

    #
    # /fleet/locations
    #
    # Get current location of vehicles in a group. This method returns the current
    # location in latitude and longitude of all vehicles in a requested group.
    #
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def locations_async(custom_headers:nil)
      fail ArgumentError, '@client.access_token is nil' if @client.access_token.nil?
      fail ArgumentError, '@client.group_param is nil' if @client.group_param.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Serialize Request
      request_mapper = Swagger::Models::GroupParam.mapper()
      request_content = @client.serialize(request_mapper,  @client.group_param)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'fleet/locations'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          query_params: {'access_token' => @client.access_token},
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:post, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Swagger::Models::LocationsOKResponse.mapper()
            result.body = @client.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # /fleet/maintenance/dvirs
    #
    # Get DVIRs for the org within provided time constraints
    #
    # @param end_ms [Integer] time in millis until the last dvir log.
    # @param duration_ms [Integer] time in millis which corresponds to the duration
    # before the end_ms.
    # @param group_id [Integer] Group ID to query.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [DvirListResponse] operation results.
    #
    def dvirs(end_ms, duration_ms, group_id:nil, custom_headers:nil)
      response = dvirs_async(end_ms, duration_ms, group_id:group_id, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # /fleet/maintenance/dvirs
    #
    # Get DVIRs for the org within provided time constraints
    #
    # @param end_ms [Integer] time in millis until the last dvir log.
    # @param duration_ms [Integer] time in millis which corresponds to the duration
    # before the end_ms.
    # @param group_id [Integer] Group ID to query.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def dvirs_with_http_info(end_ms, duration_ms, group_id:nil, custom_headers:nil)
      dvirs_async(end_ms, duration_ms, group_id:group_id, custom_headers:custom_headers).value!
    end

    #
    # /fleet/maintenance/dvirs
    #
    # Get DVIRs for the org within provided time constraints
    #
    # @param end_ms [Integer] time in millis until the last dvir log.
    # @param duration_ms [Integer] time in millis which corresponds to the duration
    # before the end_ms.
    # @param group_id [Integer] Group ID to query.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def dvirs_async(end_ms, duration_ms, group_id:nil, custom_headers:nil)
      fail ArgumentError, '@client.access_token is nil' if @client.access_token.nil?
      fail ArgumentError, 'end_ms is nil' if end_ms.nil?
      fail ArgumentError, 'duration_ms is nil' if duration_ms.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'
      path_template = 'fleet/maintenance/dvirs'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          query_params: {'access_token' => @client.access_token,'end_ms' => end_ms,'duration_ms' => duration_ms,'group_id' => group_id},
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:get, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Swagger::Models::DvirListResponse.mapper()
            result.body = @client.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # /fleet/maintenance/list
    #
    # Get list of the vehicles with any engine faults or check light data.
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [ListOKResponse] operation results.
    #
    def list_method(custom_headers:nil)
      response = list_method_async(custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # /fleet/maintenance/list
    #
    # Get list of the vehicles with any engine faults or check light data.
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def list_method_with_http_info(custom_headers:nil)
      list_method_async(custom_headers:custom_headers).value!
    end

    #
    # /fleet/maintenance/list
    #
    # Get list of the vehicles with any engine faults or check light data.
    #
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def list_method_async(custom_headers:nil)
      fail ArgumentError, '@client.access_token is nil' if @client.access_token.nil?
      fail ArgumentError, '@client.group_param is nil' if @client.group_param.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Serialize Request
      request_mapper = Swagger::Models::GroupParam.mapper()
      request_content = @client.serialize(request_mapper,  @client.group_param)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'fleet/maintenance/list'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          query_params: {'access_token' => @client.access_token},
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:post, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Swagger::Models::ListOKResponse.mapper()
            result.body = @client.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # /fleet/trips
    #
    # Get historical trips data for specified vehicle. This method returns a set of
    # historical trips data for the specified vehicle in the specified time range.
    #
    # @param trips_param [TripsParam] Group ID, vehicle ID and time range to query.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [TripResponse] operation results.
    #
    def trips(trips_param, custom_headers:nil)
      response = trips_async(trips_param, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # /fleet/trips
    #
    # Get historical trips data for specified vehicle. This method returns a set of
    # historical trips data for the specified vehicle in the specified time range.
    #
    # @param trips_param [TripsParam] Group ID, vehicle ID and time range to query.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def trips_with_http_info(trips_param, custom_headers:nil)
      trips_async(trips_param, custom_headers:custom_headers).value!
    end

    #
    # /fleet/trips
    #
    # Get historical trips data for specified vehicle. This method returns a set of
    # historical trips data for the specified vehicle in the specified time range.
    #
    # @param trips_param [TripsParam] Group ID, vehicle ID and time range to query.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def trips_async(trips_param, custom_headers:nil)
      fail ArgumentError, '@client.access_token is nil' if @client.access_token.nil?
      fail ArgumentError, 'trips_param is nil' if trips_param.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Serialize Request
      request_mapper = Swagger::Models::TripsParam.mapper()
      request_content = @client.serialize(request_mapper,  trips_param)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'fleet/trips'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          query_params: {'access_token' => @client.access_token},
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:post, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Swagger::Models::TripResponse.mapper()
            result.body = @client.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # /machines/history
    #
    # Get historical data for machine objects. This method returns a set of
    # historical data for all machines in a group
    #
    # @param history_param [HistoryParam] Group ID and time range to query for
    # events
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MachineHistoryResponse] operation results.
    #
    def history(history_param, custom_headers:nil)
      response = history_async(history_param, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # /machines/history
    #
    # Get historical data for machine objects. This method returns a set of
    # historical data for all machines in a group
    #
    # @param history_param [HistoryParam] Group ID and time range to query for
    # events
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def history_with_http_info(history_param, custom_headers:nil)
      history_async(history_param, custom_headers:custom_headers).value!
    end

    #
    # /machines/history
    #
    # Get historical data for machine objects. This method returns a set of
    # historical data for all machines in a group
    #
    # @param history_param [HistoryParam] Group ID and time range to query for
    # events
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def history_async(history_param, custom_headers:nil)
      fail ArgumentError, '@client.access_token is nil' if @client.access_token.nil?
      fail ArgumentError, 'history_param is nil' if history_param.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Serialize Request
      request_mapper = Swagger::Models::HistoryParam.mapper()
      request_content = @client.serialize(request_mapper,  history_param)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'machines/history'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          query_params: {'access_token' => @client.access_token},
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:post, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Swagger::Models::MachineHistoryResponse.mapper()
            result.body = @client.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # /machines/list
    #
    # Get machine objects. This method returns a list of the machine objects in the
    # Samsara Cloud and information about them.
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MachinesOKResponse] operation results.
    #
    def machines(custom_headers:nil)
      response = machines_async(custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # /machines/list
    #
    # Get machine objects. This method returns a list of the machine objects in the
    # Samsara Cloud and information about them.
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def machines_with_http_info(custom_headers:nil)
      machines_async(custom_headers:custom_headers).value!
    end

    #
    # /machines/list
    #
    # Get machine objects. This method returns a list of the machine objects in the
    # Samsara Cloud and information about them.
    #
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def machines_async(custom_headers:nil)
      fail ArgumentError, '@client.access_token is nil' if @client.access_token.nil?
      fail ArgumentError, '@client.group_param is nil' if @client.group_param.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Serialize Request
      request_mapper = Swagger::Models::GroupParam.mapper()
      request_content = @client.serialize(request_mapper,  @client.group_param)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'machines/list'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          query_params: {'access_token' => @client.access_token},
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:post, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Swagger::Models::MachinesOKResponse.mapper()
            result.body = @client.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # /sensors/cargo
    #
    # Get cargo monitor status (empty / full) for requested sensors.
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [CargoResponse] operation results.
    #
    def cargo(custom_headers:nil)
      response = cargo_async(custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # /sensors/cargo
    #
    # Get cargo monitor status (empty / full) for requested sensors.
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def cargo_with_http_info(custom_headers:nil)
      cargo_async(custom_headers:custom_headers).value!
    end

    #
    # /sensors/cargo
    #
    # Get cargo monitor status (empty / full) for requested sensors.
    #
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def cargo_async(custom_headers:nil)
      fail ArgumentError, '@client.access_token is nil' if @client.access_token.nil?
      fail ArgumentError, '@client.sensor_param is nil' if @client.sensor_param.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Serialize Request
      request_mapper = Swagger::Models::SensorParam.mapper()
      request_content = @client.serialize(request_mapper,  @client.sensor_param)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'sensors/cargo'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          query_params: {'access_token' => @client.access_token},
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:post, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Swagger::Models::CargoResponse.mapper()
            result.body = @client.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # /sensors/door
    #
    # Get door monitor status (closed / open) for requested sensors.
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [DoorResponse] operation results.
    #
    def door(custom_headers:nil)
      response = door_async(custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # /sensors/door
    #
    # Get door monitor status (closed / open) for requested sensors.
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def door_with_http_info(custom_headers:nil)
      door_async(custom_headers:custom_headers).value!
    end

    #
    # /sensors/door
    #
    # Get door monitor status (closed / open) for requested sensors.
    #
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def door_async(custom_headers:nil)
      fail ArgumentError, '@client.access_token is nil' if @client.access_token.nil?
      fail ArgumentError, '@client.sensor_param is nil' if @client.sensor_param.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Serialize Request
      request_mapper = Swagger::Models::SensorParam.mapper()
      request_content = @client.serialize(request_mapper,  @client.sensor_param)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'sensors/door'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          query_params: {'access_token' => @client.access_token},
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:post, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Swagger::Models::DoorResponse.mapper()
            result.body = @client.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # /sensors/history
    #
    # Get historical data for specified sensors. This method returns a set of
    # historical data for the specified sensors in the specified time range and at
    # the specified time resolution.
    #
    # @param history_param [HistoryParamModel] Group ID, time range and resolution,
    # and list of sensor ID, field pairs to query.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [SensorHistoryResponse] operation results.
    #
    def history1(history_param, custom_headers:nil)
      response = history1_async(history_param, custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # /sensors/history
    #
    # Get historical data for specified sensors. This method returns a set of
    # historical data for the specified sensors in the specified time range and at
    # the specified time resolution.
    #
    # @param history_param [HistoryParamModel] Group ID, time range and resolution,
    # and list of sensor ID, field pairs to query.
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def history1_with_http_info(history_param, custom_headers:nil)
      history1_async(history_param, custom_headers:custom_headers).value!
    end

    #
    # /sensors/history
    #
    # Get historical data for specified sensors. This method returns a set of
    # historical data for the specified sensors in the specified time range and at
    # the specified time resolution.
    #
    # @param history_param [HistoryParamModel] Group ID, time range and resolution,
    # and list of sensor ID, field pairs to query.
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def history1_async(history_param, custom_headers:nil)
      fail ArgumentError, '@client.access_token is nil' if @client.access_token.nil?
      fail ArgumentError, 'history_param is nil' if history_param.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Serialize Request
      request_mapper = Swagger::Models::HistoryParamModel.mapper()
      request_content = @client.serialize(request_mapper,  history_param)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'sensors/history'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          query_params: {'access_token' => @client.access_token},
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:post, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Swagger::Models::SensorHistoryResponse.mapper()
            result.body = @client.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # /sensors/humidity
    #
    # Get humidity for requested sensors. This method returns the current relative
    # humidity for the requested sensors.
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [HumidityResponse] operation results.
    #
    def humidity(custom_headers:nil)
      response = humidity_async(custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # /sensors/humidity
    #
    # Get humidity for requested sensors. This method returns the current relative
    # humidity for the requested sensors.
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def humidity_with_http_info(custom_headers:nil)
      humidity_async(custom_headers:custom_headers).value!
    end

    #
    # /sensors/humidity
    #
    # Get humidity for requested sensors. This method returns the current relative
    # humidity for the requested sensors.
    #
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def humidity_async(custom_headers:nil)
      fail ArgumentError, '@client.access_token is nil' if @client.access_token.nil?
      fail ArgumentError, '@client.sensor_param is nil' if @client.sensor_param.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Serialize Request
      request_mapper = Swagger::Models::SensorParam.mapper()
      request_content = @client.serialize(request_mapper,  @client.sensor_param)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'sensors/humidity'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          query_params: {'access_token' => @client.access_token},
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:post, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Swagger::Models::HumidityResponse.mapper()
            result.body = @client.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # /sensors/list
    #
    # Get sensor objects. This method returns a list of the sensor objects in the
    # Samsara Cloud and information about them.
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [SensorsOKResponse] operation results.
    #
    def sensors(custom_headers:nil)
      response = sensors_async(custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # /sensors/list
    #
    # Get sensor objects. This method returns a list of the sensor objects in the
    # Samsara Cloud and information about them.
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def sensors_with_http_info(custom_headers:nil)
      sensors_async(custom_headers:custom_headers).value!
    end

    #
    # /sensors/list
    #
    # Get sensor objects. This method returns a list of the sensor objects in the
    # Samsara Cloud and information about them.
    #
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def sensors_async(custom_headers:nil)
      fail ArgumentError, '@client.access_token is nil' if @client.access_token.nil?
      fail ArgumentError, '@client.group_param is nil' if @client.group_param.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Serialize Request
      request_mapper = Swagger::Models::GroupParam.mapper()
      request_content = @client.serialize(request_mapper,  @client.group_param)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'sensors/list'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          query_params: {'access_token' => @client.access_token},
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:post, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Swagger::Models::SensorsOKResponse.mapper()
            result.body = @client.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

    #
    # /sensors/temperature
    #
    # Get temperature for requested sensors. This method returns the current
    # ambient temperature (and probe temperature if applicable) for the requested
    # sensors.
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [TemperatureResponse] operation results.
    #
    def temperature(custom_headers:nil)
      response = temperature_async(custom_headers:custom_headers).value!
      response.body unless response.nil?
    end

    #
    # /sensors/temperature
    #
    # Get temperature for requested sensors. This method returns the current
    # ambient temperature (and probe temperature if applicable) for the requested
    # sensors.
    #
    # @param custom_headers [Hash{String => String}] A hash of custom headers that
    # will be added to the HTTP request.
    #
    # @return [MsRest::HttpOperationResponse] HTTP response information.
    #
    def temperature_with_http_info(custom_headers:nil)
      temperature_async(custom_headers:custom_headers).value!
    end

    #
    # /sensors/temperature
    #
    # Get temperature for requested sensors. This method returns the current
    # ambient temperature (and probe temperature if applicable) for the requested
    # sensors.
    #
    # @param [Hash{String => String}] A hash of custom headers that will be added
    # to the HTTP request.
    #
    # @return [Concurrent::Promise] Promise object which holds the HTTP response.
    #
    def temperature_async(custom_headers:nil)
      fail ArgumentError, '@client.access_token is nil' if @client.access_token.nil?
      fail ArgumentError, '@client.sensor_param is nil' if @client.sensor_param.nil?


      request_headers = {}
      request_headers['Content-Type'] = 'application/json; charset=utf-8'

      # Serialize Request
      request_mapper = Swagger::Models::SensorParam.mapper()
      request_content = @client.serialize(request_mapper,  @client.sensor_param)
      request_content = request_content != nil ? JSON.generate(request_content, quirks_mode: true) : nil

      path_template = 'sensors/temperature'

      request_url = @base_url || @client.base_url

      options = {
          middlewares: [[MsRest::RetryPolicyMiddleware, times: 3, retry: 0.02], [:cookie_jar]],
          query_params: {'access_token' => @client.access_token},
          body: request_content,
          headers: request_headers.merge(custom_headers || {}),
          base_url: request_url
      }
      promise = @client.make_request_async(:post, path_template, options)

      promise = promise.then do |result|
        http_response = result.response
        status_code = http_response.status
        response_content = http_response.body
        unless status_code == 200
          error_model = JSON.load(response_content)
          fail MsRest::HttpOperationError.new(result.request, http_response, error_model)
        end

        # Deserialize Response
        if status_code == 200
          begin
            parsed_response = response_content.to_s.empty? ? nil : JSON.load(response_content)
            result_mapper = Swagger::Models::TemperatureResponse.mapper()
            result.body = @client.deserialize(result_mapper, parsed_response)
          rescue Exception => e
            fail MsRest::DeserializationError.new('Error occurred in deserializing the response', e.message, e.backtrace, result)
          end
        end

        result
      end

      promise.execute
    end

  end
end
