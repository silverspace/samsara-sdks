# samsara_api
#
# This file was automatically generated by APIMATIC v2.0
# ( https://apimatic.io ).

module SamsaraApi
  # FleetController
  class FleetController < BaseController
    @instance = FleetController.new

    class << self
      attr_accessor :instance
    end

    def instance
      self.class.instance
    end

    # Fetch all of the document types.
    # @return List of DocumentType response from the API call
    def get_driver_document_types_by_org_id
      # Prepare query url.
      _path_url = '/fleet/drivers/document_types'
      _query_builder = Configuration.base_uri.dup
      _query_builder << _path_url
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/json'
      }

      # Prepare and execute HttpRequest.
      _request = @http_client.get(
        _query_url,
        headers: _headers
      )
      CustomQueryAuth.apply(_request)
      _context = execute_request(_request)

      # Validate response against endpoint and global error codes.
      unless _context.response.status_code.between?(200, 208)
        raise APIException.new(
          'Unexpected error.',
          _context
        )
      end
      validate_response(_context)

      # Return appropriate response type.
      decoded = APIHelper.json_deserialize(_context.response.raw_body)
      decoded.map { |element| DocumentType.from_hash(element) }
    end

    # Fetch locations for a given vehicle between a start/end time. The maximum
    # query duration is one hour.
    # @param [String] access_token Required parameter: Samsara API access
    # token.
    # @param [Long] vehicle_id Required parameter: ID of the vehicle with the
    # associated routes.
    # @param [Long] start_ms Required parameter: Time in Unix epoch milliseconds
    # for the start of the query (cannot exceed 1 hour)
    # @param [Long] end_ms Required parameter: Time in Unix epoch milliseconds
    # for the end of the query (cannot exceed 1 hour)
    # @return List of FleetVehicleLocation response from the API call
    def get_vehicle_locations(access_token,
                              vehicle_id,
                              start_ms,
                              end_ms)
      # Prepare query url.
      _path_url = '/fleet/vehicles/{vehicle_id}/locations'
      _path_url = APIHelper.append_url_with_template_parameters(
        _path_url,
        'vehicle_id' => vehicle_id
      )
      _query_builder = Configuration.base_uri.dup
      _query_builder << _path_url
      _query_builder = APIHelper.append_url_with_query_parameters(
        _query_builder,
        {
          'access_token' => access_token,
          'startMs' => start_ms,
          'endMs' => end_ms
        },
        array_serialization: Configuration.array_serialization
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/json'
      }

      # Prepare and execute HttpRequest.
      _request = @http_client.get(
        _query_url,
        headers: _headers
      )
      CustomQueryAuth.apply(_request)
      _context = execute_request(_request)

      # Validate response against endpoint and global error codes.
      unless _context.response.status_code.between?(200, 208)
        raise APIException.new(
          'Unexpected error.',
          _context
        )
      end
      validate_response(_context)

      # Return appropriate response type.
      decoded = APIHelper.json_deserialize(_context.response.raw_body)
      decoded.map { |element| FleetVehicleLocation.from_hash(element) }
    end

    # Create a new dispatch route for the vehicle with vehicle_id.
    # @param [DispatchRouteCreate] create_dispatch_route_params Required
    # parameter: Example:
    # @param [String] access_token Required parameter: Samsara API access
    # token.
    # @param [Long] vehicle_id Required parameter: ID of the vehicle with the
    # associated routes.
    # @return DispatchRoute response from the API call
    def create_vehicle_dispatch_route(create_dispatch_route_params,
                                      access_token,
                                      vehicle_id)
      # Prepare query url.
      _path_url = '/fleet/vehicles/{vehicle_id}/dispatch/routes'
      _path_url = APIHelper.append_url_with_template_parameters(
        _path_url,
        'vehicle_id' => vehicle_id
      )
      _query_builder = Configuration.base_uri.dup
      _query_builder << _path_url
      _query_builder = APIHelper.append_url_with_query_parameters(
        _query_builder,
        {
          'access_token' => access_token
        },
        array_serialization: Configuration.array_serialization
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/json',
        'content-type' => 'application/json; charset=utf-8'
      }

      # Prepare and execute HttpRequest.
      _request = @http_client.post(
        _query_url,
        headers: _headers,
        parameters: create_dispatch_route_params.to_json
      )
      CustomQueryAuth.apply(_request)
      _context = execute_request(_request)

      # Validate response against endpoint and global error codes.
      unless _context.response.status_code.between?(200, 208)
        raise APIException.new(
          'Unexpected error.',
          _context
        )
      end
      validate_response(_context)

      # Return appropriate response type.
      decoded = APIHelper.json_deserialize(_context.response.raw_body)
      DispatchRoute.from_hash(decoded)
    end

    # Fetch all of the dispatch routes for a given vehicle.
    # @param [String] access_token Required parameter: Samsara API access
    # token.
    # @param [Long] vehicle_id Required parameter: ID of the vehicle with the
    # associated routes.
    # @param [Long] end_time Optional parameter: Time in unix milliseconds that
    # represents the oldest routes to return. Used in combination with duration.
    # Defaults to now.
    # @param [Long] duration Optional parameter: Time in milliseconds that
    # represents the duration before end_time to query. Defaults to 24 hours.
    # @return List of DispatchRoute response from the API call
    def get_dispatch_routes_by_vehicle_id(access_token,
                                          vehicle_id,
                                          end_time = nil,
                                          duration = nil)
      # Prepare query url.
      _path_url = '/fleet/vehicles/{vehicle_id}/dispatch/routes'
      _path_url = APIHelper.append_url_with_template_parameters(
        _path_url,
        'vehicle_id' => vehicle_id
      )
      _query_builder = Configuration.base_uri.dup
      _query_builder << _path_url
      _query_builder = APIHelper.append_url_with_query_parameters(
        _query_builder,
        {
          'access_token' => access_token,
          'end_time' => end_time,
          'duration' => duration
        },
        array_serialization: Configuration.array_serialization
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/json'
      }

      # Prepare and execute HttpRequest.
      _request = @http_client.get(
        _query_url,
        headers: _headers
      )
      CustomQueryAuth.apply(_request)
      _context = execute_request(_request)

      # Validate response against endpoint and global error codes.
      unless _context.response.status_code.between?(200, 208)
        raise APIException.new(
          'Unexpected error.',
          _context
        )
      end
      validate_response(_context)

      # Return appropriate response type.
      decoded = APIHelper.json_deserialize(_context.response.raw_body)
      decoded.map { |element| DispatchRoute.from_hash(element) }
    end

    # Updates the specified vehicle using JSON merge patch format. See IETF RFC
    # 7396: https://tools.ietf.org/html/rfc7396.
    # @param [String] access_token Required parameter: Samsara API access
    # token.
    # @param [String] vehicle_id_or_external_id Required parameter: ID of the
    # vehicle.  This must be either the numeric ID generated by Samsara or the
    # external ID of the vehicle.  External IDs are customer specified key-value
    # pairs.
    # @param [Data] data Required parameter: Example:
    # @return FleetVehicleResponse response from the API call
    def patch_fleet_vehicle(access_token,
                            vehicle_id_or_external_id,
                            data)
      # Prepare query url.
      _path_url = '/fleet/vehicles/{vehicle_id_or_external_id}'
      _path_url = APIHelper.append_url_with_template_parameters(
        _path_url,
        'vehicle_id_or_external_id' => vehicle_id_or_external_id
      )
      _query_builder = Configuration.base_uri.dup
      _query_builder << _path_url
      _query_builder = APIHelper.append_url_with_query_parameters(
        _query_builder,
        {
          'access_token' => access_token
        },
        array_serialization: Configuration.array_serialization
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/json',
        'content-type' => 'application/json; charset=utf-8'
      }

      # Prepare and execute HttpRequest.
      _request = @http_client.patch(
        _query_url,
        headers: _headers,
        parameters: data.to_json
      )
      CustomQueryAuth.apply(_request)
      _context = execute_request(_request)

      # Validate response against endpoint and global error codes.
      unless _context.response.status_code.between?(200, 208)
        raise APIException.new(
          'Unexpected error.',
          _context
        )
      end
      validate_response(_context)

      # Return appropriate response type.
      decoded = APIHelper.json_deserialize(_context.response.raw_body)
      FleetVehicleResponse.from_hash(decoded)
    end

    # Fetch the safety score for the vehicle.
    # @param [String] access_token Required parameter: Samsara API access
    # token.
    # @param [Long] start_ms Required parameter: Timestamp in milliseconds
    # representing the start of the period to fetch, inclusive. Used in
    # combination with endMs.
    # @param [Long] end_ms Required parameter: Timestamp in milliseconds
    # representing the end of the period to fetch, inclusive. Used in
    # combination with startMs.
    # @param [Long] vehicle_id Required parameter: ID of the vehicle
    # @return VehicleSafetyScoreResponse response from the API call
    def get_vehicle_safety_score(access_token,
                                 start_ms,
                                 end_ms,
                                 vehicle_id)
      # Prepare query url.
      _path_url = '/fleet/vehicles/{vehicleId}/safety/score'
      _path_url = APIHelper.append_url_with_template_parameters(
        _path_url,
        'vehicleId' => vehicle_id
      )
      _query_builder = Configuration.base_uri.dup
      _query_builder << _path_url
      _query_builder = APIHelper.append_url_with_query_parameters(
        _query_builder,
        {
          'access_token' => access_token,
          'startMs' => start_ms,
          'endMs' => end_ms
        },
        array_serialization: Configuration.array_serialization
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/json'
      }

      # Prepare and execute HttpRequest.
      _request = @http_client.get(
        _query_url,
        headers: _headers
      )
      CustomQueryAuth.apply(_request)
      _context = execute_request(_request)

      # Validate response against endpoint and global error codes.
      unless _context.response.status_code.between?(200, 208)
        raise APIException.new(
          'Unexpected error.',
          _context
        )
      end
      validate_response(_context)

      # Return appropriate response type.
      decoded = APIHelper.json_deserialize(_context.response.raw_body)
      VehicleSafetyScoreResponse.from_hash(decoded)
    end

    # Fetch harsh event details for a vehicle.
    # @param [String] access_token Required parameter: Samsara API access
    # token.
    # @param [Long] timestamp Required parameter: Timestamp in milliseconds
    # representing the timestamp of a harsh event.
    # @param [Long] vehicle_id Required parameter: ID of the vehicle
    # @return VehicleHarshEventResponse response from the API call
    def get_vehicle_harsh_event(access_token,
                                timestamp,
                                vehicle_id)
      # Prepare query url.
      _path_url = '/fleet/vehicles/{vehicleId}/safety/harsh_event'
      _path_url = APIHelper.append_url_with_template_parameters(
        _path_url,
        'vehicleId' => vehicle_id
      )
      _query_builder = Configuration.base_uri.dup
      _query_builder << _path_url
      _query_builder = APIHelper.append_url_with_query_parameters(
        _query_builder,
        {
          'access_token' => access_token,
          'timestamp' => timestamp
        },
        array_serialization: Configuration.array_serialization
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/json'
      }

      # Prepare and execute HttpRequest.
      _request = @http_client.get(
        _query_url,
        headers: _headers
      )
      CustomQueryAuth.apply(_request)
      _context = execute_request(_request)

      # Validate response against endpoint and global error codes.
      unless _context.response.status_code.between?(200, 208)
        raise APIException.new(
          'Unexpected error.',
          _context
        )
      end
      validate_response(_context)

      # Return appropriate response type.
      decoded = APIHelper.json_deserialize(_context.response.raw_body)
      VehicleHarshEventResponse.from_hash(decoded)
    end

    # Fetch locations for a given vehicle between a start/end time. The maximum
    # query duration is 30 minutes.
    # @param [String] access_token Required parameter: Samsara API access
    # token.
    # @param [Integer] start_ms Required parameter: Time in Unix epoch
    # milliseconds for the start of the query (cannot exceed 30 minutes)
    # @param [Integer] end_ms Required parameter: Time in Unix epoch
    # milliseconds for the end of the query (cannot exceed 30 minutes)
    # @return List of FleetVehiclesLocation response from the API call
    def get_vehicles_locations(access_token,
                               start_ms,
                               end_ms)
      # Prepare query url.
      _path_url = '/fleet/vehicles/locations'
      _query_builder = Configuration.base_uri.dup
      _query_builder << _path_url
      _query_builder = APIHelper.append_url_with_query_parameters(
        _query_builder,
        {
          'access_token' => access_token,
          'startMs' => start_ms,
          'endMs' => end_ms
        },
        array_serialization: Configuration.array_serialization
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/json'
      }

      # Prepare and execute HttpRequest.
      _request = @http_client.get(
        _query_url,
        headers: _headers
      )
      CustomQueryAuth.apply(_request)
      _context = execute_request(_request)

      # Validate response against endpoint and global error codes.
      unless _context.response.status_code.between?(200, 208)
        raise APIException.new(
          'Unexpected error.',
          _context
        )
      end
      validate_response(_context)

      # Return appropriate response type.
      decoded = APIHelper.json_deserialize(_context.response.raw_body)
      decoded.map { |element| FleetVehiclesLocation.from_hash(element) }
    end

    # Get DVIRs for the org within provided time constraints
    # @param [String] access_token Required parameter: Samsara API access
    # token.
    # @param [Integer] end_ms Required parameter: time in millis until the last
    # dvir log.
    # @param [Integer] duration_ms Required parameter: time in millis which
    # corresponds to the duration before the end_ms.
    # @param [Integer] group_id Optional parameter: Group ID to query.
    # @return DvirListResponse response from the API call
    def get_dvirs(access_token,
                  end_ms,
                  duration_ms,
                  group_id = nil)
      # Prepare query url.
      _path_url = '/fleet/maintenance/dvirs'
      _query_builder = Configuration.base_uri.dup
      _query_builder << _path_url
      _query_builder = APIHelper.append_url_with_query_parameters(
        _query_builder,
        {
          'access_token' => access_token,
          'end_ms' => end_ms,
          'duration_ms' => duration_ms,
          'group_id' => group_id
        },
        array_serialization: Configuration.array_serialization
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/json'
      }

      # Prepare and execute HttpRequest.
      _request = @http_client.get(
        _query_url,
        headers: _headers
      )
      CustomQueryAuth.apply(_request)
      _context = execute_request(_request)

      # Validate response against endpoint and global error codes.
      unless _context.response.status_code.between?(200, 208)
        raise APIException.new(
          'Unexpected error.',
          _context
        )
      end
      validate_response(_context)

      # Return appropriate response type.
      decoded = APIHelper.json_deserialize(_context.response.raw_body)
      DvirListResponse.from_hash(decoded)
    end

    # Gets a specific vehicle.
    # @param [String] access_token Required parameter: Samsara API access
    # token.
    # @param [String] vehicle_id_or_external_id Required parameter: ID of the
    # vehicle.  This must be either the numeric ID generated by Samsara or the
    # external ID of the vehicle.  External IDs are customer specified key-value
    # pairs.
    # @return FleetVehicleResponse response from the API call
    def get_fleet_vehicle(access_token,
                          vehicle_id_or_external_id)
      # Prepare query url.
      _path_url = '/fleet/vehicles/{vehicle_id_or_external_id}'
      _path_url = APIHelper.append_url_with_template_parameters(
        _path_url,
        'vehicle_id_or_external_id' => vehicle_id_or_external_id
      )
      _query_builder = Configuration.base_uri.dup
      _query_builder << _path_url
      _query_builder = APIHelper.append_url_with_query_parameters(
        _query_builder,
        {
          'access_token' => access_token
        },
        array_serialization: Configuration.array_serialization
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/json'
      }

      # Prepare and execute HttpRequest.
      _request = @http_client.get(
        _query_url,
        headers: _headers
      )
      CustomQueryAuth.apply(_request)
      _context = execute_request(_request)

      # Validate response against endpoint and global error codes.
      unless _context.response.status_code.between?(200, 208)
        raise APIException.new(
          'Unexpected error.',
          _context
        )
      end
      validate_response(_context)

      # Return appropriate response type.
      decoded = APIHelper.json_deserialize(_context.response.raw_body)
      FleetVehicleResponse.from_hash(decoded)
    end

    # Get list of the vehicles. This method returns a list of the vehicles in
    # the Samsara Cloud and information about them.
    # @param [String] access_token Required parameter: Samsara API access
    # token.
    # @param [GroupParam] group_param Required parameter: Group ID to query.
    # @param [String] starting_after Optional parameter: Pagination parameter
    # indicating the cursor position to continue returning results after. Used
    # in conjunction with the 'limit' parameter. Mutually exclusive with
    # 'endingBefore' parameter.
    # @param [String] ending_before Optional parameter: Pagination parameter
    # indicating the cursor position to return results before. Used in
    # conjunction with the 'limit' parameter. Mutually exclusive with
    # 'startingAfter' parameter.
    # @param [Long] limit Optional parameter: Pagination parameter indicating
    # the number of results to return in this request. Used in conjunction with
    # either 'startingAfter' or 'endingBefore'.
    # @return ListFleetResponse response from the API call
    def create_list_fleet(access_token,
                          group_param,
                          starting_after = nil,
                          ending_before = nil,
                          limit = nil)
      # Prepare query url.
      _path_url = '/fleet/list'
      _query_builder = Configuration.base_uri.dup
      _query_builder << _path_url
      _query_builder = APIHelper.append_url_with_query_parameters(
        _query_builder,
        {
          'access_token' => access_token,
          'startingAfter' => starting_after,
          'endingBefore' => ending_before,
          'limit' => limit
        },
        array_serialization: Configuration.array_serialization
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/json',
        'content-type' => 'application/json; charset=utf-8'
      }

      # Prepare and execute HttpRequest.
      _request = @http_client.post(
        _query_url,
        headers: _headers,
        parameters: group_param.to_json
      )
      CustomQueryAuth.apply(_request)
      _context = execute_request(_request)

      # Validate response against endpoint and global error codes.
      unless _context.response.status_code.between?(200, 208)
        raise APIException.new(
          'Unexpected error.',
          _context
        )
      end
      validate_response(_context)

      # Return appropriate response type.
      decoded = APIHelper.json_deserialize(_context.response.raw_body)
      ListFleetResponse.from_hash(decoded)
    end

    # Get summarized daily HOS charts for a specified driver.
    # @param [String] access_token Required parameter: Samsara API access
    # token.
    # @param [Long] driver_id Required parameter: ID of the driver with HOS
    # logs.
    # @param [HosLogsParam] hos_logs_param Required parameter: Example:
    # @return DriverDailyLogResponse response from the API call
    def create_get_fleet_drivers_hos_daily_logs(access_token,
                                                driver_id,
                                                hos_logs_param)
      # Prepare query url.
      _path_url = '/fleet/drivers/{driver_id}/hos_daily_logs'
      _path_url = APIHelper.append_url_with_template_parameters(
        _path_url,
        'driver_id' => driver_id
      )
      _query_builder = Configuration.base_uri.dup
      _query_builder << _path_url
      _query_builder = APIHelper.append_url_with_query_parameters(
        _query_builder,
        {
          'access_token' => access_token
        },
        array_serialization: Configuration.array_serialization
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/json',
        'content-type' => 'application/json; charset=utf-8'
      }

      # Prepare and execute HttpRequest.
      _request = @http_client.post(
        _query_url,
        headers: _headers,
        parameters: hos_logs_param.to_json
      )
      CustomQueryAuth.apply(_request)
      _context = execute_request(_request)

      # Validate response against endpoint and global error codes.
      unless _context.response.status_code.between?(200, 208)
        raise APIException.new(
          'Unexpected error.',
          _context
        )
      end
      validate_response(_context)

      # Return appropriate response type.
      decoded = APIHelper.json_deserialize(_context.response.raw_body)
      DriverDailyLogResponse.from_hash(decoded)
    end

    # Create a driver document for the given driver.
    # @param [DocumentCreate] create_document_params Required parameter: To
    # create a document for a given document type, the document type's uuid
    # needs to be passed in to documentTypeUuid. The list of fields passed in
    # should match the document type’s list of field types in the correct order.
    # In other words, a field's valueType and value (i.e. only one of:
    # stringValue, numberValue, or photoValue) at index _i_ should match with
    # the document field type’s valueType at index _i_.
    # @param [String] access_token Required parameter: Samsara API access
    # token.
    # @param [Long] driver_id Required parameter: ID of the driver for whom the
    # document is created.
    # @return Document response from the API call
    def create_driver_document(create_document_params,
                               access_token,
                               driver_id)
      # Prepare query url.
      _path_url = '/fleet/drivers/{driver_id}/documents'
      _path_url = APIHelper.append_url_with_template_parameters(
        _path_url,
        'driver_id' => driver_id
      )
      _query_builder = Configuration.base_uri.dup
      _query_builder << _path_url
      _query_builder = APIHelper.append_url_with_query_parameters(
        _query_builder,
        {
          'access_token' => access_token
        },
        array_serialization: Configuration.array_serialization
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/json',
        'content-type' => 'application/json; charset=utf-8'
      }

      # Prepare and execute HttpRequest.
      _request = @http_client.post(
        _query_url,
        headers: _headers,
        parameters: create_document_params.to_json
      )
      CustomQueryAuth.apply(_request)
      _context = execute_request(_request)

      # Validate response against endpoint and global error codes.
      unless _context.response.status_code.between?(200, 208)
        raise APIException.new(
          'Unexpected error.',
          _context
        )
      end
      validate_response(_context)

      # Return appropriate response type.
      decoded = APIHelper.json_deserialize(_context.response.raw_body)
      Document.from_hash(decoded)
    end

    # Create a new dispatch route for the driver with driver_id.
    # @param [DispatchRouteCreate] create_dispatch_route_params Required
    # parameter: Example:
    # @param [String] access_token Required parameter: Samsara API access
    # token.
    # @param [Long] driver_id Required parameter: ID of the driver with the
    # associated routes.
    # @return DispatchRoute response from the API call
    def create_driver_dispatch_route(create_dispatch_route_params,
                                     access_token,
                                     driver_id)
      # Prepare query url.
      _path_url = '/fleet/drivers/{driver_id}/dispatch/routes'
      _path_url = APIHelper.append_url_with_template_parameters(
        _path_url,
        'driver_id' => driver_id
      )
      _query_builder = Configuration.base_uri.dup
      _query_builder << _path_url
      _query_builder = APIHelper.append_url_with_query_parameters(
        _query_builder,
        {
          'access_token' => access_token
        },
        array_serialization: Configuration.array_serialization
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/json',
        'content-type' => 'application/json; charset=utf-8'
      }

      # Prepare and execute HttpRequest.
      _request = @http_client.post(
        _query_url,
        headers: _headers,
        parameters: create_dispatch_route_params.to_json
      )
      CustomQueryAuth.apply(_request)
      _context = execute_request(_request)

      # Validate response against endpoint and global error codes.
      unless _context.response.status_code.between?(200, 208)
        raise APIException.new(
          'Unexpected error.',
          _context
        )
      end
      validate_response(_context)

      # Return appropriate response type.
      decoded = APIHelper.json_deserialize(_context.response.raw_body)
      DispatchRoute.from_hash(decoded)
    end

    # Get historical trips data for specified vehicle. This method returns a set
    # of historical trips data for the specified vehicle in the specified time
    # range.
    # @param [String] access_token Required parameter: Samsara API access
    # token.
    # @param [TripsParam] trips_param Required parameter: Group ID, vehicle ID
    # and time range to query.
    # @return TripResponse response from the API call
    def create_get_fleet_trips(access_token,
                               trips_param)
      # Prepare query url.
      _path_url = '/fleet/trips'
      _query_builder = Configuration.base_uri.dup
      _query_builder << _path_url
      _query_builder = APIHelper.append_url_with_query_parameters(
        _query_builder,
        {
          'access_token' => access_token
        },
        array_serialization: Configuration.array_serialization
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/json',
        'content-type' => 'application/json; charset=utf-8'
      }

      # Prepare and execute HttpRequest.
      _request = @http_client.post(
        _query_url,
        headers: _headers,
        parameters: trips_param.to_json
      )
      CustomQueryAuth.apply(_request)
      _context = execute_request(_request)

      # Validate response against endpoint and global error codes.
      unless _context.response.status_code.between?(200, 208)
        raise APIException.new(
          'Unexpected error.',
          _context
        )
      end
      validate_response(_context)

      # Return appropriate response type.
      decoded = APIHelper.json_deserialize(_context.response.raw_body)
      TripResponse.from_hash(decoded)
    end

    # This method enables the mutation of metadata for vehicles in the Samsara
    # Cloud.
    # @param [String] access_token Required parameter: Samsara API access
    # token.
    # @param [VehicleUpdateParam] vehicle_update_param Required parameter:
    # Example:
    # @return void response from the API call
    def update_vehicles(access_token,
                        vehicle_update_param)
      # Prepare query url.
      _path_url = '/fleet/set_data'
      _query_builder = Configuration.base_uri.dup
      _query_builder << _path_url
      _query_builder = APIHelper.append_url_with_query_parameters(
        _query_builder,
        {
          'access_token' => access_token
        },
        array_serialization: Configuration.array_serialization
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'content-type' => 'application/json; charset=utf-8'
      }

      # Prepare and execute HttpRequest.
      _request = @http_client.post(
        _query_url,
        headers: _headers,
        parameters: vehicle_update_param.to_json
      )
      CustomQueryAuth.apply(_request)
      _context = execute_request(_request)

      # Validate response against endpoint and global error codes.
      unless _context.response.status_code.between?(200, 208)
        raise APIException.new(
          'Unexpected error.',
          _context
        )
      end
      validate_response(_context)
    end

    # Get list of the vehicles with any engine faults or check light data.
    # @param [String] access_token Required parameter: Samsara API access
    # token.
    # @param [GroupParam] group_param Required parameter: Group ID to query.
    # @return GetFleetMaintenanceListResponse response from the API call
    def create_get_fleet_maintenance_list(access_token,
                                          group_param)
      # Prepare query url.
      _path_url = '/fleet/maintenance/list'
      _query_builder = Configuration.base_uri.dup
      _query_builder << _path_url
      _query_builder = APIHelper.append_url_with_query_parameters(
        _query_builder,
        {
          'access_token' => access_token
        },
        array_serialization: Configuration.array_serialization
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/json',
        'content-type' => 'application/json; charset=utf-8'
      }

      # Prepare and execute HttpRequest.
      _request = @http_client.post(
        _query_url,
        headers: _headers,
        parameters: group_param.to_json
      )
      CustomQueryAuth.apply(_request)
      _context = execute_request(_request)

      # Validate response against endpoint and global error codes.
      unless _context.response.status_code.between?(200, 208)
        raise APIException.new(
          'Unexpected error.',
          _context
        )
      end
      validate_response(_context)

      # Return appropriate response type.
      decoded = APIHelper.json_deserialize(_context.response.raw_body)
      GetFleetMaintenanceListResponse.from_hash(decoded)
    end

    # Fetch all of the dispatch routes for a given driver.
    # @param [String] access_token Required parameter: Samsara API access
    # token.
    # @param [Long] driver_id Required parameter: ID of the driver with the
    # associated routes.
    # @param [Long] end_time Optional parameter: Time in unix milliseconds that
    # represents the oldest routes to return. Used in combination with duration.
    # Defaults to now.
    # @param [Long] duration Optional parameter: Time in milliseconds that
    # represents the duration before end_time to query. Defaults to 24 hours.
    # @return List of DispatchRoute response from the API call
    def get_dispatch_routes_by_driver_id(access_token,
                                         driver_id,
                                         end_time = nil,
                                         duration = nil)
      # Prepare query url.
      _path_url = '/fleet/drivers/{driver_id}/dispatch/routes'
      _path_url = APIHelper.append_url_with_template_parameters(
        _path_url,
        'driver_id' => driver_id
      )
      _query_builder = Configuration.base_uri.dup
      _query_builder << _path_url
      _query_builder = APIHelper.append_url_with_query_parameters(
        _query_builder,
        {
          'access_token' => access_token,
          'end_time' => end_time,
          'duration' => duration
        },
        array_serialization: Configuration.array_serialization
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/json'
      }

      # Prepare and execute HttpRequest.
      _request = @http_client.get(
        _query_url,
        headers: _headers
      )
      CustomQueryAuth.apply(_request)
      _context = execute_request(_request)

      # Validate response against endpoint and global error codes.
      unless _context.response.status_code.between?(200, 208)
        raise APIException.new(
          'Unexpected error.',
          _context
        )
      end
      validate_response(_context)

      # Return appropriate response type.
      decoded = APIHelper.json_deserialize(_context.response.raw_body)
      decoded.map { |element| DispatchRoute.from_hash(element) }
    end

    # Create a new dvir, marking a vehicle or trailer safe or unsafe.
    # @param [String] access_token Required parameter: Samsara API access
    # token.
    # @param [CreateDvirParam] create_dvir_param Required parameter: DVIR
    # creation body
    # @return DvirBase response from the API call
    def create_dvir(access_token,
                    create_dvir_param)
      # Prepare query url.
      _path_url = '/fleet/maintenance/dvirs'
      _query_builder = Configuration.base_uri.dup
      _query_builder << _path_url
      _query_builder = APIHelper.append_url_with_query_parameters(
        _query_builder,
        {
          'access_token' => access_token
        },
        array_serialization: Configuration.array_serialization
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/json',
        'content-type' => 'application/json; charset=utf-8'
      }

      # Prepare and execute HttpRequest.
      _request = @http_client.post(
        _query_url,
        headers: _headers,
        parameters: create_dvir_param.to_json
      )
      CustomQueryAuth.apply(_request)
      _context = execute_request(_request)

      # Validate response against endpoint and global error codes.
      unless _context.response.status_code.between?(200, 208)
        raise APIException.new(
          'Unexpected error.',
          _context
        )
      end
      validate_response(_context)

      # Return appropriate response type.
      decoded = APIHelper.json_deserialize(_context.response.raw_body)
      DvirBase.from_hash(decoded)
    end

    # Fetch the safety score for the driver.
    # @param [String] access_token Required parameter: Samsara API access
    # token.
    # @param [Long] start_ms Required parameter: Timestamp in milliseconds
    # representing the start of the period to fetch, inclusive. Used in
    # combination with endMs.
    # @param [Long] end_ms Required parameter: Timestamp in milliseconds
    # representing the end of the period to fetch, inclusive. Used in
    # combination with startMs.
    # @param [Long] driver_id Required parameter: ID of the driver
    # @return DriverSafetyScoreResponse response from the API call
    def get_driver_safety_score(access_token,
                                start_ms,
                                end_ms,
                                driver_id)
      # Prepare query url.
      _path_url = '/fleet/drivers/{driverId}/safety/score'
      _path_url = APIHelper.append_url_with_template_parameters(
        _path_url,
        'driverId' => driver_id
      )
      _query_builder = Configuration.base_uri.dup
      _query_builder << _path_url
      _query_builder = APIHelper.append_url_with_query_parameters(
        _query_builder,
        {
          'access_token' => access_token,
          'startMs' => start_ms,
          'endMs' => end_ms
        },
        array_serialization: Configuration.array_serialization
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/json'
      }

      # Prepare and execute HttpRequest.
      _request = @http_client.get(
        _query_url,
        headers: _headers
      )
      CustomQueryAuth.apply(_request)
      _context = execute_request(_request)

      # Validate response against endpoint and global error codes.
      unless _context.response.status_code.between?(200, 208)
        raise APIException.new(
          'Unexpected error.',
          _context
        )
      end
      validate_response(_context)

      # Return appropriate response type.
      decoded = APIHelper.json_deserialize(_context.response.raw_body)
      DriverSafetyScoreResponse.from_hash(decoded)
    end

    # Get current location of vehicles in a group. This method returns the
    # current location in latitude and longitude of all vehicles in a requested
    # group.
    # @param [String] access_token Required parameter: Samsara API access
    # token.
    # @param [GroupParam] group_param Required parameter: Group ID to query.
    # @return GetFleetLocationsResponse response from the API call
    def create_get_fleet_locations(access_token,
                                   group_param)
      # Prepare query url.
      _path_url = '/fleet/locations'
      _query_builder = Configuration.base_uri.dup
      _query_builder << _path_url
      _query_builder = APIHelper.append_url_with_query_parameters(
        _query_builder,
        {
          'access_token' => access_token
        },
        array_serialization: Configuration.array_serialization
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/json',
        'content-type' => 'application/json; charset=utf-8'
      }

      # Prepare and execute HttpRequest.
      _request = @http_client.post(
        _query_url,
        headers: _headers,
        parameters: group_param.to_json
      )
      CustomQueryAuth.apply(_request)
      _context = execute_request(_request)

      # Validate response against endpoint and global error codes.
      unless _context.response.status_code.between?(200, 208)
        raise APIException.new(
          'Unexpected error.',
          _context
        )
      end
      validate_response(_context)

      # Return appropriate response type.
      decoded = APIHelper.json_deserialize(_context.response.raw_body)
      GetFleetLocationsResponse.from_hash(decoded)
    end

    # Get the current HOS status for all drivers in the group.
    # @param [String] access_token Required parameter: Samsara API access
    # token.
    # @param [HosLogsParam2] hos_logs_param Required parameter: Example:
    # @return HosLogsSummaryResponse response from the API call
    def create_get_fleet_hos_logs_summary(access_token,
                                          hos_logs_param)
      # Prepare query url.
      _path_url = '/fleet/hos_logs_summary'
      _query_builder = Configuration.base_uri.dup
      _query_builder << _path_url
      _query_builder = APIHelper.append_url_with_query_parameters(
        _query_builder,
        {
          'access_token' => access_token
        },
        array_serialization: Configuration.array_serialization
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/json',
        'content-type' => 'application/json; charset=utf-8'
      }

      # Prepare and execute HttpRequest.
      _request = @http_client.post(
        _query_url,
        headers: _headers,
        parameters: hos_logs_param.to_json
      )
      CustomQueryAuth.apply(_request)
      _context = execute_request(_request)

      # Validate response against endpoint and global error codes.
      unless _context.response.status_code.between?(200, 208)
        raise APIException.new(
          'Unexpected error.',
          _context
        )
      end
      validate_response(_context)

      # Return appropriate response type.
      decoded = APIHelper.json_deserialize(_context.response.raw_body)
      HosLogsSummaryResponse.from_hash(decoded)
    end

    # Get the HOS (hours of service) logs for the specified driver. This method
    # returns all the HOS statuses that the driver was in during this time
    # period.
    # @param [String] access_token Required parameter: Samsara API access
    # token.
    # @param [HosLogsParam] hos_logs_param Required parameter: Example:
    # @return HosLogsResponse response from the API call
    def create_get_fleet_hos_logs(access_token,
                                  hos_logs_param)
      # Prepare query url.
      _path_url = '/fleet/hos_logs'
      _query_builder = Configuration.base_uri.dup
      _query_builder << _path_url
      _query_builder = APIHelper.append_url_with_query_parameters(
        _query_builder,
        {
          'access_token' => access_token
        },
        array_serialization: Configuration.array_serialization
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/json',
        'content-type' => 'application/json; charset=utf-8'
      }

      # Prepare and execute HttpRequest.
      _request = @http_client.post(
        _query_url,
        headers: _headers,
        parameters: hos_logs_param.to_json
      )
      CustomQueryAuth.apply(_request)
      _context = execute_request(_request)

      # Validate response against endpoint and global error codes.
      unless _context.response.status_code.between?(200, 208)
        raise APIException.new(
          'Unexpected error.',
          _context
        )
      end
      validate_response(_context)

      # Return appropriate response type.
      decoded = APIHelper.json_deserialize(_context.response.raw_body)
      HosLogsResponse.from_hash(decoded)
    end

    # Get the HOS (hours of service) signin and signout logs for the specified
    # driver. Only signout logs include location information.
    # @param [String] access_token Required parameter: Samsara API access
    # token.
    # @param [HosAuthenticationLogsParam] hos_authentication_logs_param Required
    # parameter: Example:
    # @return HosAuthenticationLogsResponse response from the API call
    def create_get_fleet_hos_authentication_logs(access_token,
                                                 hos_authentication_logs_param)
      # Prepare query url.
      _path_url = '/fleet/hos_authentication_logs'
      _query_builder = Configuration.base_uri.dup
      _query_builder << _path_url
      _query_builder = APIHelper.append_url_with_query_parameters(
        _query_builder,
        {
          'access_token' => access_token
        },
        array_serialization: Configuration.array_serialization
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/json',
        'content-type' => 'application/json; charset=utf-8'
      }

      # Prepare and execute HttpRequest.
      _request = @http_client.post(
        _query_url,
        headers: _headers,
        parameters: hos_authentication_logs_param.to_json
      )
      CustomQueryAuth.apply(_request)
      _context = execute_request(_request)

      # Validate response against endpoint and global error codes.
      unless _context.response.status_code.between?(200, 208)
        raise APIException.new(
          'Unexpected error.',
          _context
        )
      end
      validate_response(_context)

      # Return appropriate response type.
      decoded = APIHelper.json_deserialize(_context.response.raw_body)
      HosAuthenticationLogsResponse.from_hash(decoded)
    end

    # Get the distance and time each driver in an organization has driven in a
    # given time period.
    # @param [String] access_token Required parameter: Samsara API access
    # token.
    # @param [DriversSummaryParam] drivers_summary_param Required parameter: Org
    # ID and time range to query.
    # @param [Boolean] snap_to_day_bounds Optional parameter: Snap query result
    # to HOS day boundaries.
    # @return DriversSummaryResponse response from the API call
    def create_get_fleet_drivers_summary(access_token,
                                         drivers_summary_param,
                                         snap_to_day_bounds = nil)
      # Prepare query url.
      _path_url = '/fleet/drivers/summary'
      _query_builder = Configuration.base_uri.dup
      _query_builder << _path_url
      _query_builder = APIHelper.append_url_with_query_parameters(
        _query_builder,
        {
          'access_token' => access_token,
          'snap_to_day_bounds' => snap_to_day_bounds
        },
        array_serialization: Configuration.array_serialization
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/json',
        'content-type' => 'application/json; charset=utf-8'
      }

      # Prepare and execute HttpRequest.
      _request = @http_client.post(
        _query_url,
        headers: _headers,
        parameters: drivers_summary_param.to_json
      )
      CustomQueryAuth.apply(_request)
      _context = execute_request(_request)

      # Validate response against endpoint and global error codes.
      unless _context.response.status_code.between?(200, 208)
        raise APIException.new(
          'Unexpected error.',
          _context
        )
      end
      validate_response(_context)

      # Return appropriate response type.
      decoded = APIHelper.json_deserialize(_context.response.raw_body)
      DriversSummaryResponse.from_hash(decoded)
    end

    # Fetch engine state and aux input data for all vehicles in the group
    # between a start/end time. Data returned may be affected by device
    # connectivity and processing time.
    # @param [String] access_token Required parameter: Samsara API access
    # token.
    # @param [Integer] start_ms Required parameter: Time in Unix epoch
    # milliseconds for the start of the query.
    # @param [Integer] end_ms Required parameter: Time in Unix epoch
    # milliseconds for the end of the query.
    # @param [SeriesEnum] series Optional parameter: Comma-separated list of
    # stat types. Options are engineState, auxInput1, and auxInput2. If this
    # parameter is excluded, all 3 stat types will be returned. Example:
    # series=engineState,auxInput2
    # @param [String] tag_ids Optional parameter: Comma-separated list of tag
    # ids. Example: tagIds=1,2,3
    # @param [String] starting_after Optional parameter: Pagination parameter
    # indicating the cursor position to continue returning results after. Used
    # in conjunction with the 'limit' parameter. Mutually exclusive with
    # 'endingBefore' parameter.
    # @param [String] ending_before Optional parameter: Pagination parameter
    # indicating the cursor position to return results before. Used in
    # conjunction with the 'limit' parameter. Mutually exclusive with
    # 'startingAfter' parameter.
    # @param [Long] limit Optional parameter: Pagination parameter indicating
    # the number of results to return in this request. Used in conjunction with
    # either 'startingAfter' or 'endingBefore'.
    # @return GetVehicleStatsResponse response from the API call
    def get_vehicle_stats(access_token,
                          start_ms,
                          end_ms,
                          series = nil,
                          tag_ids = nil,
                          starting_after = nil,
                          ending_before = nil,
                          limit = nil)
      # Prepare query url.
      _path_url = '/fleet/vehicles/stats'
      _query_builder = Configuration.base_uri.dup
      _query_builder << _path_url
      _query_builder = APIHelper.append_url_with_query_parameters(
        _query_builder,
        {
          'access_token' => access_token,
          'startMs' => start_ms,
          'endMs' => end_ms,
          'series' => series,
          'tagIds' => tag_ids,
          'startingAfter' => starting_after,
          'endingBefore' => ending_before,
          'limit' => limit
        },
        array_serialization: Configuration.array_serialization
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/json'
      }

      # Prepare and execute HttpRequest.
      _request = @http_client.get(
        _query_url,
        headers: _headers
      )
      CustomQueryAuth.apply(_request)
      _context = execute_request(_request)

      # Validate response against endpoint and global error codes.
      unless _context.response.status_code.between?(200, 208)
        raise APIException.new(
          'Unexpected error.',
          _context
        )
      end
      validate_response(_context)

      # Return appropriate response type.
      decoded = APIHelper.json_deserialize(_context.response.raw_body)
      GetVehicleStatsResponse.from_hash(decoded)
    end

    # Reactivate the inactive driver having id.
    # @param [ReactivateDriverParam] reactivate_driver_param Required parameter:
    # Driver reactivation body
    # @param [String] access_token Required parameter: Samsara API access
    # token.
    # @param [String] driver_id_or_external_id Required parameter: ID of the
    # driver.  This must be either the numeric ID generated by Samsara or the
    # external ID of the driver.  External IDs are customer specified key-value
    # pairs.
    # @return Driver response from the API call
    def update_reactivate_driver_by_id(reactivate_driver_param,
                                       access_token,
                                       driver_id_or_external_id)
      # Prepare query url.
      _path_url = '/fleet/drivers/inactive/{driver_id_or_external_id}'
      _path_url = APIHelper.append_url_with_template_parameters(
        _path_url,
        'driver_id_or_external_id' => driver_id_or_external_id
      )
      _query_builder = Configuration.base_uri.dup
      _query_builder << _path_url
      _query_builder = APIHelper.append_url_with_query_parameters(
        _query_builder,
        {
          'access_token' => access_token
        },
        array_serialization: Configuration.array_serialization
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/json',
        'content-type' => 'application/json; charset=utf-8'
      }

      # Prepare and execute HttpRequest.
      _request = @http_client.put(
        _query_url,
        headers: _headers,
        parameters: reactivate_driver_param.to_json
      )
      CustomQueryAuth.apply(_request)
      _context = execute_request(_request)

      # Validate response against endpoint and global error codes.
      unless _context.response.status_code.between?(200, 208)
        raise APIException.new(
          'Unexpected error.',
          _context
        )
      end
      validate_response(_context)

      # Return appropriate response type.
      decoded = APIHelper.json_deserialize(_context.response.raw_body)
      Driver.from_hash(decoded)
    end

    # Fetch all of the documents.
    # @param [String] access_token Required parameter: Samsara API access
    # token.
    # @param [Long] end_ms Optional parameter: Time in unix milliseconds that
    # represents the oldest documents to return. Used in combination with
    # durationMs. Defaults to now.
    # @param [Long] duration_ms Optional parameter: Time in milliseconds that
    # represents the duration before endMs to query. Defaults to 24 hours.
    # @return List of Document response from the API call
    def get_driver_documents_by_org_id(access_token,
                                       end_ms = nil,
                                       duration_ms = nil)
      # Prepare query url.
      _path_url = '/fleet/drivers/documents'
      _query_builder = Configuration.base_uri.dup
      _query_builder << _path_url
      _query_builder = APIHelper.append_url_with_query_parameters(
        _query_builder,
        {
          'access_token' => access_token,
          'endMs' => end_ms,
          'durationMs' => duration_ms
        },
        array_serialization: Configuration.array_serialization
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/json'
      }

      # Prepare and execute HttpRequest.
      _request = @http_client.get(
        _query_url,
        headers: _headers
      )
      CustomQueryAuth.apply(_request)
      _context = execute_request(_request)

      # Validate response against endpoint and global error codes.
      unless _context.response.status_code.between?(200, 208)
        raise APIException.new(
          'Unexpected error.',
          _context
        )
      end
      validate_response(_context)

      # Return appropriate response type.
      decoded = APIHelper.json_deserialize(_context.response.raw_body)
      decoded.map { |element| Document.from_hash(element) }
    end

    # Deactivate a driver with the given id.
    # @param [String] access_token Required parameter: Samsara API access
    # token.
    # @param [String] driver_id_or_external_id Required parameter: ID of the
    # driver.  This must be either the numeric ID generated by Samsara or the
    # external ID of the driver.  External IDs are customer specified key-value
    # pairs.
    # @return void response from the API call
    def delete_deactivate_driver(access_token,
                                 driver_id_or_external_id)
      # Prepare query url.
      _path_url = '/fleet/drivers/{driver_id_or_external_id}'
      _path_url = APIHelper.append_url_with_template_parameters(
        _path_url,
        'driver_id_or_external_id' => driver_id_or_external_id
      )
      _query_builder = Configuration.base_uri.dup
      _query_builder << _path_url
      _query_builder = APIHelper.append_url_with_query_parameters(
        _query_builder,
        {
          'access_token' => access_token
        },
        array_serialization: Configuration.array_serialization
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare and execute HttpRequest.
      _request = @http_client.delete(
        _query_url
      )
      CustomQueryAuth.apply(_request)
      _context = execute_request(_request)

      # Validate response against endpoint and global error codes.
      unless _context.response.status_code.between?(200, 208)
        raise APIException.new(
          'Unexpected error.',
          _context
        )
      end
      validate_response(_context)
    end

    # Fetch the history of a dispatch route.
    # @param [String] access_token Required parameter: Samsara API access
    # token.
    # @param [Long] route_id Required parameter: ID of the route with history.
    # @param [Long] start_time Optional parameter: Timestamp representing the
    # start of the period to fetch, inclusive. Used in combination with
    # end_time. Defaults to 0.
    # @param [Long] end_time Optional parameter: Timestamp representing the end
    # of the period to fetch, inclusive. Used in combination with start_time.
    # Defaults to nowMs.
    # @return DispatchRouteHistory response from the API call
    def get_dispatch_route_history(access_token,
                                   route_id,
                                   start_time = nil,
                                   end_time = nil)
      # Prepare query url.
      _path_url = '/fleet/dispatch/routes/{route_id}/history'
      _path_url = APIHelper.append_url_with_template_parameters(
        _path_url,
        'route_id' => route_id
      )
      _query_builder = Configuration.base_uri.dup
      _query_builder << _path_url
      _query_builder = APIHelper.append_url_with_query_parameters(
        _query_builder,
        {
          'access_token' => access_token,
          'start_time' => start_time,
          'end_time' => end_time
        },
        array_serialization: Configuration.array_serialization
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/json'
      }

      # Prepare and execute HttpRequest.
      _request = @http_client.get(
        _query_url,
        headers: _headers
      )
      CustomQueryAuth.apply(_request)
      _context = execute_request(_request)

      # Validate response against endpoint and global error codes.
      unless _context.response.status_code.between?(200, 208)
        raise APIException.new(
          'Unexpected error.',
          _context
        )
      end
      validate_response(_context)

      # Return appropriate response type.
      decoded = APIHelper.json_deserialize(_context.response.raw_body)
      DispatchRouteHistory.from_hash(decoded)
    end

    # Update a dispatch route and its associated jobs.
    # @param [DispatchRoute] update_dispatch_route_params Required parameter:
    # Example:
    # @param [String] access_token Required parameter: Samsara API access
    # token.
    # @param [Long] route_id Required parameter: ID of the dispatch route.
    # @return DispatchRoute response from the API call
    def update_dispatch_route_by_id(update_dispatch_route_params,
                                    access_token,
                                    route_id)
      # Prepare query url.
      _path_url = '/fleet/dispatch/routes/{route_id}'
      _path_url = APIHelper.append_url_with_template_parameters(
        _path_url,
        'route_id' => route_id
      )
      _query_builder = Configuration.base_uri.dup
      _query_builder << _path_url
      _query_builder = APIHelper.append_url_with_query_parameters(
        _query_builder,
        {
          'access_token' => access_token
        },
        array_serialization: Configuration.array_serialization
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/json',
        'content-type' => 'application/json; charset=utf-8'
      }

      # Prepare and execute HttpRequest.
      _request = @http_client.put(
        _query_url,
        headers: _headers,
        parameters: update_dispatch_route_params.to_json
      )
      CustomQueryAuth.apply(_request)
      _context = execute_request(_request)

      # Validate response against endpoint and global error codes.
      unless _context.response.status_code.between?(200, 208)
        raise APIException.new(
          'Unexpected error.',
          _context
        )
      end
      validate_response(_context)

      # Return appropriate response type.
      decoded = APIHelper.json_deserialize(_context.response.raw_body)
      DispatchRoute.from_hash(decoded)
    end

    # Fetch all updates to a job including route data in the last 24 hours or
    # subsequent to an sequence ID
    # @param [String] access_token Required parameter: Samsara API access
    # token.
    # @param [Long] group_id Optional parameter: Optional group ID if the
    # organization has multiple groups (uncommon).
    # @param [String] sequence_id Optional parameter: Sequence ID from the
    # response payload of the last request. Defaults to fetching updates from
    # last 24 hours.
    # @param [String] include Optional parameter: Optionally set include=route
    # to include route object in response payload.
    # @return AllRouteJobUpdates response from the API call
    def fetch_all_route_job_updates(access_token,
                                    group_id = nil,
                                    sequence_id = nil,
                                    include = nil)
      # Prepare query url.
      _path_url = '/fleet/dispatch/routes/job_updates'
      _query_builder = Configuration.base_uri.dup
      _query_builder << _path_url
      _query_builder = APIHelper.append_url_with_query_parameters(
        _query_builder,
        {
          'access_token' => access_token,
          'group_id' => group_id,
          'sequence_id' => sequence_id,
          'include' => include
        },
        array_serialization: Configuration.array_serialization
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/json'
      }

      # Prepare and execute HttpRequest.
      _request = @http_client.get(
        _query_url,
        headers: _headers
      )
      CustomQueryAuth.apply(_request)
      _context = execute_request(_request)

      # Validate response against endpoint and global error codes.
      unless _context.response.status_code.between?(200, 208)
        raise APIException.new(
          'Unexpected error.',
          _context
        )
      end
      validate_response(_context)

      # Return appropriate response type.
      decoded = APIHelper.json_deserialize(_context.response.raw_body)
      AllRouteJobUpdates.from_hash(decoded)
    end

    # Fetch all of the dispatch routes for the group.
    # @param [String] access_token Required parameter: Samsara API access
    # token.
    # @param [Long] group_id Optional parameter: Optional group ID if the
    # organization has multiple groups (uncommon).
    # @param [Long] end_time Optional parameter: Time in unix milliseconds that
    # represents the oldest routes to return. Used in combination with duration.
    # Defaults to now.
    # @param [Long] duration Optional parameter: Time in milliseconds that
    # represents the duration before end_time to query. Defaults to 24 hours.
    # @return List of DispatchRoute response from the API call
    def fetch_all_dispatch_routes(access_token,
                                  group_id = nil,
                                  end_time = nil,
                                  duration = nil)
      # Prepare query url.
      _path_url = '/fleet/dispatch/routes'
      _query_builder = Configuration.base_uri.dup
      _query_builder << _path_url
      _query_builder = APIHelper.append_url_with_query_parameters(
        _query_builder,
        {
          'access_token' => access_token,
          'group_id' => group_id,
          'end_time' => end_time,
          'duration' => duration
        },
        array_serialization: Configuration.array_serialization
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/json'
      }

      # Prepare and execute HttpRequest.
      _request = @http_client.get(
        _query_url,
        headers: _headers
      )
      CustomQueryAuth.apply(_request)
      _context = execute_request(_request)

      # Validate response against endpoint and global error codes.
      unless _context.response.status_code.between?(200, 208)
        raise APIException.new(
          'Unexpected error.',
          _context
        )
      end
      validate_response(_context)

      # Return appropriate response type.
      decoded = APIHelper.json_deserialize(_context.response.raw_body)
      decoded.map { |element| DispatchRoute.from_hash(element) }
    end

    # Fetch the reefer-specific stats of an asset.
    # @param [String] access_token Required parameter: Samsara API access
    # token.
    # @param [Long] asset_id Required parameter: ID of the asset
    # @param [Long] start_ms Required parameter: Timestamp in milliseconds
    # representing the start of the period to fetch, inclusive. Used in
    # combination with endMs.
    # @param [Long] end_ms Required parameter: Timestamp in milliseconds
    # representing the end of the period to fetch, inclusive. Used in
    # combination with startMs.
    # @return AssetReeferResponse response from the API call
    def get_asset_reefer(access_token,
                         asset_id,
                         start_ms,
                         end_ms)
      # Prepare query url.
      _path_url = '/fleet/assets/{asset_id}/reefer'
      _path_url = APIHelper.append_url_with_template_parameters(
        _path_url,
        'asset_id' => asset_id
      )
      _query_builder = Configuration.base_uri.dup
      _query_builder << _path_url
      _query_builder = APIHelper.append_url_with_query_parameters(
        _query_builder,
        {
          'access_token' => access_token,
          'startMs' => start_ms,
          'endMs' => end_ms
        },
        array_serialization: Configuration.array_serialization
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/json'
      }

      # Prepare and execute HttpRequest.
      _request = @http_client.get(
        _query_url,
        headers: _headers
      )
      CustomQueryAuth.apply(_request)
      _context = execute_request(_request)

      # Validate response against endpoint and global error codes.
      unless _context.response.status_code.between?(200, 208)
        raise APIException.new(
          'Unexpected error.',
          _context
        )
      end
      validate_response(_context)

      # Return appropriate response type.
      decoded = APIHelper.json_deserialize(_context.response.raw_body)
      AssetReeferResponse.from_hash(decoded)
    end

    # Fetch the historical locations for the asset.
    # @param [String] access_token Required parameter: Samsara API access
    # token.
    # @param [Long] asset_id Required parameter: ID of the asset
    # @param [Long] start_ms Required parameter: Timestamp in milliseconds
    # representing the start of the period to fetch, inclusive. Used in
    # combination with endMs.
    # @param [Long] end_ms Required parameter: Timestamp in milliseconds
    # representing the end of the period to fetch, inclusive. Used in
    # combination with startMs.
    # @return List of AssetLocationResponse response from the API call
    def get_asset_location(access_token,
                           asset_id,
                           start_ms,
                           end_ms)
      # Prepare query url.
      _path_url = '/fleet/assets/{asset_id}/locations'
      _path_url = APIHelper.append_url_with_template_parameters(
        _path_url,
        'asset_id' => asset_id
      )
      _query_builder = Configuration.base_uri.dup
      _query_builder << _path_url
      _query_builder = APIHelper.append_url_with_query_parameters(
        _query_builder,
        {
          'access_token' => access_token,
          'startMs' => start_ms,
          'endMs' => end_ms
        },
        array_serialization: Configuration.array_serialization
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/json'
      }

      # Prepare and execute HttpRequest.
      _request = @http_client.get(
        _query_url,
        headers: _headers
      )
      CustomQueryAuth.apply(_request)
      _context = execute_request(_request)

      # Validate response against endpoint and global error codes.
      unless _context.response.status_code.between?(200, 208)
        raise APIException.new(
          'Unexpected error.',
          _context
        )
      end
      validate_response(_context)

      # Return appropriate response type.
      decoded = APIHelper.json_deserialize(_context.response.raw_body)
      decoded.map { |element| AssetLocationResponse.from_hash(element) }
    end

    # Fetch driver by id.
    # @param [String] access_token Required parameter: Samsara API access
    # token.
    # @param [String] driver_id_or_external_id Required parameter: ID of the
    # driver.  This must be either the numeric ID generated by Samsara or the
    # external ID of the driver.  External IDs are customer specified key-value
    # pairs.
    # @return Driver response from the API call
    def get_driver_by_id(access_token,
                         driver_id_or_external_id)
      # Prepare query url.
      _path_url = '/fleet/drivers/{driver_id_or_external_id}'
      _path_url = APIHelper.append_url_with_template_parameters(
        _path_url,
        'driver_id_or_external_id' => driver_id_or_external_id
      )
      _query_builder = Configuration.base_uri.dup
      _query_builder << _path_url
      _query_builder = APIHelper.append_url_with_query_parameters(
        _query_builder,
        {
          'access_token' => access_token
        },
        array_serialization: Configuration.array_serialization
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/json'
      }

      # Prepare and execute HttpRequest.
      _request = @http_client.get(
        _query_url,
        headers: _headers
      )
      CustomQueryAuth.apply(_request)
      _context = execute_request(_request)

      # Validate response against endpoint and global error codes.
      unless _context.response.status_code.between?(200, 208)
        raise APIException.new(
          'Unexpected error.',
          _context
        )
      end
      validate_response(_context)

      # Return appropriate response type.
      decoded = APIHelper.json_deserialize(_context.response.raw_body)
      Driver.from_hash(decoded)
    end

    # Fetch deactivated driver by id.
    # @param [String] access_token Required parameter: Samsara API access
    # token.
    # @param [String] driver_id_or_external_id Required parameter: ID of the
    # driver.  This must be either the numeric ID generated by Samsara or the
    # external ID of the driver.  External IDs are customer specified key-value
    # pairs.
    # @return Driver response from the API call
    def get_deactivated_driver_by_id(access_token,
                                     driver_id_or_external_id)
      # Prepare query url.
      _path_url = '/fleet/drivers/inactive/{driver_id_or_external_id}'
      _path_url = APIHelper.append_url_with_template_parameters(
        _path_url,
        'driver_id_or_external_id' => driver_id_or_external_id
      )
      _query_builder = Configuration.base_uri.dup
      _query_builder << _path_url
      _query_builder = APIHelper.append_url_with_query_parameters(
        _query_builder,
        {
          'access_token' => access_token
        },
        array_serialization: Configuration.array_serialization
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/json'
      }

      # Prepare and execute HttpRequest.
      _request = @http_client.get(
        _query_url,
        headers: _headers
      )
      CustomQueryAuth.apply(_request)
      _context = execute_request(_request)

      # Validate response against endpoint and global error codes.
      unless _context.response.status_code.between?(200, 208)
        raise APIException.new(
          'Unexpected error.',
          _context
        )
      end
      validate_response(_context)

      # Return appropriate response type.
      decoded = APIHelper.json_deserialize(_context.response.raw_body)
      Driver.from_hash(decoded)
    end

    # Fetch all deactivated drivers for the group.
    # @param [String] access_token Required parameter: Samsara API access
    # token.
    # @param [Long] group_id Optional parameter: Optional group ID if the
    # organization has multiple groups (uncommon).
    # @return List of Driver response from the API call
    def get_all_deactivated_drivers(access_token,
                                    group_id = nil)
      # Prepare query url.
      _path_url = '/fleet/drivers/inactive'
      _query_builder = Configuration.base_uri.dup
      _query_builder << _path_url
      _query_builder = APIHelper.append_url_with_query_parameters(
        _query_builder,
        {
          'access_token' => access_token,
          'group_id' => group_id
        },
        array_serialization: Configuration.array_serialization
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/json'
      }

      # Prepare and execute HttpRequest.
      _request = @http_client.get(
        _query_url,
        headers: _headers
      )
      CustomQueryAuth.apply(_request)
      _context = execute_request(_request)

      # Validate response against endpoint and global error codes.
      unless _context.response.status_code.between?(200, 208)
        raise APIException.new(
          'Unexpected error.',
          _context
        )
      end
      validate_response(_context)

      # Return appropriate response type.
      decoded = APIHelper.json_deserialize(_context.response.raw_body)
      decoded.map { |element| Driver.from_hash(element) }
    end

    # Create a new driver.
    # @param [String] access_token Required parameter: Samsara API access
    # token.
    # @param [DriverForCreate] create_driver_param Required parameter: Driver
    # creation body
    # @return Driver response from the API call
    def create_driver(access_token,
                      create_driver_param)
      # Prepare query url.
      _path_url = '/fleet/drivers/create'
      _query_builder = Configuration.base_uri.dup
      _query_builder << _path_url
      _query_builder = APIHelper.append_url_with_query_parameters(
        _query_builder,
        {
          'access_token' => access_token
        },
        array_serialization: Configuration.array_serialization
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/json',
        'content-type' => 'application/json; charset=utf-8'
      }

      # Prepare and execute HttpRequest.
      _request = @http_client.post(
        _query_url,
        headers: _headers,
        parameters: create_driver_param.to_json
      )
      CustomQueryAuth.apply(_request)
      _context = execute_request(_request)

      # Validate response against endpoint and global error codes.
      unless _context.response.status_code.between?(200, 208)
        raise APIException.new(
          'Unexpected error.',
          _context
        )
      end
      validate_response(_context)

      # Return appropriate response type.
      decoded = APIHelper.json_deserialize(_context.response.raw_body)
      Driver.from_hash(decoded)
    end

    # Get all the drivers for the specified group.
    # @param [String] access_token Required parameter: Samsara API access
    # token.
    # @param [GroupDriversParam] group_drivers_param Required parameter:
    # Example:
    # @return DriversResponse response from the API call
    def create_get_fleet_drivers(access_token,
                                 group_drivers_param)
      # Prepare query url.
      _path_url = '/fleet/drivers'
      _query_builder = Configuration.base_uri.dup
      _query_builder << _path_url
      _query_builder = APIHelper.append_url_with_query_parameters(
        _query_builder,
        {
          'access_token' => access_token
        },
        array_serialization: Configuration.array_serialization
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/json',
        'content-type' => 'application/json; charset=utf-8'
      }

      # Prepare and execute HttpRequest.
      _request = @http_client.post(
        _query_url,
        headers: _headers,
        parameters: group_drivers_param.to_json
      )
      CustomQueryAuth.apply(_request)
      _context = execute_request(_request)

      # Validate response against endpoint and global error codes.
      unless _context.response.status_code.between?(200, 208)
        raise APIException.new(
          'Unexpected error.',
          _context
        )
      end
      validate_response(_context)

      # Return appropriate response type.
      decoded = APIHelper.json_deserialize(_context.response.raw_body)
      DriversResponse.from_hash(decoded)
    end

    # Delete a dispatch route and its associated jobs.
    # @param [String] access_token Required parameter: Samsara API access
    # token.
    # @param [Long] route_id Required parameter: ID of the dispatch route.
    # @return void response from the API call
    def delete_dispatch_route_by_id(access_token,
                                    route_id)
      # Prepare query url.
      _path_url = '/fleet/dispatch/routes/{route_id}'
      _path_url = APIHelper.append_url_with_template_parameters(
        _path_url,
        'route_id' => route_id
      )
      _query_builder = Configuration.base_uri.dup
      _query_builder << _path_url
      _query_builder = APIHelper.append_url_with_query_parameters(
        _query_builder,
        {
          'access_token' => access_token
        },
        array_serialization: Configuration.array_serialization
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare and execute HttpRequest.
      _request = @http_client.delete(
        _query_url
      )
      CustomQueryAuth.apply(_request)
      _context = execute_request(_request)

      # Validate response against endpoint and global error codes.
      unless _context.response.status_code.between?(200, 208)
        raise APIException.new(
          'Unexpected error.',
          _context
        )
      end
      validate_response(_context)
    end

    # Fetch a dispatch route by id.
    # @param [String] access_token Required parameter: Samsara API access
    # token.
    # @param [Long] route_id Required parameter: ID of the dispatch route.
    # @return DispatchRoute response from the API call
    def get_dispatch_route_by_id(access_token,
                                 route_id)
      # Prepare query url.
      _path_url = '/fleet/dispatch/routes/{route_id}'
      _path_url = APIHelper.append_url_with_template_parameters(
        _path_url,
        'route_id' => route_id
      )
      _query_builder = Configuration.base_uri.dup
      _query_builder << _path_url
      _query_builder = APIHelper.append_url_with_query_parameters(
        _query_builder,
        {
          'access_token' => access_token
        },
        array_serialization: Configuration.array_serialization
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/json'
      }

      # Prepare and execute HttpRequest.
      _request = @http_client.get(
        _query_url,
        headers: _headers
      )
      CustomQueryAuth.apply(_request)
      _context = execute_request(_request)

      # Validate response against endpoint and global error codes.
      unless _context.response.status_code.between?(200, 208)
        raise APIException.new(
          'Unexpected error.',
          _context
        )
      end
      validate_response(_context)

      # Return appropriate response type.
      decoded = APIHelper.json_deserialize(_context.response.raw_body)
      DispatchRoute.from_hash(decoded)
    end

    # Create a new dispatch route.
    # @param [String] access_token Required parameter: Samsara API access
    # token.
    # @param [DispatchRouteCreate] create_dispatch_route_params Required
    # parameter: Example:
    # @return DispatchRoute response from the API call
    def create_dispatch_route(access_token,
                              create_dispatch_route_params)
      # Prepare query url.
      _path_url = '/fleet/dispatch/routes'
      _query_builder = Configuration.base_uri.dup
      _query_builder << _path_url
      _query_builder = APIHelper.append_url_with_query_parameters(
        _query_builder,
        {
          'access_token' => access_token
        },
        array_serialization: Configuration.array_serialization
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/json',
        'content-type' => 'application/json; charset=utf-8'
      }

      # Prepare and execute HttpRequest.
      _request = @http_client.post(
        _query_url,
        headers: _headers,
        parameters: create_dispatch_route_params.to_json
      )
      CustomQueryAuth.apply(_request)
      _context = execute_request(_request)

      # Validate response against endpoint and global error codes.
      unless _context.response.status_code.between?(200, 208)
        raise APIException.new(
          'Unexpected error.',
          _context
        )
      end
      validate_response(_context)

      # Return appropriate response type.
      decoded = APIHelper.json_deserialize(_context.response.raw_body)
      DispatchRoute.from_hash(decoded)
    end

    # Fetch current locations of all assets for the group.
    # @param [String] access_token Required parameter: Samsara API access
    # token.
    # @return GetAllAssetCurrentLocationsResponse response from the API call
    def get_all_asset_current_locations(access_token)
      # Prepare query url.
      _path_url = '/fleet/assets/locations'
      _query_builder = Configuration.base_uri.dup
      _query_builder << _path_url
      _query_builder = APIHelper.append_url_with_query_parameters(
        _query_builder,
        {
          'access_token' => access_token
        },
        array_serialization: Configuration.array_serialization
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/json'
      }

      # Prepare and execute HttpRequest.
      _request = @http_client.get(
        _query_url,
        headers: _headers
      )
      CustomQueryAuth.apply(_request)
      _context = execute_request(_request)

      # Validate response against endpoint and global error codes.
      unless _context.response.status_code.between?(200, 208)
        raise APIException.new(
          'Unexpected error.',
          _context
        )
      end
      validate_response(_context)

      # Return appropriate response type.
      decoded = APIHelper.json_deserialize(_context.response.raw_body)
      GetAllAssetCurrentLocationsResponse.from_hash(decoded)
    end

    # Fetch all of the assets for the group.
    # @param [String] access_token Required parameter: Samsara API access
    # token.
    # @return GetAllAssetsResponse response from the API call
    def get_all_assets(access_token)
      # Prepare query url.
      _path_url = '/fleet/assets'
      _query_builder = Configuration.base_uri.dup
      _query_builder << _path_url
      _query_builder = APIHelper.append_url_with_query_parameters(
        _query_builder,
        {
          'access_token' => access_token
        },
        array_serialization: Configuration.array_serialization
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/json'
      }

      # Prepare and execute HttpRequest.
      _request = @http_client.get(
        _query_url,
        headers: _headers
      )
      CustomQueryAuth.apply(_request)
      _context = execute_request(_request)

      # Validate response against endpoint and global error codes.
      unless _context.response.status_code.between?(200, 208)
        raise APIException.new(
          'Unexpected error.',
          _context
        )
      end
      validate_response(_context)

      # Return appropriate response type.
      decoded = APIHelper.json_deserialize(_context.response.raw_body)
      GetAllAssetsResponse.from_hash(decoded)
    end

    # This method adds an address book entry to the specified group.
    # @param [String] access_token Required parameter: Samsara API access
    # token.
    # @param [AddressParam] address_param Required parameter: Example:
    # @return void response from the API call
    def add_fleet_address(access_token,
                          address_param)
      # Prepare query url.
      _path_url = '/fleet/add_address'
      _query_builder = Configuration.base_uri.dup
      _query_builder << _path_url
      _query_builder = APIHelper.append_url_with_query_parameters(
        _query_builder,
        {
          'access_token' => access_token
        },
        array_serialization: Configuration.array_serialization
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'content-type' => 'application/json; charset=utf-8'
      }

      # Prepare and execute HttpRequest.
      _request = @http_client.post(
        _query_url,
        headers: _headers,
        parameters: address_param.to_json
      )
      CustomQueryAuth.apply(_request)
      _context = execute_request(_request)

      # Validate response against endpoint and global error codes.
      unless _context.response.status_code.between?(200, 208)
        raise APIException.new(
          'Unexpected error.',
          _context
        )
      end
      validate_response(_context)
    end

    # Fetch a contact by its id.
    # @param [String] access_token Required parameter: Samsara API access
    # token.
    # @param [Long] contact_id Required parameter: ID of the contact
    # @return Contact response from the API call
    def get_organization_contact(access_token,
                                 contact_id)
      # Prepare query url.
      _path_url = '/contacts/{contact_id}'
      _path_url = APIHelper.append_url_with_template_parameters(
        _path_url,
        'contact_id' => contact_id
      )
      _query_builder = Configuration.base_uri.dup
      _query_builder << _path_url
      _query_builder = APIHelper.append_url_with_query_parameters(
        _query_builder,
        {
          'access_token' => access_token
        },
        array_serialization: Configuration.array_serialization
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/json'
      }

      # Prepare and execute HttpRequest.
      _request = @http_client.get(
        _query_url,
        headers: _headers
      )
      CustomQueryAuth.apply(_request)
      _context = execute_request(_request)

      # Validate response against endpoint and global error codes.
      unless _context.response.status_code.between?(200, 208)
        raise APIException.new(
          'Unexpected error.',
          _context
        )
      end
      validate_response(_context)

      # Return appropriate response type.
      decoded = APIHelper.json_deserialize(_context.response.raw_body)
      Contact.from_hash(decoded)
    end

    # Fetch all contacts for the organization.
    # @param [String] access_token Required parameter: Samsara API access
    # token.
    # @return List of Contact response from the API call
    def list_contacts(access_token)
      # Prepare query url.
      _path_url = '/contacts'
      _query_builder = Configuration.base_uri.dup
      _query_builder << _path_url
      _query_builder = APIHelper.append_url_with_query_parameters(
        _query_builder,
        {
          'access_token' => access_token
        },
        array_serialization: Configuration.array_serialization
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/json'
      }

      # Prepare and execute HttpRequest.
      _request = @http_client.get(
        _query_url,
        headers: _headers
      )
      CustomQueryAuth.apply(_request)
      _context = execute_request(_request)

      # Validate response against endpoint and global error codes.
      unless _context.response.status_code.between?(200, 208)
        raise APIException.new(
          'Unexpected error.',
          _context
        )
      end
      validate_response(_context)

      # Return appropriate response type.
      decoded = APIHelper.json_deserialize(_context.response.raw_body)
      decoded.map { |element| Contact.from_hash(element) }
    end

    # Delete an address.
    # @param [String] access_token Required parameter: Samsara API access
    # token.
    # @param [Long] address_id Required parameter: ID of the address/geofence
    # @return void response from the API call
    def delete_organization_address(access_token,
                                    address_id)
      # Prepare query url.
      _path_url = '/addresses/{addressId}'
      _path_url = APIHelper.append_url_with_template_parameters(
        _path_url,
        'addressId' => address_id
      )
      _query_builder = Configuration.base_uri.dup
      _query_builder << _path_url
      _query_builder = APIHelper.append_url_with_query_parameters(
        _query_builder,
        {
          'access_token' => access_token
        },
        array_serialization: Configuration.array_serialization
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare and execute HttpRequest.
      _request = @http_client.delete(
        _query_url
      )
      CustomQueryAuth.apply(_request)
      _context = execute_request(_request)

      # Validate response against endpoint and global error codes.
      unless _context.response.status_code.between?(200, 208)
        raise APIException.new(
          'Unexpected error.',
          _context
        )
      end
      validate_response(_context)
    end

    # Fetch an address by its id.
    # @param [String] access_token Required parameter: Samsara API access
    # token.
    # @param [Long] address_id Required parameter: ID of the address/geofence
    # @return Address response from the API call
    def get_organization_address(access_token,
                                 address_id)
      # Prepare query url.
      _path_url = '/addresses/{addressId}'
      _path_url = APIHelper.append_url_with_template_parameters(
        _path_url,
        'addressId' => address_id
      )
      _query_builder = Configuration.base_uri.dup
      _query_builder << _path_url
      _query_builder = APIHelper.append_url_with_query_parameters(
        _query_builder,
        {
          'access_token' => access_token
        },
        array_serialization: Configuration.array_serialization
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/json'
      }

      # Prepare and execute HttpRequest.
      _request = @http_client.get(
        _query_url,
        headers: _headers
      )
      CustomQueryAuth.apply(_request)
      _context = execute_request(_request)

      # Validate response against endpoint and global error codes.
      unless _context.response.status_code.between?(200, 208)
        raise APIException.new(
          'Unexpected error.',
          _context
        )
      end
      validate_response(_context)

      # Return appropriate response type.
      decoded = APIHelper.json_deserialize(_context.response.raw_body)
      Address.from_hash(decoded)
    end

    # Update the name, formatted address, geofence, notes, or tag and contact
    # Ids for an address. The set of tags or contacts associated with this
    # address will be updated to exactly match the list of IDs passed in. To
    # remove all tags or contacts from an address, pass an empty list; to remove
    # notes, pass an empty string.
    # @param [String] access_token Required parameter: Samsara API access
    # token.
    # @param [Address1] address Required parameter: Update parts of an address's
    # value. If the geofence 'circle' or 'polygon' key is specified, the update
    # will change the type of geofence accordingly.
    # @param [Long] address_id Required parameter: ID of the address/geofence
    # @return void response from the API call
    def update_organization_address(access_token,
                                    address,
                                    address_id)
      # Prepare query url.
      _path_url = '/addresses/{addressId}'
      _path_url = APIHelper.append_url_with_template_parameters(
        _path_url,
        'addressId' => address_id
      )
      _query_builder = Configuration.base_uri.dup
      _query_builder << _path_url
      _query_builder = APIHelper.append_url_with_query_parameters(
        _query_builder,
        {
          'access_token' => access_token
        },
        array_serialization: Configuration.array_serialization
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'content-type' => 'application/json; charset=utf-8'
      }

      # Prepare and execute HttpRequest.
      _request = @http_client.patch(
        _query_url,
        headers: _headers,
        parameters: address.to_json
      )
      CustomQueryAuth.apply(_request)
      _context = execute_request(_request)

      # Validate response against endpoint and global error codes.
      unless _context.response.status_code.between?(200, 208)
        raise APIException.new(
          'Unexpected error.',
          _context
        )
      end
      validate_response(_context)
    end

    # Fetch all addresses/geofences for the organization. An address contains
    # either a circle or polygon geofence describing the address boundaries.
    # @param [String] access_token Required parameter: Samsara API access
    # token.
    # @return List of Address response from the API call
    def get_organization_addresses(access_token)
      # Prepare query url.
      _path_url = '/addresses'
      _query_builder = Configuration.base_uri.dup
      _query_builder << _path_url
      _query_builder = APIHelper.append_url_with_query_parameters(
        _query_builder,
        {
          'access_token' => access_token
        },
        array_serialization: Configuration.array_serialization
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/json'
      }

      # Prepare and execute HttpRequest.
      _request = @http_client.get(
        _query_url,
        headers: _headers
      )
      CustomQueryAuth.apply(_request)
      _context = execute_request(_request)

      # Validate response against endpoint and global error codes.
      unless _context.response.status_code.between?(200, 208)
        raise APIException.new(
          'Unexpected error.',
          _context
        )
      end
      validate_response(_context)

      # Return appropriate response type.
      decoded = APIHelper.json_deserialize(_context.response.raw_body)
      decoded.map { |element| Address.from_hash(element) }
    end

    # Add one or more addresses to the organization
    # @param [String] access_token Required parameter: Samsara API access
    # token.
    # @param [Addresses] addresses Required parameter: List of
    # addresses/geofences to add. Geofences can be circular or a polygon.  For
    # each address, only one of 'circle' or 'polygon' should be provided. If
    # both are provided, the geofence will be saved as a polygon.
    # @return List of Address response from the API call
    def add_organization_addresses(access_token,
                                   addresses)
      # Prepare query url.
      _path_url = '/addresses'
      _query_builder = Configuration.base_uri.dup
      _query_builder << _path_url
      _query_builder = APIHelper.append_url_with_query_parameters(
        _query_builder,
        {
          'access_token' => access_token
        },
        array_serialization: Configuration.array_serialization
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/json',
        'content-type' => 'application/json; charset=utf-8'
      }

      # Prepare and execute HttpRequest.
      _request = @http_client.post(
        _query_url,
        headers: _headers,
        parameters: addresses.to_json
      )
      CustomQueryAuth.apply(_request)
      _context = execute_request(_request)

      # Validate response against endpoint and global error codes.
      unless _context.response.status_code.between?(200, 208)
        raise APIException.new(
          'Unexpected error.',
          _context
        )
      end
      validate_response(_context)

      # Return appropriate response type.
      decoded = APIHelper.json_deserialize(_context.response.raw_body)
      decoded.map { |element| Address.from_hash(element) }
    end
  end
end
