/**
 * SamsaraAPILib
 *
 * This file was automatically generated by APIMATIC v2.0 ( https://apimatic.io ).
 */

;(function (angular) {
'use strict';

angular.module('SamsaraAPILib')
    .factory('FleetController', ['$q', 'Configuration', 'HttpClient', 'APIHelper', 'BaseController', FleetController
    ]);

    function FleetController($q, Configuration, HttpClient, APIHelper, BaseController) {
        return {
            /**
             * Fetch all of the document types.
             *
             *
             * @return {promise<DocumentType>}
             */
            getDriverDocumentTypesByOrgId: function () {

                //Create promise to return
                var _deffered = $q.defer();
                
                //prepare query string for API call
                var _baseUri = Configuration.BASEURI;
                var _queryBuilder = _baseUri + '/fleet/drivers/document_types';
                
                // Process query parameters
                _queryBuilder = APIHelper.appendUrlWithQueryParameters(_queryBuilder, {
                    'access_token': Configuration.accessToken
                });

                //validate and preprocess url
                var _queryUrl = APIHelper.cleanUrl(_queryBuilder);
                
                // prepare headers
                var _headers = {
                    'accept': 'application/json'
                };

                // prepare and invoke the API call request to fetch the response
                var _config = {
                    method: 'GET',
                    queryUrl: _queryUrl,
                    headers: _headers,
                };
                
                var _response = new HttpClient(_config);
                
                //process response
                _response.then(function success(_result) {
                    var parsed = _result.body;
                    parsed = parsed.map(function(model){
                        return BaseController.getObjectMapper().mapObject(model, 'DocumentType');
                    });
                    _result.body = parsed;
                    _deffered.resolve(_result);
                }, function error(_result){
                    // Error handling for custom HTTP status codes
                     else {
                        _deffered.reject(APIHelper.appendContext({
                            errorMessage:'HTTP Response Not OK',
                            errorCode: _result.code,
                            errorResponse: _result.message
                        }, _result.getContext()));
                    }
                });
                
                return _deffered.promise;
            },
            /**
             * Fetch locations for a given vehicle between a start/end time. The maximum query duration is one hour.
             *
             * @param {string} accessToken Samsara API access token.
             * @param {long} vehicleId ID of the vehicle with the associated routes.
             * @param {long} startMs Time in Unix epoch milliseconds for the start of the query (cannot exceed 1
             * hour)
             * @param {long} endMs Time in Unix epoch milliseconds for the end of the query (cannot exceed 1 hour)
             *
             * @return {promise<FleetVehicleLocation>}
             */
            getVehicleLocations: function (accessToken, vehicleId, startMs, endMs) {

                //Create promise to return
                var _deffered = $q.defer();
                
                //prepare query string for API call
                var _baseUri = Configuration.BASEURI;
                var _queryBuilder = _baseUri + '/fleet/vehicles/{vehicle_id}/locations';
                
                // Process template parameters
                _queryBuilder = APIHelper.appendUrlWithTemplateParameters(_queryBuilder, {
                    'vehicle_id': vehicleId
                });

                // Process query parameters
                _queryBuilder = APIHelper.appendUrlWithQueryParameters(_queryBuilder, {
                    'access_token': accessToken,
                    'startMs': startMs,
                    'endMs': endMs
                });

                //validate and preprocess url
                var _queryUrl = APIHelper.cleanUrl(_queryBuilder);
                
                // prepare headers
                var _headers = {
                    'accept': 'application/json'
                };

                // prepare and invoke the API call request to fetch the response
                var _config = {
                    method: 'GET',
                    queryUrl: _queryUrl,
                    headers: _headers,
                };
                
                var _response = new HttpClient(_config);
                
                //process response
                _response.then(function success(_result) {
                    var parsed = _result.body;
                    parsed = parsed.map(function(model){
                        return BaseController.getObjectMapper().mapObject(model, 'FleetVehicleLocation');
                    });
                    _result.body = parsed;
                    _deffered.resolve(_result);
                }, function error(_result){
                    // Error handling for custom HTTP status codes
                     else {
                        _deffered.reject(APIHelper.appendContext({
                            errorMessage:'HTTP Response Not OK',
                            errorCode: _result.code,
                            errorResponse: _result.message
                        }, _result.getContext()));
                    }
                });
                
                return _deffered.promise;
            },
            /**
             * Create a new dispatch route for the vehicle with vehicle_id.
             *
             * @param {DispatchRouteCreate} createDispatchRouteParams TODO: type description here
             * @param {string} accessToken Samsara API access token.
             * @param {long} vehicleId ID of the vehicle with the associated routes.
             *
             * @return {promise<DispatchRoute>}
             */
            createVehicleDispatchRoute: function (createDispatchRouteParams, accessToken, vehicleId) {

                //Create promise to return
                var _deffered = $q.defer();
                
                //prepare query string for API call
                var _baseUri = Configuration.BASEURI;
                var _queryBuilder = _baseUri + '/fleet/vehicles/{vehicle_id}/dispatch/routes';
                
                // Process template parameters
                _queryBuilder = APIHelper.appendUrlWithTemplateParameters(_queryBuilder, {
                    'vehicle_id': vehicleId
                });

                // Process query parameters
                _queryBuilder = APIHelper.appendUrlWithQueryParameters(_queryBuilder, {
                    'access_token': accessToken
                });

                //validate and preprocess url
                var _queryUrl = APIHelper.cleanUrl(_queryBuilder);
                
                // prepare headers
                var _headers = {
                    'accept': 'application/json',
                    'content-type': 'application/json; charset=utf-8'
                };

                // Remove null values
                APIHelper.cleanObject(createDispatchRouteParams);

                // prepare and invoke the API call request to fetch the response
                var _config = {
                    method: 'POST',
                    queryUrl: _queryUrl,
                    headers: _headers,
                    body: createDispatchRouteParams.toJSON()
                };
                
                var _response = new HttpClient(_config);
                
                //process response
                _response.then(function success(_result) {
                    var parsed = _result.body;
                    parsed = BaseController.getObjectMapper().mapObject(parsed, 'DispatchRoute');
                    _result.body = parsed;
                    _deffered.resolve(_result);
                }, function error(_result){
                    // Error handling for custom HTTP status codes
                     else {
                        _deffered.reject(APIHelper.appendContext({
                            errorMessage:'HTTP Response Not OK',
                            errorCode: _result.code,
                            errorResponse: _result.message
                        }, _result.getContext()));
                    }
                });
                
                return _deffered.promise;
            },
            /**
             * Fetch all of the dispatch routes for a given vehicle.
             *
             * @param {string} accessToken Samsara API access token.
             * @param {long} vehicleId ID of the vehicle with the associated routes.
             * @param {long|null} endTime [Optional] Time in unix milliseconds that represents the oldest routes to
             * return. Used in combination with duration. Defaults to now.
             * @param {long|null} duration [Optional] Time in milliseconds that represents the duration before
             * end_time to query. Defaults to 24 hours.
             *
             * @return {promise<DispatchRoute>}
             */
            getDispatchRoutesByVehicleId: function (accessToken, vehicleId, endTime, duration) {

                //Create promise to return
                var _deffered = $q.defer();
                
                //prepare query string for API call
                var _baseUri = Configuration.BASEURI;
                var _queryBuilder = _baseUri + '/fleet/vehicles/{vehicle_id}/dispatch/routes';
                
                // Process template parameters
                _queryBuilder = APIHelper.appendUrlWithTemplateParameters(_queryBuilder, {
                    'vehicle_id': vehicleId
                });

                // Process query parameters
                _queryBuilder = APIHelper.appendUrlWithQueryParameters(_queryBuilder, {
                    'access_token': accessToken,
                    'end_time': endTime,
                    'duration': duration
                });

                //validate and preprocess url
                var _queryUrl = APIHelper.cleanUrl(_queryBuilder);
                
                // prepare headers
                var _headers = {
                    'accept': 'application/json'
                };

                // prepare and invoke the API call request to fetch the response
                var _config = {
                    method: 'GET',
                    queryUrl: _queryUrl,
                    headers: _headers,
                };
                
                var _response = new HttpClient(_config);
                
                //process response
                _response.then(function success(_result) {
                    var parsed = _result.body;
                    parsed = parsed.map(function(model){
                        return BaseController.getObjectMapper().mapObject(model, 'DispatchRoute');
                    });
                    _result.body = parsed;
                    _deffered.resolve(_result);
                }, function error(_result){
                    // Error handling for custom HTTP status codes
                     else {
                        _deffered.reject(APIHelper.appendContext({
                            errorMessage:'HTTP Response Not OK',
                            errorCode: _result.code,
                            errorResponse: _result.message
                        }, _result.getContext()));
                    }
                });
                
                return _deffered.promise;
            },
            /**
             * Updates the specified vehicle using JSON merge patch format. See IETF RFC 7396: https://tools.ietf.
             * org/html/rfc7396.
             *
             * @param {string} accessToken Samsara API access token.
             * @param {string} vehicleIdOrExternalId ID of the vehicle.  This must be either the numeric ID
             * generated by Samsara or the external ID of the vehicle.
             * External IDs are customer specified key-value pairs.
             * @param {Data} data TODO: type description here
             *
             * @return {promise<FleetVehicleResponse>}
             */
            patchFleetVehicle: function (accessToken, vehicleIdOrExternalId, data) {

                //Create promise to return
                var _deffered = $q.defer();
                
                //prepare query string for API call
                var _baseUri = Configuration.BASEURI;
                var _queryBuilder = _baseUri + '/fleet/vehicles/{vehicle_id_or_external_id}';
                
                // Process template parameters
                _queryBuilder = APIHelper.appendUrlWithTemplateParameters(_queryBuilder, {
                    'vehicle_id_or_external_id': vehicleIdOrExternalId
                });

                // Process query parameters
                _queryBuilder = APIHelper.appendUrlWithQueryParameters(_queryBuilder, {
                    'access_token': accessToken
                });

                //validate and preprocess url
                var _queryUrl = APIHelper.cleanUrl(_queryBuilder);
                
                // prepare headers
                var _headers = {
                    'accept': 'application/json',
                    'content-type': 'application/json; charset=utf-8'
                };

                // Remove null values
                APIHelper.cleanObject(data);

                // prepare and invoke the API call request to fetch the response
                var _config = {
                    method: 'PATCH',
                    queryUrl: _queryUrl,
                    headers: _headers,
                    body: data.toJSON()
                };
                
                var _response = new HttpClient(_config);
                
                //process response
                _response.then(function success(_result) {
                    var parsed = _result.body;
                    parsed = BaseController.getObjectMapper().mapObject(parsed, 'FleetVehicleResponse');
                    _result.body = parsed;
                    _deffered.resolve(_result);
                }, function error(_result){
                    // Error handling for custom HTTP status codes
                     else {
                        _deffered.reject(APIHelper.appendContext({
                            errorMessage:'HTTP Response Not OK',
                            errorCode: _result.code,
                            errorResponse: _result.message
                        }, _result.getContext()));
                    }
                });
                
                return _deffered.promise;
            },
            /**
             * Fetch the safety score for the vehicle.
             *
             * @param {string} accessToken Samsara API access token.
             * @param {long} startMs Timestamp in milliseconds representing the start of the period to fetch,
             * inclusive. Used in combination with endMs.
             * @param {long} endMs Timestamp in milliseconds representing the end of the period to fetch, inclusive.
             * Used in combination with startMs.
             * @param {long} vehicleId ID of the vehicle
             *
             * @return {promise<VehicleSafetyScoreResponse>}
             */
            getVehicleSafetyScore: function (accessToken, startMs, endMs, vehicleId) {

                //Create promise to return
                var _deffered = $q.defer();
                
                //prepare query string for API call
                var _baseUri = Configuration.BASEURI;
                var _queryBuilder = _baseUri + '/fleet/vehicles/{vehicleId}/safety/score';
                
                // Process template parameters
                _queryBuilder = APIHelper.appendUrlWithTemplateParameters(_queryBuilder, {
                    'vehicleId': vehicleId
                });

                // Process query parameters
                _queryBuilder = APIHelper.appendUrlWithQueryParameters(_queryBuilder, {
                    'access_token': accessToken,
                    'startMs': startMs,
                    'endMs': endMs
                });

                //validate and preprocess url
                var _queryUrl = APIHelper.cleanUrl(_queryBuilder);
                
                // prepare headers
                var _headers = {
                    'accept': 'application/json'
                };

                // prepare and invoke the API call request to fetch the response
                var _config = {
                    method: 'GET',
                    queryUrl: _queryUrl,
                    headers: _headers,
                };
                
                var _response = new HttpClient(_config);
                
                //process response
                _response.then(function success(_result) {
                    var parsed = _result.body;
                    parsed = BaseController.getObjectMapper().mapObject(parsed, 'VehicleSafetyScoreResponse');
                    _result.body = parsed;
                    _deffered.resolve(_result);
                }, function error(_result){
                    // Error handling for custom HTTP status codes
                     else {
                        _deffered.reject(APIHelper.appendContext({
                            errorMessage:'HTTP Response Not OK',
                            errorCode: _result.code,
                            errorResponse: _result.message
                        }, _result.getContext()));
                    }
                });
                
                return _deffered.promise;
            },
            /**
             * Fetch harsh event details for a vehicle.
             *
             * @param {string} accessToken Samsara API access token.
             * @param {long} timestamp Timestamp in milliseconds representing the timestamp of a harsh event.
             * @param {long} vehicleId ID of the vehicle
             *
             * @return {promise<VehicleHarshEventResponse>}
             */
            getVehicleHarshEvent: function (accessToken, timestamp, vehicleId) {

                //Create promise to return
                var _deffered = $q.defer();
                
                //prepare query string for API call
                var _baseUri = Configuration.BASEURI;
                var _queryBuilder = _baseUri + '/fleet/vehicles/{vehicleId}/safety/harsh_event';
                
                // Process template parameters
                _queryBuilder = APIHelper.appendUrlWithTemplateParameters(_queryBuilder, {
                    'vehicleId': vehicleId
                });

                // Process query parameters
                _queryBuilder = APIHelper.appendUrlWithQueryParameters(_queryBuilder, {
                    'access_token': accessToken,
                    'timestamp': timestamp
                });

                //validate and preprocess url
                var _queryUrl = APIHelper.cleanUrl(_queryBuilder);
                
                // prepare headers
                var _headers = {
                    'accept': 'application/json'
                };

                // prepare and invoke the API call request to fetch the response
                var _config = {
                    method: 'GET',
                    queryUrl: _queryUrl,
                    headers: _headers,
                };
                
                var _response = new HttpClient(_config);
                
                //process response
                _response.then(function success(_result) {
                    var parsed = _result.body;
                    parsed = BaseController.getObjectMapper().mapObject(parsed, 'VehicleHarshEventResponse');
                    _result.body = parsed;
                    _deffered.resolve(_result);
                }, function error(_result){
                    // Error handling for custom HTTP status codes
                     else {
                        _deffered.reject(APIHelper.appendContext({
                            errorMessage:'HTTP Response Not OK',
                            errorCode: _result.code,
                            errorResponse: _result.message
                        }, _result.getContext()));
                    }
                });
                
                return _deffered.promise;
            },
            /**
             * Fetch locations for a given vehicle between a start/end time. The maximum query duration is 30
             * minutes.
             *
             * @param {string} accessToken Samsara API access token.
             * @param {int} startMs Time in Unix epoch milliseconds for the start of the query (cannot exceed 30
             * minutes)
             * @param {int} endMs Time in Unix epoch milliseconds for the end of the query (cannot exceed 30
             * minutes)
             *
             * @return {promise<FleetVehiclesLocation>}
             */
            getVehiclesLocations: function (accessToken, startMs, endMs) {

                //Create promise to return
                var _deffered = $q.defer();
                
                //prepare query string for API call
                var _baseUri = Configuration.BASEURI;
                var _queryBuilder = _baseUri + '/fleet/vehicles/locations';
                
                // Process query parameters
                _queryBuilder = APIHelper.appendUrlWithQueryParameters(_queryBuilder, {
                    'access_token': accessToken,
                    'startMs': startMs,
                    'endMs': endMs
                });

                //validate and preprocess url
                var _queryUrl = APIHelper.cleanUrl(_queryBuilder);
                
                // prepare headers
                var _headers = {
                    'accept': 'application/json'
                };

                // prepare and invoke the API call request to fetch the response
                var _config = {
                    method: 'GET',
                    queryUrl: _queryUrl,
                    headers: _headers,
                };
                
                var _response = new HttpClient(_config);
                
                //process response
                _response.then(function success(_result) {
                    var parsed = _result.body;
                    parsed = parsed.map(function(model){
                        return BaseController.getObjectMapper().mapObject(model, 'FleetVehiclesLocation');
                    });
                    _result.body = parsed;
                    _deffered.resolve(_result);
                }, function error(_result){
                    // Error handling for custom HTTP status codes
                     else {
                        _deffered.reject(APIHelper.appendContext({
                            errorMessage:'HTTP Response Not OK',
                            errorCode: _result.code,
                            errorResponse: _result.message
                        }, _result.getContext()));
                    }
                });
                
                return _deffered.promise;
            },
            /**
             * Get DVIRs for the org within provided time constraints
             *
             * @param {string} accessToken Samsara API access token.
             * @param {int} endMs time in millis until the last dvir log.
             * @param {int} durationMs time in millis which corresponds to the duration before the end_ms.
             * @param {int|null} groupId [Optional] Group ID to query.
             *
             * @return {promise<DvirListResponse>}
             */
            getDvirs: function (accessToken, endMs, durationMs, groupId) {

                //Create promise to return
                var _deffered = $q.defer();
                
                //prepare query string for API call
                var _baseUri = Configuration.BASEURI;
                var _queryBuilder = _baseUri + '/fleet/maintenance/dvirs';
                
                // Process query parameters
                _queryBuilder = APIHelper.appendUrlWithQueryParameters(_queryBuilder, {
                    'access_token': accessToken,
                    'end_ms': endMs,
                    'duration_ms': durationMs,
                    'group_id': groupId
                });

                //validate and preprocess url
                var _queryUrl = APIHelper.cleanUrl(_queryBuilder);
                
                // prepare headers
                var _headers = {
                    'accept': 'application/json'
                };

                // prepare and invoke the API call request to fetch the response
                var _config = {
                    method: 'GET',
                    queryUrl: _queryUrl,
                    headers: _headers,
                };
                
                var _response = new HttpClient(_config);
                
                //process response
                _response.then(function success(_result) {
                    var parsed = _result.body;
                    parsed = BaseController.getObjectMapper().mapObject(parsed, 'DvirListResponse');
                    _result.body = parsed;
                    _deffered.resolve(_result);
                }, function error(_result){
                    // Error handling for custom HTTP status codes
                     else {
                        _deffered.reject(APIHelper.appendContext({
                            errorMessage:'HTTP Response Not OK',
                            errorCode: _result.code,
                            errorResponse: _result.message
                        }, _result.getContext()));
                    }
                });
                
                return _deffered.promise;
            },
            /**
             * Gets a specific vehicle.
             *
             * @param {string} accessToken Samsara API access token.
             * @param {string} vehicleIdOrExternalId ID of the vehicle.  This must be either the numeric ID
             * generated by Samsara or the external ID of the vehicle.
             * External IDs are customer specified key-value pairs.
             *
             * @return {promise<FleetVehicleResponse>}
             */
            getFleetVehicle: function (accessToken, vehicleIdOrExternalId) {

                //Create promise to return
                var _deffered = $q.defer();
                
                //prepare query string for API call
                var _baseUri = Configuration.BASEURI;
                var _queryBuilder = _baseUri + '/fleet/vehicles/{vehicle_id_or_external_id}';
                
                // Process template parameters
                _queryBuilder = APIHelper.appendUrlWithTemplateParameters(_queryBuilder, {
                    'vehicle_id_or_external_id': vehicleIdOrExternalId
                });

                // Process query parameters
                _queryBuilder = APIHelper.appendUrlWithQueryParameters(_queryBuilder, {
                    'access_token': accessToken
                });

                //validate and preprocess url
                var _queryUrl = APIHelper.cleanUrl(_queryBuilder);
                
                // prepare headers
                var _headers = {
                    'accept': 'application/json'
                };

                // prepare and invoke the API call request to fetch the response
                var _config = {
                    method: 'GET',
                    queryUrl: _queryUrl,
                    headers: _headers,
                };
                
                var _response = new HttpClient(_config);
                
                //process response
                _response.then(function success(_result) {
                    var parsed = _result.body;
                    parsed = BaseController.getObjectMapper().mapObject(parsed, 'FleetVehicleResponse');
                    _result.body = parsed;
                    _deffered.resolve(_result);
                }, function error(_result){
                    // Error handling for custom HTTP status codes
                     else {
                        _deffered.reject(APIHelper.appendContext({
                            errorMessage:'HTTP Response Not OK',
                            errorCode: _result.code,
                            errorResponse: _result.message
                        }, _result.getContext()));
                    }
                });
                
                return _deffered.promise;
            },
            /**
             * Get list of the vehicles. This method returns a list of the vehicles in the Samsara Cloud and
             * information about them.
             *
             * @param {string} accessToken Samsara API access token.
             * @param {GroupParam} groupParam Group ID to query.
             * @param {string|null} startingAfter [Optional] Pagination parameter indicating the cursor position to
             * continue returning results after. Used in conjunction with the
             * 'limit' parameter. Mutually exclusive with 'endingBefore'
             * parameter.
             * @param {string|null} endingBefore [Optional] Pagination parameter indicating the cursor position to
             * return results before. Used in conjunction with the 'limit'
             * parameter. Mutually exclusive with 'startingAfter' parameter.
             * @param {long|null} limit [Optional] Pagination parameter indicating the number of results to return
             * in this request. Used in conjunction with either 'startingAfter' or
             * 'endingBefore'.
             *
             * @return {promise<list_fleetResponse>}
             */
            createListFleet: function (accessToken, groupParam, startingAfter, endingBefore, limit) {

                //Create promise to return
                var _deffered = $q.defer();
                
                //prepare query string for API call
                var _baseUri = Configuration.BASEURI;
                var _queryBuilder = _baseUri + '/fleet/list';
                
                // Process query parameters
                _queryBuilder = APIHelper.appendUrlWithQueryParameters(_queryBuilder, {
                    'access_token': accessToken,
                    'startingAfter': startingAfter,
                    'endingBefore': endingBefore,
                    'limit': limit
                });

                //validate and preprocess url
                var _queryUrl = APIHelper.cleanUrl(_queryBuilder);
                
                // prepare headers
                var _headers = {
                    'accept': 'application/json',
                    'content-type': 'application/json; charset=utf-8'
                };

                // Remove null values
                APIHelper.cleanObject(groupParam);

                // prepare and invoke the API call request to fetch the response
                var _config = {
                    method: 'POST',
                    queryUrl: _queryUrl,
                    headers: _headers,
                    body: groupParam.toJSON()
                };
                
                var _response = new HttpClient(_config);
                
                //process response
                _response.then(function success(_result) {
                    var parsed = _result.body;
                    parsed = BaseController.getObjectMapper().mapObject(parsed, 'ListFleetResponse');
                    _result.body = parsed;
                    _deffered.resolve(_result);
                }, function error(_result){
                    // Error handling for custom HTTP status codes
                     else {
                        _deffered.reject(APIHelper.appendContext({
                            errorMessage:'HTTP Response Not OK',
                            errorCode: _result.code,
                            errorResponse: _result.message
                        }, _result.getContext()));
                    }
                });
                
                return _deffered.promise;
            },
            /**
             * Get summarized daily HOS charts for a specified driver.
             *
             * @param {string} accessToken Samsara API access token.
             * @param {long} driverId ID of the driver with HOS logs.
             * @param {HosLogsParam} hosLogsParam TODO: type description here
             *
             * @return {promise<DriverDailyLogResponse>}
             */
            createGetFleetDriversHosDailyLogs: function (accessToken, driverId, hosLogsParam) {

                //Create promise to return
                var _deffered = $q.defer();
                
                //prepare query string for API call
                var _baseUri = Configuration.BASEURI;
                var _queryBuilder = _baseUri + '/fleet/drivers/{driver_id}/hos_daily_logs';
                
                // Process template parameters
                _queryBuilder = APIHelper.appendUrlWithTemplateParameters(_queryBuilder, {
                    'driver_id': driverId
                });

                // Process query parameters
                _queryBuilder = APIHelper.appendUrlWithQueryParameters(_queryBuilder, {
                    'access_token': accessToken
                });

                //validate and preprocess url
                var _queryUrl = APIHelper.cleanUrl(_queryBuilder);
                
                // prepare headers
                var _headers = {
                    'accept': 'application/json',
                    'content-type': 'application/json; charset=utf-8'
                };

                // Remove null values
                APIHelper.cleanObject(hosLogsParam);

                // prepare and invoke the API call request to fetch the response
                var _config = {
                    method: 'POST',
                    queryUrl: _queryUrl,
                    headers: _headers,
                    body: hosLogsParam.toJSON()
                };
                
                var _response = new HttpClient(_config);
                
                //process response
                _response.then(function success(_result) {
                    var parsed = _result.body;
                    parsed = BaseController.getObjectMapper().mapObject(parsed, 'DriverDailyLogResponse');
                    _result.body = parsed;
                    _deffered.resolve(_result);
                }, function error(_result){
                    // Error handling for custom HTTP status codes
                     else {
                        _deffered.reject(APIHelper.appendContext({
                            errorMessage:'HTTP Response Not OK',
                            errorCode: _result.code,
                            errorResponse: _result.message
                        }, _result.getContext()));
                    }
                });
                
                return _deffered.promise;
            },
            /**
             * Create a driver document for the given driver.
             *
             * @param {DocumentCreate} createDocumentParams To create a document for a given document type, the
             * document type's uuid needs to be passed in to
             * documentTypeUuid. The list of fields passed in should
             * match the document type’s list of field types in the
             * correct order. In other words, a field's valueType and
             * value (i.e. only one of: stringValue, numberValue, or
             * photoValue) at index _i_ should match with the document
             * field type’s valueType at index _i_.
             * @param {string} accessToken Samsara API access token.
             * @param {long} driverId ID of the driver for whom the document is created.
             *
             * @return {promise<Document>}
             */
            createDriverDocument: function (createDocumentParams, accessToken, driverId) {

                //Create promise to return
                var _deffered = $q.defer();
                
                //prepare query string for API call
                var _baseUri = Configuration.BASEURI;
                var _queryBuilder = _baseUri + '/fleet/drivers/{driver_id}/documents';
                
                // Process template parameters
                _queryBuilder = APIHelper.appendUrlWithTemplateParameters(_queryBuilder, {
                    'driver_id': driverId
                });

                // Process query parameters
                _queryBuilder = APIHelper.appendUrlWithQueryParameters(_queryBuilder, {
                    'access_token': accessToken
                });

                //validate and preprocess url
                var _queryUrl = APIHelper.cleanUrl(_queryBuilder);
                
                // prepare headers
                var _headers = {
                    'accept': 'application/json',
                    'content-type': 'application/json; charset=utf-8'
                };

                // Remove null values
                APIHelper.cleanObject(createDocumentParams);

                // prepare and invoke the API call request to fetch the response
                var _config = {
                    method: 'POST',
                    queryUrl: _queryUrl,
                    headers: _headers,
                    body: createDocumentParams.toJSON()
                };
                
                var _response = new HttpClient(_config);
                
                //process response
                _response.then(function success(_result) {
                    var parsed = _result.body;
                    parsed = BaseController.getObjectMapper().mapObject(parsed, 'Document');
                    _result.body = parsed;
                    _deffered.resolve(_result);
                }, function error(_result){
                    // Error handling for custom HTTP status codes
                     else {
                        _deffered.reject(APIHelper.appendContext({
                            errorMessage:'HTTP Response Not OK',
                            errorCode: _result.code,
                            errorResponse: _result.message
                        }, _result.getContext()));
                    }
                });
                
                return _deffered.promise;
            },
            /**
             * Create a new dispatch route for the driver with driver_id.
             *
             * @param {DispatchRouteCreate} createDispatchRouteParams TODO: type description here
             * @param {string} accessToken Samsara API access token.
             * @param {long} driverId ID of the driver with the associated routes.
             *
             * @return {promise<DispatchRoute>}
             */
            createDriverDispatchRoute: function (createDispatchRouteParams, accessToken, driverId) {

                //Create promise to return
                var _deffered = $q.defer();
                
                //prepare query string for API call
                var _baseUri = Configuration.BASEURI;
                var _queryBuilder = _baseUri + '/fleet/drivers/{driver_id}/dispatch/routes';
                
                // Process template parameters
                _queryBuilder = APIHelper.appendUrlWithTemplateParameters(_queryBuilder, {
                    'driver_id': driverId
                });

                // Process query parameters
                _queryBuilder = APIHelper.appendUrlWithQueryParameters(_queryBuilder, {
                    'access_token': accessToken
                });

                //validate and preprocess url
                var _queryUrl = APIHelper.cleanUrl(_queryBuilder);
                
                // prepare headers
                var _headers = {
                    'accept': 'application/json',
                    'content-type': 'application/json; charset=utf-8'
                };

                // Remove null values
                APIHelper.cleanObject(createDispatchRouteParams);

                // prepare and invoke the API call request to fetch the response
                var _config = {
                    method: 'POST',
                    queryUrl: _queryUrl,
                    headers: _headers,
                    body: createDispatchRouteParams.toJSON()
                };
                
                var _response = new HttpClient(_config);
                
                //process response
                _response.then(function success(_result) {
                    var parsed = _result.body;
                    parsed = BaseController.getObjectMapper().mapObject(parsed, 'DispatchRoute');
                    _result.body = parsed;
                    _deffered.resolve(_result);
                }, function error(_result){
                    // Error handling for custom HTTP status codes
                     else {
                        _deffered.reject(APIHelper.appendContext({
                            errorMessage:'HTTP Response Not OK',
                            errorCode: _result.code,
                            errorResponse: _result.message
                        }, _result.getContext()));
                    }
                });
                
                return _deffered.promise;
            },
            /**
             * Get historical trips data for specified vehicle. This method returns a set of historical trips data
             * for the specified vehicle in the specified time range.
             *
             * @param {string} accessToken Samsara API access token.
             * @param {TripsParam} tripsParam Group ID, vehicle ID and time range to query.
             *
             * @return {promise<TripResponse>}
             */
            createGetFleetTrips: function (accessToken, tripsParam) {

                //Create promise to return
                var _deffered = $q.defer();
                
                //prepare query string for API call
                var _baseUri = Configuration.BASEURI;
                var _queryBuilder = _baseUri + '/fleet/trips';
                
                // Process query parameters
                _queryBuilder = APIHelper.appendUrlWithQueryParameters(_queryBuilder, {
                    'access_token': accessToken
                });

                //validate and preprocess url
                var _queryUrl = APIHelper.cleanUrl(_queryBuilder);
                
                // prepare headers
                var _headers = {
                    'accept': 'application/json',
                    'content-type': 'application/json; charset=utf-8'
                };

                // Remove null values
                APIHelper.cleanObject(tripsParam);

                // prepare and invoke the API call request to fetch the response
                var _config = {
                    method: 'POST',
                    queryUrl: _queryUrl,
                    headers: _headers,
                    body: tripsParam.toJSON()
                };
                
                var _response = new HttpClient(_config);
                
                //process response
                _response.then(function success(_result) {
                    var parsed = _result.body;
                    parsed = BaseController.getObjectMapper().mapObject(parsed, 'TripResponse');
                    _result.body = parsed;
                    _deffered.resolve(_result);
                }, function error(_result){
                    // Error handling for custom HTTP status codes
                     else {
                        _deffered.reject(APIHelper.appendContext({
                            errorMessage:'HTTP Response Not OK',
                            errorCode: _result.code,
                            errorResponse: _result.message
                        }, _result.getContext()));
                    }
                });
                
                return _deffered.promise;
            },
            /**
             * This method enables the mutation of metadata for vehicles in the Samsara Cloud.
             *
             * @param {string} accessToken Samsara API access token.
             * @param {VehicleUpdateParam} vehicleUpdateParam TODO: type description here
             *
             * @return {promise<Void>}
             */
            updateVehicles: function (accessToken, vehicleUpdateParam) {

                //Create promise to return
                var _deffered = $q.defer();
                
                //prepare query string for API call
                var _baseUri = Configuration.BASEURI;
                var _queryBuilder = _baseUri + '/fleet/set_data';
                
                // Process query parameters
                _queryBuilder = APIHelper.appendUrlWithQueryParameters(_queryBuilder, {
                    'access_token': accessToken
                });

                //validate and preprocess url
                var _queryUrl = APIHelper.cleanUrl(_queryBuilder);
                
                // prepare headers
                var _headers = {
                    'content-type': 'application/json; charset=utf-8'
                };

                // Remove null values
                APIHelper.cleanObject(vehicleUpdateParam);

                // prepare and invoke the API call request to fetch the response
                var _config = {
                    method: 'POST',
                    queryUrl: _queryUrl,
                    headers: _headers,
                    body: vehicleUpdateParam.toJSON()
                };
                
                var _response = new HttpClient(_config);
                
                //process response
                _response.then(function success(_result) {
                    _deffered.resolve(_result);
                }, function error(_result){
                    // Error handling for custom HTTP status codes
                     else {
                        _deffered.reject(APIHelper.appendContext({
                            errorMessage:'HTTP Response Not OK',
                            errorCode: _result.code,
                            errorResponse: _result.message
                        }, _result.getContext()));
                    }
                });
                
                return _deffered.promise;
            },
            /**
             * Get list of the vehicles with any engine faults or check light data.
             *
             * @param {string} accessToken Samsara API access token.
             * @param {GroupParam} groupParam Group ID to query.
             *
             * @return {promise<get_fleet_maintenance_listResponse>}
             */
            createGetFleetMaintenanceList: function (accessToken, groupParam) {

                //Create promise to return
                var _deffered = $q.defer();
                
                //prepare query string for API call
                var _baseUri = Configuration.BASEURI;
                var _queryBuilder = _baseUri + '/fleet/maintenance/list';
                
                // Process query parameters
                _queryBuilder = APIHelper.appendUrlWithQueryParameters(_queryBuilder, {
                    'access_token': accessToken
                });

                //validate and preprocess url
                var _queryUrl = APIHelper.cleanUrl(_queryBuilder);
                
                // prepare headers
                var _headers = {
                    'accept': 'application/json',
                    'content-type': 'application/json; charset=utf-8'
                };

                // Remove null values
                APIHelper.cleanObject(groupParam);

                // prepare and invoke the API call request to fetch the response
                var _config = {
                    method: 'POST',
                    queryUrl: _queryUrl,
                    headers: _headers,
                    body: groupParam.toJSON()
                };
                
                var _response = new HttpClient(_config);
                
                //process response
                _response.then(function success(_result) {
                    var parsed = _result.body;
                    parsed = BaseController.getObjectMapper().mapObject(parsed, 'GetFleetMaintenanceListResponse');
                    _result.body = parsed;
                    _deffered.resolve(_result);
                }, function error(_result){
                    // Error handling for custom HTTP status codes
                     else {
                        _deffered.reject(APIHelper.appendContext({
                            errorMessage:'HTTP Response Not OK',
                            errorCode: _result.code,
                            errorResponse: _result.message
                        }, _result.getContext()));
                    }
                });
                
                return _deffered.promise;
            },
            /**
             * Fetch all of the dispatch routes for a given driver.
             *
             * @param {string} accessToken Samsara API access token.
             * @param {long} driverId ID of the driver with the associated routes.
             * @param {long|null} endTime [Optional] Time in unix milliseconds that represents the oldest routes to
             * return. Used in combination with duration. Defaults to now.
             * @param {long|null} duration [Optional] Time in milliseconds that represents the duration before
             * end_time to query. Defaults to 24 hours.
             *
             * @return {promise<DispatchRoute>}
             */
            getDispatchRoutesByDriverId: function (accessToken, driverId, endTime, duration) {

                //Create promise to return
                var _deffered = $q.defer();
                
                //prepare query string for API call
                var _baseUri = Configuration.BASEURI;
                var _queryBuilder = _baseUri + '/fleet/drivers/{driver_id}/dispatch/routes';
                
                // Process template parameters
                _queryBuilder = APIHelper.appendUrlWithTemplateParameters(_queryBuilder, {
                    'driver_id': driverId
                });

                // Process query parameters
                _queryBuilder = APIHelper.appendUrlWithQueryParameters(_queryBuilder, {
                    'access_token': accessToken,
                    'end_time': endTime,
                    'duration': duration
                });

                //validate and preprocess url
                var _queryUrl = APIHelper.cleanUrl(_queryBuilder);
                
                // prepare headers
                var _headers = {
                    'accept': 'application/json'
                };

                // prepare and invoke the API call request to fetch the response
                var _config = {
                    method: 'GET',
                    queryUrl: _queryUrl,
                    headers: _headers,
                };
                
                var _response = new HttpClient(_config);
                
                //process response
                _response.then(function success(_result) {
                    var parsed = _result.body;
                    parsed = parsed.map(function(model){
                        return BaseController.getObjectMapper().mapObject(model, 'DispatchRoute');
                    });
                    _result.body = parsed;
                    _deffered.resolve(_result);
                }, function error(_result){
                    // Error handling for custom HTTP status codes
                     else {
                        _deffered.reject(APIHelper.appendContext({
                            errorMessage:'HTTP Response Not OK',
                            errorCode: _result.code,
                            errorResponse: _result.message
                        }, _result.getContext()));
                    }
                });
                
                return _deffered.promise;
            },
            /**
             * Create a new dvir, marking a vehicle or trailer safe or unsafe.
             *
             * @param {string} accessToken Samsara API access token.
             * @param {CreateDvirParam} createDvirParam DVIR creation body
             *
             * @return {promise<DvirBase>}
             */
            createDvir: function (accessToken, createDvirParam) {

                //Create promise to return
                var _deffered = $q.defer();
                
                //prepare query string for API call
                var _baseUri = Configuration.BASEURI;
                var _queryBuilder = _baseUri + '/fleet/maintenance/dvirs';
                
                // Process query parameters
                _queryBuilder = APIHelper.appendUrlWithQueryParameters(_queryBuilder, {
                    'access_token': accessToken
                });

                //validate and preprocess url
                var _queryUrl = APIHelper.cleanUrl(_queryBuilder);
                
                // prepare headers
                var _headers = {
                    'accept': 'application/json',
                    'content-type': 'application/json; charset=utf-8'
                };

                // Remove null values
                APIHelper.cleanObject(createDvirParam);

                // prepare and invoke the API call request to fetch the response
                var _config = {
                    method: 'POST',
                    queryUrl: _queryUrl,
                    headers: _headers,
                    body: createDvirParam.toJSON()
                };
                
                var _response = new HttpClient(_config);
                
                //process response
                _response.then(function success(_result) {
                    var parsed = _result.body;
                    parsed = BaseController.getObjectMapper().mapObject(parsed, 'DvirBase');
                    _result.body = parsed;
                    _deffered.resolve(_result);
                }, function error(_result){
                    // Error handling for custom HTTP status codes
                     else {
                        _deffered.reject(APIHelper.appendContext({
                            errorMessage:'HTTP Response Not OK',
                            errorCode: _result.code,
                            errorResponse: _result.message
                        }, _result.getContext()));
                    }
                });
                
                return _deffered.promise;
            },
            /**
             * Fetch the safety score for the driver.
             *
             * @param {string} accessToken Samsara API access token.
             * @param {long} startMs Timestamp in milliseconds representing the start of the period to fetch,
             * inclusive. Used in combination with endMs.
             * @param {long} endMs Timestamp in milliseconds representing the end of the period to fetch, inclusive.
             * Used in combination with startMs.
             * @param {long} driverId ID of the driver
             *
             * @return {promise<DriverSafetyScoreResponse>}
             */
            getDriverSafetyScore: function (accessToken, startMs, endMs, driverId) {

                //Create promise to return
                var _deffered = $q.defer();
                
                //prepare query string for API call
                var _baseUri = Configuration.BASEURI;
                var _queryBuilder = _baseUri + '/fleet/drivers/{driverId}/safety/score';
                
                // Process template parameters
                _queryBuilder = APIHelper.appendUrlWithTemplateParameters(_queryBuilder, {
                    'driverId': driverId
                });

                // Process query parameters
                _queryBuilder = APIHelper.appendUrlWithQueryParameters(_queryBuilder, {
                    'access_token': accessToken,
                    'startMs': startMs,
                    'endMs': endMs
                });

                //validate and preprocess url
                var _queryUrl = APIHelper.cleanUrl(_queryBuilder);
                
                // prepare headers
                var _headers = {
                    'accept': 'application/json'
                };

                // prepare and invoke the API call request to fetch the response
                var _config = {
                    method: 'GET',
                    queryUrl: _queryUrl,
                    headers: _headers,
                };
                
                var _response = new HttpClient(_config);
                
                //process response
                _response.then(function success(_result) {
                    var parsed = _result.body;
                    parsed = BaseController.getObjectMapper().mapObject(parsed, 'DriverSafetyScoreResponse');
                    _result.body = parsed;
                    _deffered.resolve(_result);
                }, function error(_result){
                    // Error handling for custom HTTP status codes
                     else {
                        _deffered.reject(APIHelper.appendContext({
                            errorMessage:'HTTP Response Not OK',
                            errorCode: _result.code,
                            errorResponse: _result.message
                        }, _result.getContext()));
                    }
                });
                
                return _deffered.promise;
            },
            /**
             * Get current location of vehicles in a group. This method returns the current location in latitude and
             * longitude of all vehicles in a requested group.
             *
             * @param {string} accessToken Samsara API access token.
             * @param {GroupParam} groupParam Group ID to query.
             *
             * @return {promise<get_fleet_locationsResponse>}
             */
            createGetFleetLocations: function (accessToken, groupParam) {

                //Create promise to return
                var _deffered = $q.defer();
                
                //prepare query string for API call
                var _baseUri = Configuration.BASEURI;
                var _queryBuilder = _baseUri + '/fleet/locations';
                
                // Process query parameters
                _queryBuilder = APIHelper.appendUrlWithQueryParameters(_queryBuilder, {
                    'access_token': accessToken
                });

                //validate and preprocess url
                var _queryUrl = APIHelper.cleanUrl(_queryBuilder);
                
                // prepare headers
                var _headers = {
                    'accept': 'application/json',
                    'content-type': 'application/json; charset=utf-8'
                };

                // Remove null values
                APIHelper.cleanObject(groupParam);

                // prepare and invoke the API call request to fetch the response
                var _config = {
                    method: 'POST',
                    queryUrl: _queryUrl,
                    headers: _headers,
                    body: groupParam.toJSON()
                };
                
                var _response = new HttpClient(_config);
                
                //process response
                _response.then(function success(_result) {
                    var parsed = _result.body;
                    parsed = BaseController.getObjectMapper().mapObject(parsed, 'GetFleetLocationsResponse');
                    _result.body = parsed;
                    _deffered.resolve(_result);
                }, function error(_result){
                    // Error handling for custom HTTP status codes
                     else {
                        _deffered.reject(APIHelper.appendContext({
                            errorMessage:'HTTP Response Not OK',
                            errorCode: _result.code,
                            errorResponse: _result.message
                        }, _result.getContext()));
                    }
                });
                
                return _deffered.promise;
            },
            /**
             * Get the current HOS status for all drivers in the group.
             *
             * @param {string} accessToken Samsara API access token.
             * @param {HosLogsParam2} hosLogsParam TODO: type description here
             *
             * @return {promise<HosLogsSummaryResponse>}
             */
            createGetFleetHosLogsSummary: function (accessToken, hosLogsParam) {

                //Create promise to return
                var _deffered = $q.defer();
                
                //prepare query string for API call
                var _baseUri = Configuration.BASEURI;
                var _queryBuilder = _baseUri + '/fleet/hos_logs_summary';
                
                // Process query parameters
                _queryBuilder = APIHelper.appendUrlWithQueryParameters(_queryBuilder, {
                    'access_token': accessToken
                });

                //validate and preprocess url
                var _queryUrl = APIHelper.cleanUrl(_queryBuilder);
                
                // prepare headers
                var _headers = {
                    'accept': 'application/json',
                    'content-type': 'application/json; charset=utf-8'
                };

                // Remove null values
                APIHelper.cleanObject(hosLogsParam);

                // prepare and invoke the API call request to fetch the response
                var _config = {
                    method: 'POST',
                    queryUrl: _queryUrl,
                    headers: _headers,
                    body: hosLogsParam.toJSON()
                };
                
                var _response = new HttpClient(_config);
                
                //process response
                _response.then(function success(_result) {
                    var parsed = _result.body;
                    parsed = BaseController.getObjectMapper().mapObject(parsed, 'HosLogsSummaryResponse');
                    _result.body = parsed;
                    _deffered.resolve(_result);
                }, function error(_result){
                    // Error handling for custom HTTP status codes
                     else {
                        _deffered.reject(APIHelper.appendContext({
                            errorMessage:'HTTP Response Not OK',
                            errorCode: _result.code,
                            errorResponse: _result.message
                        }, _result.getContext()));
                    }
                });
                
                return _deffered.promise;
            },
            /**
             * Get the HOS (hours of service) logs for the specified driver. This method returns all the HOS
             * statuses that the driver was in during this time period.
             *
             * @param {string} accessToken Samsara API access token.
             * @param {HosLogsParam} hosLogsParam TODO: type description here
             *
             * @return {promise<HosLogsResponse>}
             */
            createGetFleetHosLogs: function (accessToken, hosLogsParam) {

                //Create promise to return
                var _deffered = $q.defer();
                
                //prepare query string for API call
                var _baseUri = Configuration.BASEURI;
                var _queryBuilder = _baseUri + '/fleet/hos_logs';
                
                // Process query parameters
                _queryBuilder = APIHelper.appendUrlWithQueryParameters(_queryBuilder, {
                    'access_token': accessToken
                });

                //validate and preprocess url
                var _queryUrl = APIHelper.cleanUrl(_queryBuilder);
                
                // prepare headers
                var _headers = {
                    'accept': 'application/json',
                    'content-type': 'application/json; charset=utf-8'
                };

                // Remove null values
                APIHelper.cleanObject(hosLogsParam);

                // prepare and invoke the API call request to fetch the response
                var _config = {
                    method: 'POST',
                    queryUrl: _queryUrl,
                    headers: _headers,
                    body: hosLogsParam.toJSON()
                };
                
                var _response = new HttpClient(_config);
                
                //process response
                _response.then(function success(_result) {
                    var parsed = _result.body;
                    parsed = BaseController.getObjectMapper().mapObject(parsed, 'HosLogsResponse');
                    _result.body = parsed;
                    _deffered.resolve(_result);
                }, function error(_result){
                    // Error handling for custom HTTP status codes
                     else {
                        _deffered.reject(APIHelper.appendContext({
                            errorMessage:'HTTP Response Not OK',
                            errorCode: _result.code,
                            errorResponse: _result.message
                        }, _result.getContext()));
                    }
                });
                
                return _deffered.promise;
            },
            /**
             * Get the HOS (hours of service) signin and signout logs for the specified driver. Only signout logs
             * include location information.
             *
             * @param {string} accessToken Samsara API access token.
             * @param {HosAuthenticationLogsParam} hosAuthenticationLogsParam TODO: type description here
             *
             * @return {promise<HosAuthenticationLogsResponse>}
             */
            createGetFleetHosAuthenticationLogs: function (accessToken, hosAuthenticationLogsParam) {

                //Create promise to return
                var _deffered = $q.defer();
                
                //prepare query string for API call
                var _baseUri = Configuration.BASEURI;
                var _queryBuilder = _baseUri + '/fleet/hos_authentication_logs';
                
                // Process query parameters
                _queryBuilder = APIHelper.appendUrlWithQueryParameters(_queryBuilder, {
                    'access_token': accessToken
                });

                //validate and preprocess url
                var _queryUrl = APIHelper.cleanUrl(_queryBuilder);
                
                // prepare headers
                var _headers = {
                    'accept': 'application/json',
                    'content-type': 'application/json; charset=utf-8'
                };

                // Remove null values
                APIHelper.cleanObject(hosAuthenticationLogsParam);

                // prepare and invoke the API call request to fetch the response
                var _config = {
                    method: 'POST',
                    queryUrl: _queryUrl,
                    headers: _headers,
                    body: hosAuthenticationLogsParam.toJSON()
                };
                
                var _response = new HttpClient(_config);
                
                //process response
                _response.then(function success(_result) {
                    var parsed = _result.body;
                    parsed = BaseController.getObjectMapper().mapObject(parsed, 'HosAuthenticationLogsResponse');
                    _result.body = parsed;
                    _deffered.resolve(_result);
                }, function error(_result){
                    // Error handling for custom HTTP status codes
                     else {
                        _deffered.reject(APIHelper.appendContext({
                            errorMessage:'HTTP Response Not OK',
                            errorCode: _result.code,
                            errorResponse: _result.message
                        }, _result.getContext()));
                    }
                });
                
                return _deffered.promise;
            },
            /**
             * Get the distance and time each driver in an organization has driven in a given time period.
             *
             * @param {string} accessToken Samsara API access token.
             * @param {DriversSummaryParam} driversSummaryParam Org ID and time range to query.
             * @param {bool|null} snapToDayBounds [Optional] Snap query result to HOS day boundaries.
             *
             * @return {promise<DriversSummaryResponse>}
             */
            createGetFleetDriversSummary: function (accessToken, driversSummaryParam, snapToDayBounds) {

                //Create promise to return
                var _deffered = $q.defer();
                
                //prepare query string for API call
                var _baseUri = Configuration.BASEURI;
                var _queryBuilder = _baseUri + '/fleet/drivers/summary';
                
                // Process query parameters
                _queryBuilder = APIHelper.appendUrlWithQueryParameters(_queryBuilder, {
                    'access_token': accessToken,
                    'snap_to_day_bounds': snapToDayBounds
                });

                //validate and preprocess url
                var _queryUrl = APIHelper.cleanUrl(_queryBuilder);
                
                // prepare headers
                var _headers = {
                    'accept': 'application/json',
                    'content-type': 'application/json; charset=utf-8'
                };

                // Remove null values
                APIHelper.cleanObject(driversSummaryParam);

                // prepare and invoke the API call request to fetch the response
                var _config = {
                    method: 'POST',
                    queryUrl: _queryUrl,
                    headers: _headers,
                    body: driversSummaryParam.toJSON()
                };
                
                var _response = new HttpClient(_config);
                
                //process response
                _response.then(function success(_result) {
                    var parsed = _result.body;
                    parsed = BaseController.getObjectMapper().mapObject(parsed, 'DriversSummaryResponse');
                    _result.body = parsed;
                    _deffered.resolve(_result);
                }, function error(_result){
                    // Error handling for custom HTTP status codes
                     else {
                        _deffered.reject(APIHelper.appendContext({
                            errorMessage:'HTTP Response Not OK',
                            errorCode: _result.code,
                            errorResponse: _result.message
                        }, _result.getContext()));
                    }
                });
                
                return _deffered.promise;
            },
            /**
             * Fetch engine state and aux input data for all vehicles in the group between a start/end time. Data
             * returned may be affected by device connectivity and processing time.
             *
             * @param {string} accessToken Samsara API access token.
             * @param {int} startMs Time in Unix epoch milliseconds for the start of the query.
             * @param {int} endMs Time in Unix epoch milliseconds for the end of the query.
             * @param {SeriesEnum|null} series [Optional] Comma-separated list of stat types. Options are
             * engineState, auxInput1, and auxInput2. If this parameter is excluded,
             * all 3 stat types will be returned. Example: series=engineState,
             * auxInput2
             * @param {string|null} tagIds [Optional] Comma-separated list of tag ids. Example: tagIds=1,2,3
             * @param {string|null} startingAfter [Optional] Pagination parameter indicating the cursor position to
             * continue returning results after. Used in conjunction with the
             * 'limit' parameter. Mutually exclusive with 'endingBefore'
             * parameter.
             * @param {string|null} endingBefore [Optional] Pagination parameter indicating the cursor position to
             * return results before. Used in conjunction with the 'limit'
             * parameter. Mutually exclusive with 'startingAfter' parameter.
             * @param {long|null} limit [Optional] Pagination parameter indicating the number of results to return
             * in this request. Used in conjunction with either 'startingAfter' or
             * 'endingBefore'.
             *
             * @return {promise<GetVehicleStatsResponse>}
             */
            getVehicleStats: function (accessToken,
                startMs,
                endMs,
                series,
                tagIds,
                startingAfter,
                endingBefore,
                limit)
            {

                //Create promise to return
                var _deffered = $q.defer();
                
                //prepare query string for API call
                var _baseUri = Configuration.BASEURI;
                var _queryBuilder = _baseUri + '/fleet/vehicles/stats';
                
                // Process query parameters
                _queryBuilder = APIHelper.appendUrlWithQueryParameters(_queryBuilder, {
                    'access_token': accessToken,
                    'startMs': startMs,
                    'endMs': endMs,
                    'series': (series !== null) ? series : null,
                    'tagIds': tagIds,
                    'startingAfter': startingAfter,
                    'endingBefore': endingBefore,
                    'limit': limit
                });

                //validate and preprocess url
                var _queryUrl = APIHelper.cleanUrl(_queryBuilder);
                
                // prepare headers
                var _headers = {
                    'accept': 'application/json'
                };

                // prepare and invoke the API call request to fetch the response
                var _config = {
                    method: 'GET',
                    queryUrl: _queryUrl,
                    headers: _headers,
                };
                
                var _response = new HttpClient(_config);
                
                //process response
                _response.then(function success(_result) {
                    var parsed = _result.body;
                    parsed = BaseController.getObjectMapper().mapObject(parsed, 'GetVehicleStatsResponse');
                    _result.body = parsed;
                    _deffered.resolve(_result);
                }, function error(_result){
                    // Error handling for custom HTTP status codes
                     else {
                        _deffered.reject(APIHelper.appendContext({
                            errorMessage:'HTTP Response Not OK',
                            errorCode: _result.code,
                            errorResponse: _result.message
                        }, _result.getContext()));
                    }
                });
                
                return _deffered.promise;
            },
            /**
             * Reactivate the inactive driver having id.
             *
             * @param {ReactivateDriverParam} reactivateDriverParam Driver reactivation body
             * @param {string} accessToken Samsara API access token.
             * @param {string} driverIdOrExternalId ID of the driver.  This must be either the numeric ID generated
             * by Samsara or the external ID of the driver.  External IDs are
             * customer specified key-value pairs.
             *
             * @return {promise<Driver>}
             */
            updateReactivateDriverById: function (reactivateDriverParam, accessToken, driverIdOrExternalId) {

                //Create promise to return
                var _deffered = $q.defer();
                
                //prepare query string for API call
                var _baseUri = Configuration.BASEURI;
                var _queryBuilder = _baseUri + '/fleet/drivers/inactive/{driver_id_or_external_id}';
                
                // Process template parameters
                _queryBuilder = APIHelper.appendUrlWithTemplateParameters(_queryBuilder, {
                    'driver_id_or_external_id': driverIdOrExternalId
                });

                // Process query parameters
                _queryBuilder = APIHelper.appendUrlWithQueryParameters(_queryBuilder, {
                    'access_token': accessToken
                });

                //validate and preprocess url
                var _queryUrl = APIHelper.cleanUrl(_queryBuilder);
                
                // prepare headers
                var _headers = {
                    'accept': 'application/json',
                    'content-type': 'application/json; charset=utf-8'
                };

                // Remove null values
                APIHelper.cleanObject(reactivateDriverParam);

                // prepare and invoke the API call request to fetch the response
                var _config = {
                    method: 'PUT',
                    queryUrl: _queryUrl,
                    headers: _headers,
                    body: reactivateDriverParam.toJSON()
                };
                
                var _response = new HttpClient(_config);
                
                //process response
                _response.then(function success(_result) {
                    var parsed = _result.body;
                    parsed = BaseController.getObjectMapper().mapObject(parsed, 'Driver');
                    _result.body = parsed;
                    _deffered.resolve(_result);
                }, function error(_result){
                    // Error handling for custom HTTP status codes
                     else {
                        _deffered.reject(APIHelper.appendContext({
                            errorMessage:'HTTP Response Not OK',
                            errorCode: _result.code,
                            errorResponse: _result.message
                        }, _result.getContext()));
                    }
                });
                
                return _deffered.promise;
            },
            /**
             * Fetch all of the documents.
             *
             * @param {string} accessToken Samsara API access token.
             * @param {long|null} endMs [Optional] Time in unix milliseconds that represents the oldest documents
             * to return. Used in combination with durationMs. Defaults to now.
             * @param {long|null} durationMs [Optional] Time in milliseconds that represents the duration before
             * endMs to query. Defaults to 24 hours.
             *
             * @return {promise<Document>}
             */
            getDriverDocumentsByOrgId: function (accessToken, endMs, durationMs) {

                //Create promise to return
                var _deffered = $q.defer();
                
                //prepare query string for API call
                var _baseUri = Configuration.BASEURI;
                var _queryBuilder = _baseUri + '/fleet/drivers/documents';
                
                // Process query parameters
                _queryBuilder = APIHelper.appendUrlWithQueryParameters(_queryBuilder, {
                    'access_token': accessToken,
                    'endMs': endMs,
                    'durationMs': durationMs
                });

                //validate and preprocess url
                var _queryUrl = APIHelper.cleanUrl(_queryBuilder);
                
                // prepare headers
                var _headers = {
                    'accept': 'application/json'
                };

                // prepare and invoke the API call request to fetch the response
                var _config = {
                    method: 'GET',
                    queryUrl: _queryUrl,
                    headers: _headers,
                };
                
                var _response = new HttpClient(_config);
                
                //process response
                _response.then(function success(_result) {
                    var parsed = _result.body;
                    parsed = parsed.map(function(model){
                        return BaseController.getObjectMapper().mapObject(model, 'Document');
                    });
                    _result.body = parsed;
                    _deffered.resolve(_result);
                }, function error(_result){
                    // Error handling for custom HTTP status codes
                     else {
                        _deffered.reject(APIHelper.appendContext({
                            errorMessage:'HTTP Response Not OK',
                            errorCode: _result.code,
                            errorResponse: _result.message
                        }, _result.getContext()));
                    }
                });
                
                return _deffered.promise;
            },
            /**
             * Deactivate a driver with the given id.
             *
             * @param {string} accessToken Samsara API access token.
             * @param {string} driverIdOrExternalId ID of the driver.  This must be either the numeric ID generated
             * by Samsara or the external ID of the driver.  External IDs are
             * customer specified key-value pairs.
             *
             * @return {promise<Void>}
             */
            deleteDeactivateDriver: function (accessToken, driverIdOrExternalId) {

                //Create promise to return
                var _deffered = $q.defer();
                
                //prepare query string for API call
                var _baseUri = Configuration.BASEURI;
                var _queryBuilder = _baseUri + '/fleet/drivers/{driver_id_or_external_id}';
                
                // Process template parameters
                _queryBuilder = APIHelper.appendUrlWithTemplateParameters(_queryBuilder, {
                    'driver_id_or_external_id': driverIdOrExternalId
                });

                // Process query parameters
                _queryBuilder = APIHelper.appendUrlWithQueryParameters(_queryBuilder, {
                    'access_token': accessToken
                });

                //validate and preprocess url
                var _queryUrl = APIHelper.cleanUrl(_queryBuilder);
                
                // prepare and invoke the API call request to fetch the response
                var _config = {
                    method: 'DELETE',
                    queryUrl: _queryUrl,
                };
                
                var _response = new HttpClient(_config);
                
                //process response
                _response.then(function success(_result) {
                    _deffered.resolve(_result);
                }, function error(_result){
                    // Error handling for custom HTTP status codes
                     else {
                        _deffered.reject(APIHelper.appendContext({
                            errorMessage:'HTTP Response Not OK',
                            errorCode: _result.code,
                            errorResponse: _result.message
                        }, _result.getContext()));
                    }
                });
                
                return _deffered.promise;
            },
            /**
             * Fetch the history of a dispatch route.
             *
             * @param {string} accessToken Samsara API access token.
             * @param {long} routeId ID of the route with history.
             * @param {long|null} startTime [Optional] Timestamp representing the start of the period to fetch,
             * inclusive. Used in combination with end_time. Defaults to 0.
             * @param {long|null} endTime [Optional] Timestamp representing the end of the period to fetch,
             * inclusive. Used in combination with start_time. Defaults to nowMs.
             *
             * @return {promise<DispatchRouteHistory>}
             */
            getDispatchRouteHistory: function (accessToken, routeId, startTime, endTime) {

                //Create promise to return
                var _deffered = $q.defer();
                
                //prepare query string for API call
                var _baseUri = Configuration.BASEURI;
                var _queryBuilder = _baseUri + '/fleet/dispatch/routes/{route_id}/history';
                
                // Process template parameters
                _queryBuilder = APIHelper.appendUrlWithTemplateParameters(_queryBuilder, {
                    'route_id': routeId
                });

                // Process query parameters
                _queryBuilder = APIHelper.appendUrlWithQueryParameters(_queryBuilder, {
                    'access_token': accessToken,
                    'start_time': startTime,
                    'end_time': endTime
                });

                //validate and preprocess url
                var _queryUrl = APIHelper.cleanUrl(_queryBuilder);
                
                // prepare headers
                var _headers = {
                    'accept': 'application/json'
                };

                // prepare and invoke the API call request to fetch the response
                var _config = {
                    method: 'GET',
                    queryUrl: _queryUrl,
                    headers: _headers,
                };
                
                var _response = new HttpClient(_config);
                
                //process response
                _response.then(function success(_result) {
                    var parsed = _result.body;
                    parsed = BaseController.getObjectMapper().mapObject(parsed, 'DispatchRouteHistory');
                    _result.body = parsed;
                    _deffered.resolve(_result);
                }, function error(_result){
                    // Error handling for custom HTTP status codes
                     else {
                        _deffered.reject(APIHelper.appendContext({
                            errorMessage:'HTTP Response Not OK',
                            errorCode: _result.code,
                            errorResponse: _result.message
                        }, _result.getContext()));
                    }
                });
                
                return _deffered.promise;
            },
            /**
             * Update a dispatch route and its associated jobs.
             *
             * @param {DispatchRoute} updateDispatchRouteParams TODO: type description here
             * @param {string} accessToken Samsara API access token.
             * @param {long} routeId ID of the dispatch route.
             *
             * @return {promise<DispatchRoute>}
             */
            updateDispatchRouteById: function (updateDispatchRouteParams, accessToken, routeId) {

                //Create promise to return
                var _deffered = $q.defer();
                
                //prepare query string for API call
                var _baseUri = Configuration.BASEURI;
                var _queryBuilder = _baseUri + '/fleet/dispatch/routes/{route_id}';
                
                // Process template parameters
                _queryBuilder = APIHelper.appendUrlWithTemplateParameters(_queryBuilder, {
                    'route_id': routeId
                });

                // Process query parameters
                _queryBuilder = APIHelper.appendUrlWithQueryParameters(_queryBuilder, {
                    'access_token': accessToken
                });

                //validate and preprocess url
                var _queryUrl = APIHelper.cleanUrl(_queryBuilder);
                
                // prepare headers
                var _headers = {
                    'accept': 'application/json',
                    'content-type': 'application/json; charset=utf-8'
                };

                // Remove null values
                APIHelper.cleanObject(updateDispatchRouteParams);

                // prepare and invoke the API call request to fetch the response
                var _config = {
                    method: 'PUT',
                    queryUrl: _queryUrl,
                    headers: _headers,
                    body: updateDispatchRouteParams.toJSON()
                };
                
                var _response = new HttpClient(_config);
                
                //process response
                _response.then(function success(_result) {
                    var parsed = _result.body;
                    parsed = BaseController.getObjectMapper().mapObject(parsed, 'DispatchRoute');
                    _result.body = parsed;
                    _deffered.resolve(_result);
                }, function error(_result){
                    // Error handling for custom HTTP status codes
                     else {
                        _deffered.reject(APIHelper.appendContext({
                            errorMessage:'HTTP Response Not OK',
                            errorCode: _result.code,
                            errorResponse: _result.message
                        }, _result.getContext()));
                    }
                });
                
                return _deffered.promise;
            },
            /**
             * Fetch all updates to a job including route data in the last 24 hours or subsequent to an sequence ID
             *
             * @param {string} accessToken Samsara API access token.
             * @param {long|null} groupId [Optional] Optional group ID if the organization has multiple groups
             * (uncommon).
             * @param {string|null} sequenceId [Optional] Sequence ID from the response payload of the last request.
             * Defaults to fetching updates from last 24 hours.
             * @param {string|null} include [Optional] Optionally set include=route to include route object in
             * response payload.
             *
             * @return {promise<allRouteJobUpdates>}
             */
            fetchAllRouteJobUpdates: function (accessToken, groupId, sequenceId, include) {

                //Create promise to return
                var _deffered = $q.defer();
                
                //prepare query string for API call
                var _baseUri = Configuration.BASEURI;
                var _queryBuilder = _baseUri + '/fleet/dispatch/routes/job_updates';
                
                // Process query parameters
                _queryBuilder = APIHelper.appendUrlWithQueryParameters(_queryBuilder, {
                    'access_token': accessToken,
                    'group_id': groupId,
                    'sequence_id': sequenceId,
                    'include': include
                });

                //validate and preprocess url
                var _queryUrl = APIHelper.cleanUrl(_queryBuilder);
                
                // prepare headers
                var _headers = {
                    'accept': 'application/json'
                };

                // prepare and invoke the API call request to fetch the response
                var _config = {
                    method: 'GET',
                    queryUrl: _queryUrl,
                    headers: _headers,
                };
                
                var _response = new HttpClient(_config);
                
                //process response
                _response.then(function success(_result) {
                    var parsed = _result.body;
                    parsed = BaseController.getObjectMapper().mapObject(parsed, 'AllRouteJobUpdates');
                    _result.body = parsed;
                    _deffered.resolve(_result);
                }, function error(_result){
                    // Error handling for custom HTTP status codes
                     else {
                        _deffered.reject(APIHelper.appendContext({
                            errorMessage:'HTTP Response Not OK',
                            errorCode: _result.code,
                            errorResponse: _result.message
                        }, _result.getContext()));
                    }
                });
                
                return _deffered.promise;
            },
            /**
             * Fetch all of the dispatch routes for the group.
             *
             * @param {string} accessToken Samsara API access token.
             * @param {long|null} groupId [Optional] Optional group ID if the organization has multiple groups
             * (uncommon).
             * @param {long|null} endTime [Optional] Time in unix milliseconds that represents the oldest routes to
             * return. Used in combination with duration. Defaults to now.
             * @param {long|null} duration [Optional] Time in milliseconds that represents the duration before
             * end_time to query. Defaults to 24 hours.
             *
             * @return {promise<DispatchRoute>}
             */
            fetchAllDispatchRoutes: function (accessToken, groupId, endTime, duration) {

                //Create promise to return
                var _deffered = $q.defer();
                
                //prepare query string for API call
                var _baseUri = Configuration.BASEURI;
                var _queryBuilder = _baseUri + '/fleet/dispatch/routes';
                
                // Process query parameters
                _queryBuilder = APIHelper.appendUrlWithQueryParameters(_queryBuilder, {
                    'access_token': accessToken,
                    'group_id': groupId,
                    'end_time': endTime,
                    'duration': duration
                });

                //validate and preprocess url
                var _queryUrl = APIHelper.cleanUrl(_queryBuilder);
                
                // prepare headers
                var _headers = {
                    'accept': 'application/json'
                };

                // prepare and invoke the API call request to fetch the response
                var _config = {
                    method: 'GET',
                    queryUrl: _queryUrl,
                    headers: _headers,
                };
                
                var _response = new HttpClient(_config);
                
                //process response
                _response.then(function success(_result) {
                    var parsed = _result.body;
                    parsed = parsed.map(function(model){
                        return BaseController.getObjectMapper().mapObject(model, 'DispatchRoute');
                    });
                    _result.body = parsed;
                    _deffered.resolve(_result);
                }, function error(_result){
                    // Error handling for custom HTTP status codes
                     else {
                        _deffered.reject(APIHelper.appendContext({
                            errorMessage:'HTTP Response Not OK',
                            errorCode: _result.code,
                            errorResponse: _result.message
                        }, _result.getContext()));
                    }
                });
                
                return _deffered.promise;
            },
            /**
             * Fetch the reefer-specific stats of an asset.
             *
             * @param {string} accessToken Samsara API access token.
             * @param {long} assetId ID of the asset
             * @param {long} startMs Timestamp in milliseconds representing the start of the period to fetch,
             * inclusive. Used in combination with endMs.
             * @param {long} endMs Timestamp in milliseconds representing the end of the period to fetch, inclusive.
             * Used in combination with startMs.
             *
             * @return {promise<AssetReeferResponse>}
             */
            getAssetReefer: function (accessToken, assetId, startMs, endMs) {

                //Create promise to return
                var _deffered = $q.defer();
                
                //prepare query string for API call
                var _baseUri = Configuration.BASEURI;
                var _queryBuilder = _baseUri + '/fleet/assets/{asset_id}/reefer';
                
                // Process template parameters
                _queryBuilder = APIHelper.appendUrlWithTemplateParameters(_queryBuilder, {
                    'asset_id': assetId
                });

                // Process query parameters
                _queryBuilder = APIHelper.appendUrlWithQueryParameters(_queryBuilder, {
                    'access_token': accessToken,
                    'startMs': startMs,
                    'endMs': endMs
                });

                //validate and preprocess url
                var _queryUrl = APIHelper.cleanUrl(_queryBuilder);
                
                // prepare headers
                var _headers = {
                    'accept': 'application/json'
                };

                // prepare and invoke the API call request to fetch the response
                var _config = {
                    method: 'GET',
                    queryUrl: _queryUrl,
                    headers: _headers,
                };
                
                var _response = new HttpClient(_config);
                
                //process response
                _response.then(function success(_result) {
                    var parsed = _result.body;
                    parsed = BaseController.getObjectMapper().mapObject(parsed, 'AssetReeferResponse');
                    _result.body = parsed;
                    _deffered.resolve(_result);
                }, function error(_result){
                    // Error handling for custom HTTP status codes
                     else {
                        _deffered.reject(APIHelper.appendContext({
                            errorMessage:'HTTP Response Not OK',
                            errorCode: _result.code,
                            errorResponse: _result.message
                        }, _result.getContext()));
                    }
                });
                
                return _deffered.promise;
            },
            /**
             * Fetch the historical locations for the asset.
             *
             * @param {string} accessToken Samsara API access token.
             * @param {long} assetId ID of the asset
             * @param {long} startMs Timestamp in milliseconds representing the start of the period to fetch,
             * inclusive. Used in combination with endMs.
             * @param {long} endMs Timestamp in milliseconds representing the end of the period to fetch, inclusive.
             * Used in combination with startMs.
             *
             * @return {promise<AssetLocationResponse>}
             */
            getAssetLocation: function (accessToken, assetId, startMs, endMs) {

                //Create promise to return
                var _deffered = $q.defer();
                
                //prepare query string for API call
                var _baseUri = Configuration.BASEURI;
                var _queryBuilder = _baseUri + '/fleet/assets/{asset_id}/locations';
                
                // Process template parameters
                _queryBuilder = APIHelper.appendUrlWithTemplateParameters(_queryBuilder, {
                    'asset_id': assetId
                });

                // Process query parameters
                _queryBuilder = APIHelper.appendUrlWithQueryParameters(_queryBuilder, {
                    'access_token': accessToken,
                    'startMs': startMs,
                    'endMs': endMs
                });

                //validate and preprocess url
                var _queryUrl = APIHelper.cleanUrl(_queryBuilder);
                
                // prepare headers
                var _headers = {
                    'accept': 'application/json'
                };

                // prepare and invoke the API call request to fetch the response
                var _config = {
                    method: 'GET',
                    queryUrl: _queryUrl,
                    headers: _headers,
                };
                
                var _response = new HttpClient(_config);
                
                //process response
                _response.then(function success(_result) {
                    var parsed = _result.body;
                    parsed = parsed.map(function(model){
                        return BaseController.getObjectMapper().mapObject(model, 'AssetLocationResponse');
                    });
                    _result.body = parsed;
                    _deffered.resolve(_result);
                }, function error(_result){
                    // Error handling for custom HTTP status codes
                     else {
                        _deffered.reject(APIHelper.appendContext({
                            errorMessage:'HTTP Response Not OK',
                            errorCode: _result.code,
                            errorResponse: _result.message
                        }, _result.getContext()));
                    }
                });
                
                return _deffered.promise;
            },
            /**
             * Fetch driver by id.
             *
             * @param {string} accessToken Samsara API access token.
             * @param {string} driverIdOrExternalId ID of the driver.  This must be either the numeric ID generated
             * by Samsara or the external ID of the driver.  External IDs are
             * customer specified key-value pairs.
             *
             * @return {promise<Driver>}
             */
            getDriverById: function (accessToken, driverIdOrExternalId) {

                //Create promise to return
                var _deffered = $q.defer();
                
                //prepare query string for API call
                var _baseUri = Configuration.BASEURI;
                var _queryBuilder = _baseUri + '/fleet/drivers/{driver_id_or_external_id}';
                
                // Process template parameters
                _queryBuilder = APIHelper.appendUrlWithTemplateParameters(_queryBuilder, {
                    'driver_id_or_external_id': driverIdOrExternalId
                });

                // Process query parameters
                _queryBuilder = APIHelper.appendUrlWithQueryParameters(_queryBuilder, {
                    'access_token': accessToken
                });

                //validate and preprocess url
                var _queryUrl = APIHelper.cleanUrl(_queryBuilder);
                
                // prepare headers
                var _headers = {
                    'accept': 'application/json'
                };

                // prepare and invoke the API call request to fetch the response
                var _config = {
                    method: 'GET',
                    queryUrl: _queryUrl,
                    headers: _headers,
                };
                
                var _response = new HttpClient(_config);
                
                //process response
                _response.then(function success(_result) {
                    var parsed = _result.body;
                    parsed = BaseController.getObjectMapper().mapObject(parsed, 'Driver');
                    _result.body = parsed;
                    _deffered.resolve(_result);
                }, function error(_result){
                    // Error handling for custom HTTP status codes
                     else {
                        _deffered.reject(APIHelper.appendContext({
                            errorMessage:'HTTP Response Not OK',
                            errorCode: _result.code,
                            errorResponse: _result.message
                        }, _result.getContext()));
                    }
                });
                
                return _deffered.promise;
            },
            /**
             * Fetch deactivated driver by id.
             *
             * @param {string} accessToken Samsara API access token.
             * @param {string} driverIdOrExternalId ID of the driver.  This must be either the numeric ID generated
             * by Samsara or the external ID of the driver.  External IDs are
             * customer specified key-value pairs.
             *
             * @return {promise<Driver>}
             */
            getDeactivatedDriverById: function (accessToken, driverIdOrExternalId) {

                //Create promise to return
                var _deffered = $q.defer();
                
                //prepare query string for API call
                var _baseUri = Configuration.BASEURI;
                var _queryBuilder = _baseUri + '/fleet/drivers/inactive/{driver_id_or_external_id}';
                
                // Process template parameters
                _queryBuilder = APIHelper.appendUrlWithTemplateParameters(_queryBuilder, {
                    'driver_id_or_external_id': driverIdOrExternalId
                });

                // Process query parameters
                _queryBuilder = APIHelper.appendUrlWithQueryParameters(_queryBuilder, {
                    'access_token': accessToken
                });

                //validate and preprocess url
                var _queryUrl = APIHelper.cleanUrl(_queryBuilder);
                
                // prepare headers
                var _headers = {
                    'accept': 'application/json'
                };

                // prepare and invoke the API call request to fetch the response
                var _config = {
                    method: 'GET',
                    queryUrl: _queryUrl,
                    headers: _headers,
                };
                
                var _response = new HttpClient(_config);
                
                //process response
                _response.then(function success(_result) {
                    var parsed = _result.body;
                    parsed = BaseController.getObjectMapper().mapObject(parsed, 'Driver');
                    _result.body = parsed;
                    _deffered.resolve(_result);
                }, function error(_result){
                    // Error handling for custom HTTP status codes
                     else {
                        _deffered.reject(APIHelper.appendContext({
                            errorMessage:'HTTP Response Not OK',
                            errorCode: _result.code,
                            errorResponse: _result.message
                        }, _result.getContext()));
                    }
                });
                
                return _deffered.promise;
            },
            /**
             * Fetch all deactivated drivers for the group.
             *
             * @param {string} accessToken Samsara API access token.
             * @param {long|null} groupId [Optional] Optional group ID if the organization has multiple groups
             * (uncommon).
             *
             * @return {promise<Driver>}
             */
            getAllDeactivatedDrivers: function (accessToken, groupId) {

                //Create promise to return
                var _deffered = $q.defer();
                
                //prepare query string for API call
                var _baseUri = Configuration.BASEURI;
                var _queryBuilder = _baseUri + '/fleet/drivers/inactive';
                
                // Process query parameters
                _queryBuilder = APIHelper.appendUrlWithQueryParameters(_queryBuilder, {
                    'access_token': accessToken,
                    'group_id': groupId
                });

                //validate and preprocess url
                var _queryUrl = APIHelper.cleanUrl(_queryBuilder);
                
                // prepare headers
                var _headers = {
                    'accept': 'application/json'
                };

                // prepare and invoke the API call request to fetch the response
                var _config = {
                    method: 'GET',
                    queryUrl: _queryUrl,
                    headers: _headers,
                };
                
                var _response = new HttpClient(_config);
                
                //process response
                _response.then(function success(_result) {
                    var parsed = _result.body;
                    parsed = parsed.map(function(model){
                        return BaseController.getObjectMapper().mapObject(model, 'Driver');
                    });
                    _result.body = parsed;
                    _deffered.resolve(_result);
                }, function error(_result){
                    // Error handling for custom HTTP status codes
                     else {
                        _deffered.reject(APIHelper.appendContext({
                            errorMessage:'HTTP Response Not OK',
                            errorCode: _result.code,
                            errorResponse: _result.message
                        }, _result.getContext()));
                    }
                });
                
                return _deffered.promise;
            },
            /**
             * Create a new driver.
             *
             * @param {string} accessToken Samsara API access token.
             * @param {DriverForCreate} createDriverParam Driver creation body
             *
             * @return {promise<Driver>}
             */
            createDriver: function (accessToken, createDriverParam) {

                //Create promise to return
                var _deffered = $q.defer();
                
                //prepare query string for API call
                var _baseUri = Configuration.BASEURI;
                var _queryBuilder = _baseUri + '/fleet/drivers/create';
                
                // Process query parameters
                _queryBuilder = APIHelper.appendUrlWithQueryParameters(_queryBuilder, {
                    'access_token': accessToken
                });

                //validate and preprocess url
                var _queryUrl = APIHelper.cleanUrl(_queryBuilder);
                
                // prepare headers
                var _headers = {
                    'accept': 'application/json',
                    'content-type': 'application/json; charset=utf-8'
                };

                // Remove null values
                APIHelper.cleanObject(createDriverParam);

                // prepare and invoke the API call request to fetch the response
                var _config = {
                    method: 'POST',
                    queryUrl: _queryUrl,
                    headers: _headers,
                    body: createDriverParam.toJSON()
                };
                
                var _response = new HttpClient(_config);
                
                //process response
                _response.then(function success(_result) {
                    var parsed = _result.body;
                    parsed = BaseController.getObjectMapper().mapObject(parsed, 'Driver');
                    _result.body = parsed;
                    _deffered.resolve(_result);
                }, function error(_result){
                    // Error handling for custom HTTP status codes
                     else {
                        _deffered.reject(APIHelper.appendContext({
                            errorMessage:'HTTP Response Not OK',
                            errorCode: _result.code,
                            errorResponse: _result.message
                        }, _result.getContext()));
                    }
                });
                
                return _deffered.promise;
            },
            /**
             * Get all the drivers for the specified group.
             *
             * @param {string} accessToken Samsara API access token.
             * @param {GroupDriversParam} groupDriversParam TODO: type description here
             *
             * @return {promise<DriversResponse>}
             */
            createGetFleetDrivers: function (accessToken, groupDriversParam) {

                //Create promise to return
                var _deffered = $q.defer();
                
                //prepare query string for API call
                var _baseUri = Configuration.BASEURI;
                var _queryBuilder = _baseUri + '/fleet/drivers';
                
                // Process query parameters
                _queryBuilder = APIHelper.appendUrlWithQueryParameters(_queryBuilder, {
                    'access_token': accessToken
                });

                //validate and preprocess url
                var _queryUrl = APIHelper.cleanUrl(_queryBuilder);
                
                // prepare headers
                var _headers = {
                    'accept': 'application/json',
                    'content-type': 'application/json; charset=utf-8'
                };

                // Remove null values
                APIHelper.cleanObject(groupDriversParam);

                // prepare and invoke the API call request to fetch the response
                var _config = {
                    method: 'POST',
                    queryUrl: _queryUrl,
                    headers: _headers,
                    body: groupDriversParam.toJSON()
                };
                
                var _response = new HttpClient(_config);
                
                //process response
                _response.then(function success(_result) {
                    var parsed = _result.body;
                    parsed = BaseController.getObjectMapper().mapObject(parsed, 'DriversResponse');
                    _result.body = parsed;
                    _deffered.resolve(_result);
                }, function error(_result){
                    // Error handling for custom HTTP status codes
                     else {
                        _deffered.reject(APIHelper.appendContext({
                            errorMessage:'HTTP Response Not OK',
                            errorCode: _result.code,
                            errorResponse: _result.message
                        }, _result.getContext()));
                    }
                });
                
                return _deffered.promise;
            },
            /**
             * Delete a dispatch route and its associated jobs.
             *
             * @param {string} accessToken Samsara API access token.
             * @param {long} routeId ID of the dispatch route.
             *
             * @return {promise<Void>}
             */
            deleteDispatchRouteById: function (accessToken, routeId) {

                //Create promise to return
                var _deffered = $q.defer();
                
                //prepare query string for API call
                var _baseUri = Configuration.BASEURI;
                var _queryBuilder = _baseUri + '/fleet/dispatch/routes/{route_id}';
                
                // Process template parameters
                _queryBuilder = APIHelper.appendUrlWithTemplateParameters(_queryBuilder, {
                    'route_id': routeId
                });

                // Process query parameters
                _queryBuilder = APIHelper.appendUrlWithQueryParameters(_queryBuilder, {
                    'access_token': accessToken
                });

                //validate and preprocess url
                var _queryUrl = APIHelper.cleanUrl(_queryBuilder);
                
                // prepare and invoke the API call request to fetch the response
                var _config = {
                    method: 'DELETE',
                    queryUrl: _queryUrl,
                };
                
                var _response = new HttpClient(_config);
                
                //process response
                _response.then(function success(_result) {
                    _deffered.resolve(_result);
                }, function error(_result){
                    // Error handling for custom HTTP status codes
                     else {
                        _deffered.reject(APIHelper.appendContext({
                            errorMessage:'HTTP Response Not OK',
                            errorCode: _result.code,
                            errorResponse: _result.message
                        }, _result.getContext()));
                    }
                });
                
                return _deffered.promise;
            },
            /**
             * Fetch a dispatch route by id.
             *
             * @param {string} accessToken Samsara API access token.
             * @param {long} routeId ID of the dispatch route.
             *
             * @return {promise<DispatchRoute>}
             */
            getDispatchRouteById: function (accessToken, routeId) {

                //Create promise to return
                var _deffered = $q.defer();
                
                //prepare query string for API call
                var _baseUri = Configuration.BASEURI;
                var _queryBuilder = _baseUri + '/fleet/dispatch/routes/{route_id}';
                
                // Process template parameters
                _queryBuilder = APIHelper.appendUrlWithTemplateParameters(_queryBuilder, {
                    'route_id': routeId
                });

                // Process query parameters
                _queryBuilder = APIHelper.appendUrlWithQueryParameters(_queryBuilder, {
                    'access_token': accessToken
                });

                //validate and preprocess url
                var _queryUrl = APIHelper.cleanUrl(_queryBuilder);
                
                // prepare headers
                var _headers = {
                    'accept': 'application/json'
                };

                // prepare and invoke the API call request to fetch the response
                var _config = {
                    method: 'GET',
                    queryUrl: _queryUrl,
                    headers: _headers,
                };
                
                var _response = new HttpClient(_config);
                
                //process response
                _response.then(function success(_result) {
                    var parsed = _result.body;
                    parsed = BaseController.getObjectMapper().mapObject(parsed, 'DispatchRoute');
                    _result.body = parsed;
                    _deffered.resolve(_result);
                }, function error(_result){
                    // Error handling for custom HTTP status codes
                     else {
                        _deffered.reject(APIHelper.appendContext({
                            errorMessage:'HTTP Response Not OK',
                            errorCode: _result.code,
                            errorResponse: _result.message
                        }, _result.getContext()));
                    }
                });
                
                return _deffered.promise;
            },
            /**
             * Create a new dispatch route.
             *
             * @param {string} accessToken Samsara API access token.
             * @param {DispatchRouteCreate} createDispatchRouteParams TODO: type description here
             *
             * @return {promise<DispatchRoute>}
             */
            createDispatchRoute: function (accessToken, createDispatchRouteParams) {

                //Create promise to return
                var _deffered = $q.defer();
                
                //prepare query string for API call
                var _baseUri = Configuration.BASEURI;
                var _queryBuilder = _baseUri + '/fleet/dispatch/routes';
                
                // Process query parameters
                _queryBuilder = APIHelper.appendUrlWithQueryParameters(_queryBuilder, {
                    'access_token': accessToken
                });

                //validate and preprocess url
                var _queryUrl = APIHelper.cleanUrl(_queryBuilder);
                
                // prepare headers
                var _headers = {
                    'accept': 'application/json',
                    'content-type': 'application/json; charset=utf-8'
                };

                // Remove null values
                APIHelper.cleanObject(createDispatchRouteParams);

                // prepare and invoke the API call request to fetch the response
                var _config = {
                    method: 'POST',
                    queryUrl: _queryUrl,
                    headers: _headers,
                    body: createDispatchRouteParams.toJSON()
                };
                
                var _response = new HttpClient(_config);
                
                //process response
                _response.then(function success(_result) {
                    var parsed = _result.body;
                    parsed = BaseController.getObjectMapper().mapObject(parsed, 'DispatchRoute');
                    _result.body = parsed;
                    _deffered.resolve(_result);
                }, function error(_result){
                    // Error handling for custom HTTP status codes
                     else {
                        _deffered.reject(APIHelper.appendContext({
                            errorMessage:'HTTP Response Not OK',
                            errorCode: _result.code,
                            errorResponse: _result.message
                        }, _result.getContext()));
                    }
                });
                
                return _deffered.promise;
            },
            /**
             * Fetch current locations of all assets for the group.
             *
             * @param {string} accessToken Samsara API access token.
             *
             * @return {promise<GetAllAssetCurrentLocationsResponse>}
             */
            getAllAssetCurrentLocations: function (accessToken) {

                //Create promise to return
                var _deffered = $q.defer();
                
                //prepare query string for API call
                var _baseUri = Configuration.BASEURI;
                var _queryBuilder = _baseUri + '/fleet/assets/locations';
                
                // Process query parameters
                _queryBuilder = APIHelper.appendUrlWithQueryParameters(_queryBuilder, {
                    'access_token': accessToken
                });

                //validate and preprocess url
                var _queryUrl = APIHelper.cleanUrl(_queryBuilder);
                
                // prepare headers
                var _headers = {
                    'accept': 'application/json'
                };

                // prepare and invoke the API call request to fetch the response
                var _config = {
                    method: 'GET',
                    queryUrl: _queryUrl,
                    headers: _headers,
                };
                
                var _response = new HttpClient(_config);
                
                //process response
                _response.then(function success(_result) {
                    var parsed = _result.body;
                    parsed = BaseController.getObjectMapper().mapObject(parsed, 'GetAllAssetCurrentLocationsResponse');
                    _result.body = parsed;
                    _deffered.resolve(_result);
                }, function error(_result){
                    // Error handling for custom HTTP status codes
                     else {
                        _deffered.reject(APIHelper.appendContext({
                            errorMessage:'HTTP Response Not OK',
                            errorCode: _result.code,
                            errorResponse: _result.message
                        }, _result.getContext()));
                    }
                });
                
                return _deffered.promise;
            },
            /**
             * Fetch all of the assets for the group.
             *
             * @param {string} accessToken Samsara API access token.
             *
             * @return {promise<GetAllAssetsResponse>}
             */
            getAllAssets: function (accessToken) {

                //Create promise to return
                var _deffered = $q.defer();
                
                //prepare query string for API call
                var _baseUri = Configuration.BASEURI;
                var _queryBuilder = _baseUri + '/fleet/assets';
                
                // Process query parameters
                _queryBuilder = APIHelper.appendUrlWithQueryParameters(_queryBuilder, {
                    'access_token': accessToken
                });

                //validate and preprocess url
                var _queryUrl = APIHelper.cleanUrl(_queryBuilder);
                
                // prepare headers
                var _headers = {
                    'accept': 'application/json'
                };

                // prepare and invoke the API call request to fetch the response
                var _config = {
                    method: 'GET',
                    queryUrl: _queryUrl,
                    headers: _headers,
                };
                
                var _response = new HttpClient(_config);
                
                //process response
                _response.then(function success(_result) {
                    var parsed = _result.body;
                    parsed = BaseController.getObjectMapper().mapObject(parsed, 'GetAllAssetsResponse');
                    _result.body = parsed;
                    _deffered.resolve(_result);
                }, function error(_result){
                    // Error handling for custom HTTP status codes
                     else {
                        _deffered.reject(APIHelper.appendContext({
                            errorMessage:'HTTP Response Not OK',
                            errorCode: _result.code,
                            errorResponse: _result.message
                        }, _result.getContext()));
                    }
                });
                
                return _deffered.promise;
            },
            /**
             * This method adds an address book entry to the specified group.
             *
             * @param {string} accessToken Samsara API access token.
             * @param {AddressParam} addressParam TODO: type description here
             *
             * @return {promise<Void>}
             */
            addFleetAddress: function (accessToken, addressParam) {

                //Create promise to return
                var _deffered = $q.defer();
                
                //prepare query string for API call
                var _baseUri = Configuration.BASEURI;
                var _queryBuilder = _baseUri + '/fleet/add_address';
                
                // Process query parameters
                _queryBuilder = APIHelper.appendUrlWithQueryParameters(_queryBuilder, {
                    'access_token': accessToken
                });

                //validate and preprocess url
                var _queryUrl = APIHelper.cleanUrl(_queryBuilder);
                
                // prepare headers
                var _headers = {
                    'content-type': 'application/json; charset=utf-8'
                };

                // Remove null values
                APIHelper.cleanObject(addressParam);

                // prepare and invoke the API call request to fetch the response
                var _config = {
                    method: 'POST',
                    queryUrl: _queryUrl,
                    headers: _headers,
                    body: addressParam.toJSON()
                };
                
                var _response = new HttpClient(_config);
                
                //process response
                _response.then(function success(_result) {
                    _deffered.resolve(_result);
                }, function error(_result){
                    // Error handling for custom HTTP status codes
                     else {
                        _deffered.reject(APIHelper.appendContext({
                            errorMessage:'HTTP Response Not OK',
                            errorCode: _result.code,
                            errorResponse: _result.message
                        }, _result.getContext()));
                    }
                });
                
                return _deffered.promise;
            },
            /**
             * Fetch a contact by its id.
             *
             * @param {string} accessToken Samsara API access token.
             * @param {long} contactId ID of the contact
             *
             * @return {promise<Contact>}
             */
            getOrganizationContact: function (accessToken, contactId) {

                //Create promise to return
                var _deffered = $q.defer();
                
                //prepare query string for API call
                var _baseUri = Configuration.BASEURI;
                var _queryBuilder = _baseUri + '/contacts/{contact_id}';
                
                // Process template parameters
                _queryBuilder = APIHelper.appendUrlWithTemplateParameters(_queryBuilder, {
                    'contact_id': contactId
                });

                // Process query parameters
                _queryBuilder = APIHelper.appendUrlWithQueryParameters(_queryBuilder, {
                    'access_token': accessToken
                });

                //validate and preprocess url
                var _queryUrl = APIHelper.cleanUrl(_queryBuilder);
                
                // prepare headers
                var _headers = {
                    'accept': 'application/json'
                };

                // prepare and invoke the API call request to fetch the response
                var _config = {
                    method: 'GET',
                    queryUrl: _queryUrl,
                    headers: _headers,
                };
                
                var _response = new HttpClient(_config);
                
                //process response
                _response.then(function success(_result) {
                    var parsed = _result.body;
                    parsed = BaseController.getObjectMapper().mapObject(parsed, 'Contact');
                    _result.body = parsed;
                    _deffered.resolve(_result);
                }, function error(_result){
                    // Error handling for custom HTTP status codes
                     else {
                        _deffered.reject(APIHelper.appendContext({
                            errorMessage:'HTTP Response Not OK',
                            errorCode: _result.code,
                            errorResponse: _result.message
                        }, _result.getContext()));
                    }
                });
                
                return _deffered.promise;
            },
            /**
             * Fetch all contacts for the organization.
             *
             * @param {string} accessToken Samsara API access token.
             *
             * @return {promise<Contact>}
             */
            listContacts: function (accessToken) {

                //Create promise to return
                var _deffered = $q.defer();
                
                //prepare query string for API call
                var _baseUri = Configuration.BASEURI;
                var _queryBuilder = _baseUri + '/contacts';
                
                // Process query parameters
                _queryBuilder = APIHelper.appendUrlWithQueryParameters(_queryBuilder, {
                    'access_token': accessToken
                });

                //validate and preprocess url
                var _queryUrl = APIHelper.cleanUrl(_queryBuilder);
                
                // prepare headers
                var _headers = {
                    'accept': 'application/json'
                };

                // prepare and invoke the API call request to fetch the response
                var _config = {
                    method: 'GET',
                    queryUrl: _queryUrl,
                    headers: _headers,
                };
                
                var _response = new HttpClient(_config);
                
                //process response
                _response.then(function success(_result) {
                    var parsed = _result.body;
                    parsed = parsed.map(function(model){
                        return BaseController.getObjectMapper().mapObject(model, 'Contact');
                    });
                    _result.body = parsed;
                    _deffered.resolve(_result);
                }, function error(_result){
                    // Error handling for custom HTTP status codes
                     else {
                        _deffered.reject(APIHelper.appendContext({
                            errorMessage:'HTTP Response Not OK',
                            errorCode: _result.code,
                            errorResponse: _result.message
                        }, _result.getContext()));
                    }
                });
                
                return _deffered.promise;
            },
            /**
             * Delete an address.
             *
             * @param {string} accessToken Samsara API access token.
             * @param {long} addressId ID of the address/geofence
             *
             * @return {promise<Void>}
             */
            deleteOrganizationAddress: function (accessToken, addressId) {

                //Create promise to return
                var _deffered = $q.defer();
                
                //prepare query string for API call
                var _baseUri = Configuration.BASEURI;
                var _queryBuilder = _baseUri + '/addresses/{addressId}';
                
                // Process template parameters
                _queryBuilder = APIHelper.appendUrlWithTemplateParameters(_queryBuilder, {
                    'addressId': addressId
                });

                // Process query parameters
                _queryBuilder = APIHelper.appendUrlWithQueryParameters(_queryBuilder, {
                    'access_token': accessToken
                });

                //validate and preprocess url
                var _queryUrl = APIHelper.cleanUrl(_queryBuilder);
                
                // prepare and invoke the API call request to fetch the response
                var _config = {
                    method: 'DELETE',
                    queryUrl: _queryUrl,
                };
                
                var _response = new HttpClient(_config);
                
                //process response
                _response.then(function success(_result) {
                    _deffered.resolve(_result);
                }, function error(_result){
                    // Error handling for custom HTTP status codes
                     else {
                        _deffered.reject(APIHelper.appendContext({
                            errorMessage:'HTTP Response Not OK',
                            errorCode: _result.code,
                            errorResponse: _result.message
                        }, _result.getContext()));
                    }
                });
                
                return _deffered.promise;
            },
            /**
             * Fetch an address by its id.
             *
             * @param {string} accessToken Samsara API access token.
             * @param {long} addressId ID of the address/geofence
             *
             * @return {promise<Address>}
             */
            getOrganizationAddress: function (accessToken, addressId) {

                //Create promise to return
                var _deffered = $q.defer();
                
                //prepare query string for API call
                var _baseUri = Configuration.BASEURI;
                var _queryBuilder = _baseUri + '/addresses/{addressId}';
                
                // Process template parameters
                _queryBuilder = APIHelper.appendUrlWithTemplateParameters(_queryBuilder, {
                    'addressId': addressId
                });

                // Process query parameters
                _queryBuilder = APIHelper.appendUrlWithQueryParameters(_queryBuilder, {
                    'access_token': accessToken
                });

                //validate and preprocess url
                var _queryUrl = APIHelper.cleanUrl(_queryBuilder);
                
                // prepare headers
                var _headers = {
                    'accept': 'application/json'
                };

                // prepare and invoke the API call request to fetch the response
                var _config = {
                    method: 'GET',
                    queryUrl: _queryUrl,
                    headers: _headers,
                };
                
                var _response = new HttpClient(_config);
                
                //process response
                _response.then(function success(_result) {
                    var parsed = _result.body;
                    parsed = BaseController.getObjectMapper().mapObject(parsed, 'Address');
                    _result.body = parsed;
                    _deffered.resolve(_result);
                }, function error(_result){
                    // Error handling for custom HTTP status codes
                     else {
                        _deffered.reject(APIHelper.appendContext({
                            errorMessage:'HTTP Response Not OK',
                            errorCode: _result.code,
                            errorResponse: _result.message
                        }, _result.getContext()));
                    }
                });
                
                return _deffered.promise;
            },
            /**
             * Update the name, formatted address, geofence, notes, or tag and contact Ids for an address. The set
             * of tags or contacts associated with this address will be updated to exactly match the list of IDs
             * passed in. To remove all tags or contacts from an address, pass an empty list; to remove notes, pass
             * an empty string.
             *
             * @param {string} accessToken Samsara API access token.
             * @param {Address1} address Update parts of an address's value. If the geofence 'circle' or 'polygon'
             * key is specified, the update will change the type of geofence accordingly.
             * @param {long} addressId ID of the address/geofence
             *
             * @return {promise<Void>}
             */
            updateOrganizationAddress: function (accessToken, address, addressId) {

                //Create promise to return
                var _deffered = $q.defer();
                
                //prepare query string for API call
                var _baseUri = Configuration.BASEURI;
                var _queryBuilder = _baseUri + '/addresses/{addressId}';
                
                // Process template parameters
                _queryBuilder = APIHelper.appendUrlWithTemplateParameters(_queryBuilder, {
                    'addressId': addressId
                });

                // Process query parameters
                _queryBuilder = APIHelper.appendUrlWithQueryParameters(_queryBuilder, {
                    'access_token': accessToken
                });

                //validate and preprocess url
                var _queryUrl = APIHelper.cleanUrl(_queryBuilder);
                
                // prepare headers
                var _headers = {
                    'content-type': 'application/json; charset=utf-8'
                };

                // Remove null values
                APIHelper.cleanObject(address);

                // prepare and invoke the API call request to fetch the response
                var _config = {
                    method: 'PATCH',
                    queryUrl: _queryUrl,
                    headers: _headers,
                    body: address.toJSON()
                };
                
                var _response = new HttpClient(_config);
                
                //process response
                _response.then(function success(_result) {
                    _deffered.resolve(_result);
                }, function error(_result){
                    // Error handling for custom HTTP status codes
                     else {
                        _deffered.reject(APIHelper.appendContext({
                            errorMessage:'HTTP Response Not OK',
                            errorCode: _result.code,
                            errorResponse: _result.message
                        }, _result.getContext()));
                    }
                });
                
                return _deffered.promise;
            },
            /**
             * Fetch all addresses/geofences for the organization. An address contains either a circle or polygon
             * geofence describing the address boundaries.
             *
             * @param {string} accessToken Samsara API access token.
             *
             * @return {promise<Address>}
             */
            getOrganizationAddresses: function (accessToken) {

                //Create promise to return
                var _deffered = $q.defer();
                
                //prepare query string for API call
                var _baseUri = Configuration.BASEURI;
                var _queryBuilder = _baseUri + '/addresses';
                
                // Process query parameters
                _queryBuilder = APIHelper.appendUrlWithQueryParameters(_queryBuilder, {
                    'access_token': accessToken
                });

                //validate and preprocess url
                var _queryUrl = APIHelper.cleanUrl(_queryBuilder);
                
                // prepare headers
                var _headers = {
                    'accept': 'application/json'
                };

                // prepare and invoke the API call request to fetch the response
                var _config = {
                    method: 'GET',
                    queryUrl: _queryUrl,
                    headers: _headers,
                };
                
                var _response = new HttpClient(_config);
                
                //process response
                _response.then(function success(_result) {
                    var parsed = _result.body;
                    parsed = parsed.map(function(model){
                        return BaseController.getObjectMapper().mapObject(model, 'Address');
                    });
                    _result.body = parsed;
                    _deffered.resolve(_result);
                }, function error(_result){
                    // Error handling for custom HTTP status codes
                     else {
                        _deffered.reject(APIHelper.appendContext({
                            errorMessage:'HTTP Response Not OK',
                            errorCode: _result.code,
                            errorResponse: _result.message
                        }, _result.getContext()));
                    }
                });
                
                return _deffered.promise;
            },
            /**
             * Add one or more addresses to the organization
             *
             * @param {string} accessToken Samsara API access token.
             * @param {Addresses} addresses List of addresses/geofences to add. Geofences can be circular or a
             * polygon.  For each address, only one of 'circle' or 'polygon' should be
             * provided. If both are provided, the geofence will be saved as a polygon.
             *
             * @return {promise<Address>}
             */
            addOrganizationAddresses: function (accessToken, addresses) {

                //Create promise to return
                var _deffered = $q.defer();
                
                //prepare query string for API call
                var _baseUri = Configuration.BASEURI;
                var _queryBuilder = _baseUri + '/addresses';
                
                // Process query parameters
                _queryBuilder = APIHelper.appendUrlWithQueryParameters(_queryBuilder, {
                    'access_token': accessToken
                });

                //validate and preprocess url
                var _queryUrl = APIHelper.cleanUrl(_queryBuilder);
                
                // prepare headers
                var _headers = {
                    'accept': 'application/json',
                    'content-type': 'application/json; charset=utf-8'
                };

                // Remove null values
                APIHelper.cleanObject(addresses);

                // prepare and invoke the API call request to fetch the response
                var _config = {
                    method: 'POST',
                    queryUrl: _queryUrl,
                    headers: _headers,
                    body: addresses.toJSON()
                };
                
                var _response = new HttpClient(_config);
                
                //process response
                _response.then(function success(_result) {
                    var parsed = _result.body;
                    parsed = parsed.map(function(model){
                        return BaseController.getObjectMapper().mapObject(model, 'Address');
                    });
                    _result.body = parsed;
                    _deffered.resolve(_result);
                }, function error(_result){
                    // Error handling for custom HTTP status codes
                     else {
                        _deffered.reject(APIHelper.appendContext({
                            errorMessage:'HTTP Response Not OK',
                            errorCode: _result.code,
                            errorResponse: _result.message
                        }, _result.getContext()));
                    }
                });
                
                return _deffered.promise;
            }
        };
    }

}(angular));
