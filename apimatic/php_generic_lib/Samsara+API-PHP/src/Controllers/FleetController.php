<?php
/*
 * SamsaraAPILib
 *
 * This file was automatically generated by APIMATIC v2.0 ( https://apimatic.io ).
 */

namespace SamsaraAPILib\Controllers;

use SamsaraAPILib\APIException;
use SamsaraAPILib\APIHelper;
use SamsaraAPILib\Configuration;
use SamsaraAPILib\Models;
use SamsaraAPILib\Exceptions;
use SamsaraAPILib\Http\HttpRequest;
use SamsaraAPILib\Http\HttpResponse;
use SamsaraAPILib\Http\HttpMethod;
use SamsaraAPILib\Http\HttpContext;
use Unirest\Request;

/**
 * @todo Add a general description for this controller.
 */
class FleetController extends BaseController
{
    /**
     * @var FleetController The reference to *Singleton* instance of this class
     */
    private static $instance;

    /**
     * Returns the *Singleton* instance of this class.
     * @return FleetController The *Singleton* instance.
     */
    public static function getInstance()
    {
        if (null === static::$instance) {
            static::$instance = new static();
        }
        
        return static::$instance;
    }

    /**
     * Fetch all of the document types.
     *
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getDriverDocumentTypesByOrgId()
    {

        //prepare query string for API call
        $_queryBuilder = '/fleet/drivers/document_types';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'access_token' => Configuration::$accessToken,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl(Configuration::$BASEURI . $_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => BaseController::USER_AGENT,
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //Error handling using HTTP status codes
        if (($response->code < 200) || ($response->code > 208)) {
            throw new APIException('Unexpected error.', $_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClassArray($response->body, 'SamsaraAPILib\\Models\\DocumentType');
    }

    /**
     * Fetch locations for a given vehicle between a start/end time. The maximum query duration is one hour.
     *
     * @param string  $accessToken  Samsara API access token.
     * @param integer $vehicleId    ID of the vehicle with the associated routes.
     * @param integer $startMs      Time in Unix epoch milliseconds for the start of the query (cannot exceed 1 hour)
     * @param integer $endMs        Time in Unix epoch milliseconds for the end of the query (cannot exceed 1 hour)
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getVehicleLocations(
        $accessToken,
        $vehicleId,
        $startMs,
        $endMs
    ) {

        //prepare query string for API call
        $_queryBuilder = '/fleet/vehicles/{vehicle_id}/locations';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'vehicle_id'   => $vehicleId,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'access_token' => $accessToken,
            'startMs'      => $startMs,
            'endMs'        => $endMs,
            'access_token' => Configuration::$accessToken,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl(Configuration::$BASEURI . $_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => BaseController::USER_AGENT,
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //Error handling using HTTP status codes
        if (($response->code < 200) || ($response->code > 208)) {
            throw new APIException('Unexpected error.', $_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClassArray($response->body, 'SamsaraAPILib\\Models\\FleetVehicleLocation');
    }

    /**
     * Create a new dispatch route for the vehicle with vehicle_id.
     *
     * @param Models\DispatchRouteCreate $createDispatchRouteParams TODO: type description here
     * @param string                     $accessToken               Samsara API access token.
     * @param integer                    $vehicleId                 ID of the vehicle with the associated routes.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createVehicleDispatchRoute(
        $createDispatchRouteParams,
        $accessToken,
        $vehicleId
    ) {

        //prepare query string for API call
        $_queryBuilder = '/fleet/vehicles/{vehicle_id}/dispatch/routes';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'vehicle_id'                => $vehicleId,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'access_token'              => $accessToken,
            'access_token' => Configuration::$accessToken,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl(Configuration::$BASEURI . $_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'              => BaseController::USER_AGENT,
            'Accept'                  => 'application/json',
            'content-type'            => 'application/json; charset=utf-8'
        );

        //json encode body
        $_bodyJson = Request\Body::Json($createDispatchRouteParams);

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers, $_bodyJson);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //Error handling using HTTP status codes
        if (($response->code < 200) || ($response->code > 208)) {
            throw new APIException('Unexpected error.', $_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'SamsaraAPILib\\Models\\DispatchRoute');
    }

    /**
     * Fetch all of the dispatch routes for a given vehicle.
     *
     * @param string  $accessToken  Samsara API access token.
     * @param integer $vehicleId    ID of the vehicle with the associated routes.
     * @param integer $endTime      (optional) Time in unix milliseconds that represents the oldest routes to return.
     *                              Used in combination with duration. Defaults to now.
     * @param integer $duration     (optional) Time in milliseconds that represents the duration before end_time to
     *                              query. Defaults to 24 hours.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getDispatchRoutesByVehicleId(
        $accessToken,
        $vehicleId,
        $endTime = null,
        $duration = null
    ) {

        //prepare query string for API call
        $_queryBuilder = '/fleet/vehicles/{vehicle_id}/dispatch/routes';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'vehicle_id'   => $vehicleId,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'access_token' => $accessToken,
            'end_time'     => $endTime,
            'duration'     => $duration,
            'access_token' => Configuration::$accessToken,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl(Configuration::$BASEURI . $_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => BaseController::USER_AGENT,
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //Error handling using HTTP status codes
        if (($response->code < 200) || ($response->code > 208)) {
            throw new APIException('Unexpected error.', $_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClassArray($response->body, 'SamsaraAPILib\\Models\\DispatchRoute');
    }

    /**
     * Updates the specified vehicle using JSON merge patch format. See IETF RFC 7396: https://tools.ietf.
     * org/html/rfc7396.
     *
     * @param string      $accessToken               Samsara API access token.
     * @param string      $vehicleIdOrExternalId     ID of the vehicle.  This must be either the numeric ID generated
     *                                               by Samsara or the external ID of the vehicle.  External IDs are
     *                                               customer specified key-value pairs.
     * @param Models\Data $data                      TODO: type description here
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function patchFleetVehicle(
        $accessToken,
        $vehicleIdOrExternalId,
        $data
    ) {

        //prepare query string for API call
        $_queryBuilder = '/fleet/vehicles/{vehicle_id_or_external_id}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'vehicle_id_or_external_id' => $vehicleIdOrExternalId,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'access_token'              => $accessToken,
            'access_token' => Configuration::$accessToken,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl(Configuration::$BASEURI . $_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'              => BaseController::USER_AGENT,
            'Accept'                  => 'application/json',
            'content-type'            => 'application/json; charset=utf-8'
        );

        //json encode body
        $_bodyJson = Request\Body::Json($data);

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PATCH, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::patch($_queryUrl, $_headers, $_bodyJson);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //Error handling using HTTP status codes
        if (($response->code < 200) || ($response->code > 208)) {
            throw new APIException('Unexpected error.', $_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'SamsaraAPILib\\Models\\FleetVehicleResponse');
    }

    /**
     * Fetch the safety score for the vehicle.
     *
     * @param string  $accessToken  Samsara API access token.
     * @param integer $startMs      Timestamp in milliseconds representing the start of the period to fetch, inclusive.
     *                              Used in combination with endMs.
     * @param integer $endMs        Timestamp in milliseconds representing the end of the period to fetch, inclusive.
     *                              Used in combination with startMs.
     * @param integer $vehicleId    ID of the vehicle
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getVehicleSafetyScore(
        $accessToken,
        $startMs,
        $endMs,
        $vehicleId
    ) {

        //prepare query string for API call
        $_queryBuilder = '/fleet/vehicles/{vehicleId}/safety/score';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'vehicleId'    => $vehicleId,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'access_token' => $accessToken,
            'startMs'      => $startMs,
            'endMs'        => $endMs,
            'access_token' => Configuration::$accessToken,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl(Configuration::$BASEURI . $_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => BaseController::USER_AGENT,
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //Error handling using HTTP status codes
        if (($response->code < 200) || ($response->code > 208)) {
            throw new APIException('Unexpected error.', $_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'SamsaraAPILib\\Models\\VehicleSafetyScoreResponse');
    }

    /**
     * Fetch harsh event details for a vehicle.
     *
     * @param string  $accessToken  Samsara API access token.
     * @param integer $timestamp    Timestamp in milliseconds representing the timestamp of a harsh event.
     * @param integer $vehicleId    ID of the vehicle
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getVehicleHarshEvent(
        $accessToken,
        $timestamp,
        $vehicleId
    ) {

        //prepare query string for API call
        $_queryBuilder = '/fleet/vehicles/{vehicleId}/safety/harsh_event';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'vehicleId'    => $vehicleId,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'access_token' => $accessToken,
            'timestamp'    => $timestamp,
            'access_token' => Configuration::$accessToken,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl(Configuration::$BASEURI . $_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => BaseController::USER_AGENT,
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //Error handling using HTTP status codes
        if (($response->code < 200) || ($response->code > 208)) {
            throw new APIException('Unexpected error.', $_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'SamsaraAPILib\\Models\\VehicleHarshEventResponse');
    }

    /**
     * Fetch locations for a given vehicle between a start/end time. The maximum query duration is 30
     * minutes.
     *
     * @param string  $accessToken  Samsara API access token.
     * @param integer $startMs      Time in Unix epoch milliseconds for the start of the query (cannot exceed 30
     *                              minutes)
     * @param integer $endMs        Time in Unix epoch milliseconds for the end of the query (cannot exceed 30
     *                              minutes)
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getVehiclesLocations(
        $accessToken,
        $startMs,
        $endMs
    ) {

        //prepare query string for API call
        $_queryBuilder = '/fleet/vehicles/locations';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'access_token' => $accessToken,
            'startMs'      => $startMs,
            'endMs'        => $endMs,
            'access_token' => Configuration::$accessToken,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl(Configuration::$BASEURI . $_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => BaseController::USER_AGENT,
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //Error handling using HTTP status codes
        if (($response->code < 200) || ($response->code > 208)) {
            throw new APIException('Unexpected error.', $_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClassArray($response->body, 'SamsaraAPILib\\Models\\FleetVehiclesLocation');
    }

    /**
     * Get DVIRs for the org within provided time constraints
     *
     * @param string  $accessToken  Samsara API access token.
     * @param integer $endMs        time in millis until the last dvir log.
     * @param integer $durationMs   time in millis which corresponds to the duration before the end_ms.
     * @param integer $groupId      (optional) Group ID to query.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getDvirs(
        $accessToken,
        $endMs,
        $durationMs,
        $groupId = null
    ) {

        //prepare query string for API call
        $_queryBuilder = '/fleet/maintenance/dvirs';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'access_token' => $accessToken,
            'end_ms'       => $endMs,
            'duration_ms'  => $durationMs,
            'group_id'     => $groupId,
            'access_token' => Configuration::$accessToken,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl(Configuration::$BASEURI . $_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => BaseController::USER_AGENT,
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //Error handling using HTTP status codes
        if (($response->code < 200) || ($response->code > 208)) {
            throw new APIException('Unexpected error.', $_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'SamsaraAPILib\\Models\\DvirListResponse');
    }

    /**
     * Gets a specific vehicle.
     *
     * @param string $accessToken               Samsara API access token.
     * @param string $vehicleIdOrExternalId     ID of the vehicle.  This must be either the numeric ID generated by
     *                                          Samsara or the external ID of the vehicle.  External IDs are customer
     *                                          specified key-value pairs.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getFleetVehicle(
        $accessToken,
        $vehicleIdOrExternalId
    ) {

        //prepare query string for API call
        $_queryBuilder = '/fleet/vehicles/{vehicle_id_or_external_id}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'vehicle_id_or_external_id' => $vehicleIdOrExternalId,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'access_token'              => $accessToken,
            'access_token' => Configuration::$accessToken,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl(Configuration::$BASEURI . $_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'              => BaseController::USER_AGENT,
            'Accept'                  => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //Error handling using HTTP status codes
        if (($response->code < 200) || ($response->code > 208)) {
            throw new APIException('Unexpected error.', $_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'SamsaraAPILib\\Models\\FleetVehicleResponse');
    }

    /**
     * Get list of the vehicles. This method returns a list of the vehicles in the Samsara Cloud and
     * information about them.
     *
     * @param string            $accessToken   Samsara API access token.
     * @param Models\GroupParam $groupParam    Group ID to query.
     * @param string            $startingAfter (optional) Pagination parameter indicating the cursor position to
     *                                         continue returning results after. Used in conjunction with the 'limit'
     *                                         parameter. Mutually exclusive with 'endingBefore' parameter.
     * @param string            $endingBefore  (optional) Pagination parameter indicating the cursor position to return
     *                                         results before. Used in conjunction with the 'limit' parameter. Mutually
     *                                         exclusive with 'startingAfter' parameter.
     * @param integer           $limit         (optional) Pagination parameter indicating the number of results to
     *                                         return in this request. Used in conjunction with either 'startingAfter'
     *                                         or 'endingBefore'.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createListFleet(
        $accessToken,
        $groupParam,
        $startingAfter = null,
        $endingBefore = null,
        $limit = null
    ) {

        //prepare query string for API call
        $_queryBuilder = '/fleet/list';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'access_token'  => $accessToken,
            'startingAfter' => $startingAfter,
            'endingBefore'  => $endingBefore,
            'limit'         => $limit,
            'access_token' => Configuration::$accessToken,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl(Configuration::$BASEURI . $_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => BaseController::USER_AGENT,
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //json encode body
        $_bodyJson = Request\Body::Json($groupParam);

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers, $_bodyJson);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //Error handling using HTTP status codes
        if (($response->code < 200) || ($response->code > 208)) {
            throw new APIException('Unexpected error.', $_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'SamsaraAPILib\\Models\\ListFleetResponse');
    }

    /**
     * Get summarized daily HOS charts for a specified driver.
     *
     * @param string              $accessToken  Samsara API access token.
     * @param integer             $driverId     ID of the driver with HOS logs.
     * @param Models\HosLogsParam $hosLogsParam TODO: type description here
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createGetFleetDriversHosDailyLogs(
        $accessToken,
        $driverId,
        $hosLogsParam
    ) {

        //prepare query string for API call
        $_queryBuilder = '/fleet/drivers/{driver_id}/hos_daily_logs';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'driver_id'    => $driverId,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'access_token' => $accessToken,
            'access_token' => Configuration::$accessToken,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl(Configuration::$BASEURI . $_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => BaseController::USER_AGENT,
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //json encode body
        $_bodyJson = Request\Body::Json($hosLogsParam);

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers, $_bodyJson);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //Error handling using HTTP status codes
        if (($response->code < 200) || ($response->code > 208)) {
            throw new APIException('Unexpected error.', $_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'SamsaraAPILib\\Models\\DriverDailyLogResponse');
    }

    /**
     * Create a driver document for the given driver.
     *
     * @param Models\DocumentCreate $createDocumentParams To create a document for a given document type, the document
     *                                                    type's uuid needs to be passed in to documentTypeUuid. The
     *                                                    list of fields passed in should match the document type’s
     *                                                    list of field types in the correct order. In other words, a
     *                                                    field's valueType and value (i.e. only one of: stringValue,
     *                                                    numberValue, or photoValue) at index _i_ should match with
     *                                                    the document field type’s valueType at index _i_.
     * @param string                $accessToken          Samsara API access token.
     * @param integer               $driverId             ID of the driver for whom the document is created.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createDriverDocument(
        $createDocumentParams,
        $accessToken,
        $driverId
    ) {

        //prepare query string for API call
        $_queryBuilder = '/fleet/drivers/{driver_id}/documents';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'driver_id'            => $driverId,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'access_token'         => $accessToken,
            'access_token' => Configuration::$accessToken,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl(Configuration::$BASEURI . $_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'         => BaseController::USER_AGENT,
            'Accept'             => 'application/json',
            'content-type'       => 'application/json; charset=utf-8'
        );

        //json encode body
        $_bodyJson = Request\Body::Json($createDocumentParams);

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers, $_bodyJson);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //Error handling using HTTP status codes
        if (($response->code < 200) || ($response->code > 208)) {
            throw new APIException('Unexpected error.', $_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'SamsaraAPILib\\Models\\Document');
    }

    /**
     * Create a new dispatch route for the driver with driver_id.
     *
     * @param Models\DispatchRouteCreate $createDispatchRouteParams TODO: type description here
     * @param string                     $accessToken               Samsara API access token.
     * @param integer                    $driverId                  ID of the driver with the associated routes.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createDriverDispatchRoute(
        $createDispatchRouteParams,
        $accessToken,
        $driverId
    ) {

        //prepare query string for API call
        $_queryBuilder = '/fleet/drivers/{driver_id}/dispatch/routes';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'driver_id'                 => $driverId,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'access_token'              => $accessToken,
            'access_token' => Configuration::$accessToken,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl(Configuration::$BASEURI . $_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'              => BaseController::USER_AGENT,
            'Accept'                  => 'application/json',
            'content-type'            => 'application/json; charset=utf-8'
        );

        //json encode body
        $_bodyJson = Request\Body::Json($createDispatchRouteParams);

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers, $_bodyJson);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //Error handling using HTTP status codes
        if (($response->code < 200) || ($response->code > 208)) {
            throw new APIException('Unexpected error.', $_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'SamsaraAPILib\\Models\\DispatchRoute');
    }

    /**
     * Get historical trips data for specified vehicle. This method returns a set of historical trips data
     * for the specified vehicle in the specified time range.
     *
     * @param string            $accessToken  Samsara API access token.
     * @param Models\TripsParam $tripsParam   Group ID, vehicle ID and time range to query.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createGetFleetTrips(
        $accessToken,
        $tripsParam
    ) {

        //prepare query string for API call
        $_queryBuilder = '/fleet/trips';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'access_token' => $accessToken,
            'access_token' => Configuration::$accessToken,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl(Configuration::$BASEURI . $_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => BaseController::USER_AGENT,
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //json encode body
        $_bodyJson = Request\Body::Json($tripsParam);

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers, $_bodyJson);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //Error handling using HTTP status codes
        if (($response->code < 200) || ($response->code > 208)) {
            throw new APIException('Unexpected error.', $_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'SamsaraAPILib\\Models\\TripResponse');
    }

    /**
     * This method enables the mutation of metadata for vehicles in the Samsara Cloud.
     *
     * @param string                    $accessToken        Samsara API access token.
     * @param Models\VehicleUpdateParam $vehicleUpdateParam TODO: type description here
     * @return void response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function updateVehicles(
        $accessToken,
        $vehicleUpdateParam
    ) {

        //prepare query string for API call
        $_queryBuilder = '/fleet/set_data';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'access_token'       => $accessToken,
            'access_token' => Configuration::$accessToken,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl(Configuration::$BASEURI . $_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'       => BaseController::USER_AGENT,
            'content-type'     => 'application/json; charset=utf-8'
        );

        //json encode body
        $_bodyJson = Request\Body::Json($vehicleUpdateParam);

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers, $_bodyJson);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //Error handling using HTTP status codes
        if (($response->code < 200) || ($response->code > 208)) {
            throw new APIException('Unexpected error.', $_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);
    }

    /**
     * Get list of the vehicles with any engine faults or check light data.
     *
     * @param string            $accessToken  Samsara API access token.
     * @param Models\GroupParam $groupParam   Group ID to query.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createGetFleetMaintenanceList(
        $accessToken,
        $groupParam
    ) {

        //prepare query string for API call
        $_queryBuilder = '/fleet/maintenance/list';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'access_token' => $accessToken,
            'access_token' => Configuration::$accessToken,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl(Configuration::$BASEURI . $_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => BaseController::USER_AGENT,
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //json encode body
        $_bodyJson = Request\Body::Json($groupParam);

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers, $_bodyJson);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //Error handling using HTTP status codes
        if (($response->code < 200) || ($response->code > 208)) {
            throw new APIException('Unexpected error.', $_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'SamsaraAPILib\\Models\\GetFleetMaintenanceListResponse');
    }

    /**
     * Fetch all of the dispatch routes for a given driver.
     *
     * @param string  $accessToken  Samsara API access token.
     * @param integer $driverId     ID of the driver with the associated routes.
     * @param integer $endTime      (optional) Time in unix milliseconds that represents the oldest routes to return.
     *                              Used in combination with duration. Defaults to now.
     * @param integer $duration     (optional) Time in milliseconds that represents the duration before end_time to
     *                              query. Defaults to 24 hours.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getDispatchRoutesByDriverId(
        $accessToken,
        $driverId,
        $endTime = null,
        $duration = null
    ) {

        //prepare query string for API call
        $_queryBuilder = '/fleet/drivers/{driver_id}/dispatch/routes';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'driver_id'    => $driverId,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'access_token' => $accessToken,
            'end_time'     => $endTime,
            'duration'     => $duration,
            'access_token' => Configuration::$accessToken,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl(Configuration::$BASEURI . $_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => BaseController::USER_AGENT,
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //Error handling using HTTP status codes
        if (($response->code < 200) || ($response->code > 208)) {
            throw new APIException('Unexpected error.', $_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClassArray($response->body, 'SamsaraAPILib\\Models\\DispatchRoute');
    }

    /**
     * Create a new dvir, marking a vehicle or trailer safe or unsafe.
     *
     * @param string                 $accessToken     Samsara API access token.
     * @param Models\CreateDvirParam $createDvirParam DVIR creation body
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createDvir(
        $accessToken,
        $createDvirParam
    ) {

        //prepare query string for API call
        $_queryBuilder = '/fleet/maintenance/dvirs';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'access_token'    => $accessToken,
            'access_token' => Configuration::$accessToken,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl(Configuration::$BASEURI . $_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => BaseController::USER_AGENT,
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //json encode body
        $_bodyJson = Request\Body::Json($createDvirParam);

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers, $_bodyJson);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //Error handling using HTTP status codes
        if (($response->code < 200) || ($response->code > 208)) {
            throw new APIException('Unexpected error.', $_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'SamsaraAPILib\\Models\\DvirBase');
    }

    /**
     * Fetch the safety score for the driver.
     *
     * @param string  $accessToken  Samsara API access token.
     * @param integer $startMs      Timestamp in milliseconds representing the start of the period to fetch, inclusive.
     *                              Used in combination with endMs.
     * @param integer $endMs        Timestamp in milliseconds representing the end of the period to fetch, inclusive.
     *                              Used in combination with startMs.
     * @param integer $driverId     ID of the driver
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getDriverSafetyScore(
        $accessToken,
        $startMs,
        $endMs,
        $driverId
    ) {

        //prepare query string for API call
        $_queryBuilder = '/fleet/drivers/{driverId}/safety/score';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'driverId'     => $driverId,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'access_token' => $accessToken,
            'startMs'      => $startMs,
            'endMs'        => $endMs,
            'access_token' => Configuration::$accessToken,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl(Configuration::$BASEURI . $_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => BaseController::USER_AGENT,
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //Error handling using HTTP status codes
        if (($response->code < 200) || ($response->code > 208)) {
            throw new APIException('Unexpected error.', $_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'SamsaraAPILib\\Models\\DriverSafetyScoreResponse');
    }

    /**
     * Get current location of vehicles in a group. This method returns the current location in latitude
     * and longitude of all vehicles in a requested group.
     *
     * @param string            $accessToken  Samsara API access token.
     * @param Models\GroupParam $groupParam   Group ID to query.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createGetFleetLocations(
        $accessToken,
        $groupParam
    ) {

        //prepare query string for API call
        $_queryBuilder = '/fleet/locations';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'access_token' => $accessToken,
            'access_token' => Configuration::$accessToken,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl(Configuration::$BASEURI . $_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => BaseController::USER_AGENT,
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //json encode body
        $_bodyJson = Request\Body::Json($groupParam);

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers, $_bodyJson);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //Error handling using HTTP status codes
        if (($response->code < 200) || ($response->code > 208)) {
            throw new APIException('Unexpected error.', $_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'SamsaraAPILib\\Models\\GetFleetLocationsResponse');
    }

    /**
     * Get the current HOS status for all drivers in the group.
     *
     * @param string               $accessToken  Samsara API access token.
     * @param Models\HosLogsParam2 $hosLogsParam TODO: type description here
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createGetFleetHosLogsSummary(
        $accessToken,
        $hosLogsParam
    ) {

        //prepare query string for API call
        $_queryBuilder = '/fleet/hos_logs_summary';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'access_token' => $accessToken,
            'access_token' => Configuration::$accessToken,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl(Configuration::$BASEURI . $_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => BaseController::USER_AGENT,
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //json encode body
        $_bodyJson = Request\Body::Json($hosLogsParam);

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers, $_bodyJson);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //Error handling using HTTP status codes
        if (($response->code < 200) || ($response->code > 208)) {
            throw new APIException('Unexpected error.', $_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'SamsaraAPILib\\Models\\HosLogsSummaryResponse');
    }

    /**
     * Get the HOS (hours of service) logs for the specified driver. This method returns all the HOS
     * statuses that the driver was in during this time period.
     *
     * @param string              $accessToken  Samsara API access token.
     * @param Models\HosLogsParam $hosLogsParam TODO: type description here
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createGetFleetHosLogs(
        $accessToken,
        $hosLogsParam
    ) {

        //prepare query string for API call
        $_queryBuilder = '/fleet/hos_logs';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'access_token' => $accessToken,
            'access_token' => Configuration::$accessToken,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl(Configuration::$BASEURI . $_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => BaseController::USER_AGENT,
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //json encode body
        $_bodyJson = Request\Body::Json($hosLogsParam);

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers, $_bodyJson);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //Error handling using HTTP status codes
        if (($response->code < 200) || ($response->code > 208)) {
            throw new APIException('Unexpected error.', $_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'SamsaraAPILib\\Models\\HosLogsResponse');
    }

    /**
     * Get the HOS (hours of service) signin and signout logs for the specified driver. Only signout logs
     * include location information.
     *
     * @param string                            $accessToken                Samsara API access token.
     * @param Models\HosAuthenticationLogsParam $hosAuthenticationLogsParam TODO: type description here
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createGetFleetHosAuthenticationLogs(
        $accessToken,
        $hosAuthenticationLogsParam
    ) {

        //prepare query string for API call
        $_queryBuilder = '/fleet/hos_authentication_logs';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'access_token'               => $accessToken,
            'access_token' => Configuration::$accessToken,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl(Configuration::$BASEURI . $_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'               => BaseController::USER_AGENT,
            'Accept'                   => 'application/json',
            'content-type'             => 'application/json; charset=utf-8'
        );

        //json encode body
        $_bodyJson = Request\Body::Json($hosAuthenticationLogsParam);

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers, $_bodyJson);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //Error handling using HTTP status codes
        if (($response->code < 200) || ($response->code > 208)) {
            throw new APIException('Unexpected error.', $_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'SamsaraAPILib\\Models\\HosAuthenticationLogsResponse');
    }

    /**
     * Get the distance and time each driver in an organization has driven in a given time period.
     *
     * @param string                     $accessToken         Samsara API access token.
     * @param Models\DriversSummaryParam $driversSummaryParam Org ID and time range to query.
     * @param bool                       $snapToDayBounds     (optional) Snap query result to HOS day boundaries.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createGetFleetDriversSummary(
        $accessToken,
        $driversSummaryParam,
        $snapToDayBounds = null
    ) {

        //prepare query string for API call
        $_queryBuilder = '/fleet/drivers/summary';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'access_token'        => $accessToken,
            'snap_to_day_bounds'  => var_export($snapToDayBounds, true),
            'access_token' => Configuration::$accessToken,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl(Configuration::$BASEURI . $_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'        => BaseController::USER_AGENT,
            'Accept'            => 'application/json',
            'content-type'      => 'application/json; charset=utf-8'
        );

        //json encode body
        $_bodyJson = Request\Body::Json($driversSummaryParam);

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers, $_bodyJson);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //Error handling using HTTP status codes
        if (($response->code < 200) || ($response->code > 208)) {
            throw new APIException('Unexpected error.', $_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'SamsaraAPILib\\Models\\DriversSummaryResponse');
    }

    /**
     * Fetch engine state and aux input data for all vehicles in the group between a start/end time. Data
     * returned may be affected by device connectivity and processing time.
     *
     * @param string  $accessToken   Samsara API access token.
     * @param integer $startMs       Time in Unix epoch milliseconds for the start of the query.
     * @param integer $endMs         Time in Unix epoch milliseconds for the end of the query.
     * @param string  $series        (optional) Comma-separated list of stat types. Options are engineState, auxInput1,
     *                               and auxInput2. If this parameter is excluded, all 3 stat types will be returned.
     *                               Example: series=engineState,auxInput2
     * @param string  $tagIds        (optional) Comma-separated list of tag ids. Example: tagIds=1,2,3
     * @param string  $startingAfter (optional) Pagination parameter indicating the cursor position to continue
     *                               returning results after. Used in conjunction with the 'limit' parameter. Mutually
     *                               exclusive with 'endingBefore' parameter.
     * @param string  $endingBefore  (optional) Pagination parameter indicating the cursor position to return results
     *                               before. Used in conjunction with the 'limit' parameter. Mutually exclusive with
     *                               'startingAfter' parameter.
     * @param integer $limit         (optional) Pagination parameter indicating the number of results to return in this
     *                               request. Used in conjunction with either 'startingAfter' or 'endingBefore'.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getVehicleStats(
        $accessToken,
        $startMs,
        $endMs,
        $series = null,
        $tagIds = null,
        $startingAfter = null,
        $endingBefore = null,
        $limit = null
    ) {

        //prepare query string for API call
        $_queryBuilder = '/fleet/vehicles/stats';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'access_token'  => $accessToken,
            'startMs'       => $startMs,
            'endMs'         => $endMs,
            'series'        => $series,
            'tagIds'        => $tagIds,
            'startingAfter' => $startingAfter,
            'endingBefore'  => $endingBefore,
            'limit'         => $limit,
            'access_token' => Configuration::$accessToken,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl(Configuration::$BASEURI . $_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => BaseController::USER_AGENT,
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //Error handling using HTTP status codes
        if (($response->code < 200) || ($response->code > 208)) {
            throw new APIException('Unexpected error.', $_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'SamsaraAPILib\\Models\\GetVehicleStatsResponse');
    }

    /**
     * Reactivate the inactive driver having id.
     *
     * @param Models\ReactivateDriverParam $reactivateDriverParam    Driver reactivation body
     * @param string                       $accessToken              Samsara API access token.
     * @param string                       $driverIdOrExternalId     ID of the driver.  This must be either the numeric
     *                                                               ID generated by Samsara or the external ID of the
     *                                                               driver.  External IDs are customer specified key-
     *                                                               value pairs.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function updateReactivateDriverById(
        $reactivateDriverParam,
        $accessToken,
        $driverIdOrExternalId
    ) {

        //prepare query string for API call
        $_queryBuilder = '/fleet/drivers/inactive/{driver_id_or_external_id}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'driver_id_or_external_id' => $driverIdOrExternalId,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'access_token'             => $accessToken,
            'access_token' => Configuration::$accessToken,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl(Configuration::$BASEURI . $_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'             => BaseController::USER_AGENT,
            'Accept'                 => 'application/json',
            'content-type'           => 'application/json; charset=utf-8'
        );

        //json encode body
        $_bodyJson = Request\Body::Json($reactivateDriverParam);

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PUT, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::put($_queryUrl, $_headers, $_bodyJson);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //Error handling using HTTP status codes
        if (($response->code < 200) || ($response->code > 208)) {
            throw new APIException('Unexpected error.', $_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'SamsaraAPILib\\Models\\Driver');
    }

    /**
     * Fetch all of the documents.
     *
     * @param string  $accessToken  Samsara API access token.
     * @param integer $endMs        (optional) Time in unix milliseconds that represents the oldest documents to return.
     *                              Used in combination with durationMs. Defaults to now.
     * @param integer $durationMs   (optional) Time in milliseconds that represents the duration before endMs to query.
     *                              Defaults to 24 hours.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getDriverDocumentsByOrgId(
        $accessToken,
        $endMs = null,
        $durationMs = null
    ) {

        //prepare query string for API call
        $_queryBuilder = '/fleet/drivers/documents';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'access_token' => $accessToken,
            'endMs'        => $endMs,
            'durationMs'   => $durationMs,
            'access_token' => Configuration::$accessToken,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl(Configuration::$BASEURI . $_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => BaseController::USER_AGENT,
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //Error handling using HTTP status codes
        if (($response->code < 200) || ($response->code > 208)) {
            throw new APIException('Unexpected error.', $_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClassArray($response->body, 'SamsaraAPILib\\Models\\Document');
    }

    /**
     * Deactivate a driver with the given id.
     *
     * @param string $accessToken              Samsara API access token.
     * @param string $driverIdOrExternalId     ID of the driver.  This must be either the numeric ID generated by
     *                                         Samsara or the external ID of the driver.  External IDs are customer
     *                                         specified key-value pairs.
     * @return void response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function deleteDeactivateDriver(
        $accessToken,
        $driverIdOrExternalId
    ) {

        //prepare query string for API call
        $_queryBuilder = '/fleet/drivers/{driver_id_or_external_id}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'driver_id_or_external_id' => $driverIdOrExternalId,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'access_token'             => $accessToken,
            'access_token' => Configuration::$accessToken,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl(Configuration::$BASEURI . $_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'             => BaseController::USER_AGENT
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::DELETE, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::delete($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //Error handling using HTTP status codes
        if (($response->code < 200) || ($response->code > 208)) {
            throw new APIException('Unexpected error.', $_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);
    }

    /**
     * Fetch the history of a dispatch route.
     *
     * @param string  $accessToken  Samsara API access token.
     * @param integer $routeId      ID of the route with history.
     * @param integer $startTime    (optional) Timestamp representing the start of the period to fetch, inclusive. Used
     *                              in combination with end_time. Defaults to 0.
     * @param integer $endTime      (optional) Timestamp representing the end of the period to fetch, inclusive. Used
     *                              in combination with start_time. Defaults to nowMs.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getDispatchRouteHistory(
        $accessToken,
        $routeId,
        $startTime = null,
        $endTime = null
    ) {

        //prepare query string for API call
        $_queryBuilder = '/fleet/dispatch/routes/{route_id}/history';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'route_id'     => $routeId,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'access_token' => $accessToken,
            'start_time'   => $startTime,
            'end_time'     => $endTime,
            'access_token' => Configuration::$accessToken,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl(Configuration::$BASEURI . $_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => BaseController::USER_AGENT,
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //Error handling using HTTP status codes
        if (($response->code < 200) || ($response->code > 208)) {
            throw new APIException('Unexpected error.', $_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'SamsaraAPILib\\Models\\DispatchRouteHistory');
    }

    /**
     * Update a dispatch route and its associated jobs.
     *
     * @param Models\DispatchRoute $updateDispatchRouteParams TODO: type description here
     * @param string               $accessToken               Samsara API access token.
     * @param integer              $routeId                   ID of the dispatch route.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function updateDispatchRouteById(
        $updateDispatchRouteParams,
        $accessToken,
        $routeId
    ) {

        //prepare query string for API call
        $_queryBuilder = '/fleet/dispatch/routes/{route_id}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'route_id'                  => $routeId,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'access_token'              => $accessToken,
            'access_token' => Configuration::$accessToken,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl(Configuration::$BASEURI . $_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'              => BaseController::USER_AGENT,
            'Accept'                  => 'application/json',
            'content-type'            => 'application/json; charset=utf-8'
        );

        //json encode body
        $_bodyJson = Request\Body::Json($updateDispatchRouteParams);

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PUT, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::put($_queryUrl, $_headers, $_bodyJson);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //Error handling using HTTP status codes
        if (($response->code < 200) || ($response->code > 208)) {
            throw new APIException('Unexpected error.', $_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'SamsaraAPILib\\Models\\DispatchRoute');
    }

    /**
     * Fetch all updates to a job including route data in the last 24 hours or subsequent to an sequence
     * ID
     *
     * @param string  $accessToken  Samsara API access token.
     * @param integer $groupId      (optional) Optional group ID if the organization has multiple groups (uncommon).
     * @param string  $sequenceId   (optional) Sequence ID from the response payload of the last request. Defaults to
     *                              fetching updates from last 24 hours.
     * @param string  $minclude     (optional) Optionally set include=route to include route object in response payload.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function fetchAllRouteJobUpdates(
        $accessToken,
        $groupId = null,
        $sequenceId = null,
        $minclude = null
    ) {

        //prepare query string for API call
        $_queryBuilder = '/fleet/dispatch/routes/job_updates';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'access_token' => $accessToken,
            'group_id'     => $groupId,
            'sequence_id'  => $sequenceId,
            'include'      => $minclude,
            'access_token' => Configuration::$accessToken,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl(Configuration::$BASEURI . $_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => BaseController::USER_AGENT,
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //Error handling using HTTP status codes
        if (($response->code < 200) || ($response->code > 208)) {
            throw new APIException('Unexpected error.', $_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'SamsaraAPILib\\Models\\AllRouteJobUpdates');
    }

    /**
     * Fetch all of the dispatch routes for the group.
     *
     * @param string  $accessToken  Samsara API access token.
     * @param integer $groupId      (optional) Optional group ID if the organization has multiple groups (uncommon).
     * @param integer $endTime      (optional) Time in unix milliseconds that represents the oldest routes to return.
     *                              Used in combination with duration. Defaults to now.
     * @param integer $duration     (optional) Time in milliseconds that represents the duration before end_time to
     *                              query. Defaults to 24 hours.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function fetchAllDispatchRoutes(
        $accessToken,
        $groupId = null,
        $endTime = null,
        $duration = null
    ) {

        //prepare query string for API call
        $_queryBuilder = '/fleet/dispatch/routes';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'access_token' => $accessToken,
            'group_id'     => $groupId,
            'end_time'     => $endTime,
            'duration'     => $duration,
            'access_token' => Configuration::$accessToken,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl(Configuration::$BASEURI . $_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => BaseController::USER_AGENT,
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //Error handling using HTTP status codes
        if (($response->code < 200) || ($response->code > 208)) {
            throw new APIException('Unexpected error.', $_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClassArray($response->body, 'SamsaraAPILib\\Models\\DispatchRoute');
    }

    /**
     * Fetch the reefer-specific stats of an asset.
     *
     * @param string  $accessToken  Samsara API access token.
     * @param integer $assetId      ID of the asset
     * @param integer $startMs      Timestamp in milliseconds representing the start of the period to fetch, inclusive.
     *                              Used in combination with endMs.
     * @param integer $endMs        Timestamp in milliseconds representing the end of the period to fetch, inclusive.
     *                              Used in combination with startMs.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getAssetReefer(
        $accessToken,
        $assetId,
        $startMs,
        $endMs
    ) {

        //prepare query string for API call
        $_queryBuilder = '/fleet/assets/{asset_id}/reefer';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'asset_id'     => $assetId,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'access_token' => $accessToken,
            'startMs'      => $startMs,
            'endMs'        => $endMs,
            'access_token' => Configuration::$accessToken,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl(Configuration::$BASEURI . $_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => BaseController::USER_AGENT,
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //Error handling using HTTP status codes
        if (($response->code < 200) || ($response->code > 208)) {
            throw new APIException('Unexpected error.', $_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'SamsaraAPILib\\Models\\AssetReeferResponse');
    }

    /**
     * Fetch the historical locations for the asset.
     *
     * @param string  $accessToken  Samsara API access token.
     * @param integer $assetId      ID of the asset
     * @param integer $startMs      Timestamp in milliseconds representing the start of the period to fetch, inclusive.
     *                              Used in combination with endMs.
     * @param integer $endMs        Timestamp in milliseconds representing the end of the period to fetch, inclusive.
     *                              Used in combination with startMs.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getAssetLocation(
        $accessToken,
        $assetId,
        $startMs,
        $endMs
    ) {

        //prepare query string for API call
        $_queryBuilder = '/fleet/assets/{asset_id}/locations';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'asset_id'     => $assetId,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'access_token' => $accessToken,
            'startMs'      => $startMs,
            'endMs'        => $endMs,
            'access_token' => Configuration::$accessToken,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl(Configuration::$BASEURI . $_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => BaseController::USER_AGENT,
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //Error handling using HTTP status codes
        if (($response->code < 200) || ($response->code > 208)) {
            throw new APIException('Unexpected error.', $_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClassArray($response->body, 'SamsaraAPILib\\Models\\AssetLocationResponse');
    }

    /**
     * Fetch driver by id.
     *
     * @param string $accessToken              Samsara API access token.
     * @param string $driverIdOrExternalId     ID of the driver.  This must be either the numeric ID generated by
     *                                         Samsara or the external ID of the driver.  External IDs are customer
     *                                         specified key-value pairs.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getDriverById(
        $accessToken,
        $driverIdOrExternalId
    ) {

        //prepare query string for API call
        $_queryBuilder = '/fleet/drivers/{driver_id_or_external_id}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'driver_id_or_external_id' => $driverIdOrExternalId,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'access_token'             => $accessToken,
            'access_token' => Configuration::$accessToken,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl(Configuration::$BASEURI . $_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'             => BaseController::USER_AGENT,
            'Accept'                 => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //Error handling using HTTP status codes
        if (($response->code < 200) || ($response->code > 208)) {
            throw new APIException('Unexpected error.', $_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'SamsaraAPILib\\Models\\Driver');
    }

    /**
     * Fetch deactivated driver by id.
     *
     * @param string $accessToken              Samsara API access token.
     * @param string $driverIdOrExternalId     ID of the driver.  This must be either the numeric ID generated by
     *                                         Samsara or the external ID of the driver.  External IDs are customer
     *                                         specified key-value pairs.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getDeactivatedDriverById(
        $accessToken,
        $driverIdOrExternalId
    ) {

        //prepare query string for API call
        $_queryBuilder = '/fleet/drivers/inactive/{driver_id_or_external_id}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'driver_id_or_external_id' => $driverIdOrExternalId,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'access_token'             => $accessToken,
            'access_token' => Configuration::$accessToken,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl(Configuration::$BASEURI . $_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'             => BaseController::USER_AGENT,
            'Accept'                 => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //Error handling using HTTP status codes
        if (($response->code < 200) || ($response->code > 208)) {
            throw new APIException('Unexpected error.', $_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'SamsaraAPILib\\Models\\Driver');
    }

    /**
     * Fetch all deactivated drivers for the group.
     *
     * @param string  $accessToken  Samsara API access token.
     * @param integer $groupId      (optional) Optional group ID if the organization has multiple groups (uncommon).
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getAllDeactivatedDrivers(
        $accessToken,
        $groupId = null
    ) {

        //prepare query string for API call
        $_queryBuilder = '/fleet/drivers/inactive';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'access_token' => $accessToken,
            'group_id'     => $groupId,
            'access_token' => Configuration::$accessToken,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl(Configuration::$BASEURI . $_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => BaseController::USER_AGENT,
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //Error handling using HTTP status codes
        if (($response->code < 200) || ($response->code > 208)) {
            throw new APIException('Unexpected error.', $_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClassArray($response->body, 'SamsaraAPILib\\Models\\Driver');
    }

    /**
     * Create a new driver.
     *
     * @param string                 $accessToken       Samsara API access token.
     * @param Models\DriverForCreate $createDriverParam Driver creation body
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createDriver(
        $accessToken,
        $createDriverParam
    ) {

        //prepare query string for API call
        $_queryBuilder = '/fleet/drivers/create';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'access_token'      => $accessToken,
            'access_token' => Configuration::$accessToken,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl(Configuration::$BASEURI . $_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'      => BaseController::USER_AGENT,
            'Accept'          => 'application/json',
            'content-type'    => 'application/json; charset=utf-8'
        );

        //json encode body
        $_bodyJson = Request\Body::Json($createDriverParam);

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers, $_bodyJson);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //Error handling using HTTP status codes
        if (($response->code < 200) || ($response->code > 208)) {
            throw new APIException('Unexpected error.', $_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'SamsaraAPILib\\Models\\Driver');
    }

    /**
     * Get all the drivers for the specified group.
     *
     * @param string                   $accessToken       Samsara API access token.
     * @param Models\GroupDriversParam $groupDriversParam TODO: type description here
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createGetFleetDrivers(
        $accessToken,
        $groupDriversParam
    ) {

        //prepare query string for API call
        $_queryBuilder = '/fleet/drivers';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'access_token'      => $accessToken,
            'access_token' => Configuration::$accessToken,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl(Configuration::$BASEURI . $_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'      => BaseController::USER_AGENT,
            'Accept'          => 'application/json',
            'content-type'    => 'application/json; charset=utf-8'
        );

        //json encode body
        $_bodyJson = Request\Body::Json($groupDriversParam);

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers, $_bodyJson);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //Error handling using HTTP status codes
        if (($response->code < 200) || ($response->code > 208)) {
            throw new APIException('Unexpected error.', $_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'SamsaraAPILib\\Models\\DriversResponse');
    }

    /**
     * Delete a dispatch route and its associated jobs.
     *
     * @param string  $accessToken  Samsara API access token.
     * @param integer $routeId      ID of the dispatch route.
     * @return void response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function deleteDispatchRouteById(
        $accessToken,
        $routeId
    ) {

        //prepare query string for API call
        $_queryBuilder = '/fleet/dispatch/routes/{route_id}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'route_id'     => $routeId,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'access_token' => $accessToken,
            'access_token' => Configuration::$accessToken,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl(Configuration::$BASEURI . $_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => BaseController::USER_AGENT
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::DELETE, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::delete($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //Error handling using HTTP status codes
        if (($response->code < 200) || ($response->code > 208)) {
            throw new APIException('Unexpected error.', $_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);
    }

    /**
     * Fetch a dispatch route by id.
     *
     * @param string  $accessToken  Samsara API access token.
     * @param integer $routeId      ID of the dispatch route.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getDispatchRouteById(
        $accessToken,
        $routeId
    ) {

        //prepare query string for API call
        $_queryBuilder = '/fleet/dispatch/routes/{route_id}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'route_id'     => $routeId,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'access_token' => $accessToken,
            'access_token' => Configuration::$accessToken,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl(Configuration::$BASEURI . $_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => BaseController::USER_AGENT,
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //Error handling using HTTP status codes
        if (($response->code < 200) || ($response->code > 208)) {
            throw new APIException('Unexpected error.', $_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'SamsaraAPILib\\Models\\DispatchRoute');
    }

    /**
     * Create a new dispatch route.
     *
     * @param string                     $accessToken               Samsara API access token.
     * @param Models\DispatchRouteCreate $createDispatchRouteParams TODO: type description here
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createDispatchRoute(
        $accessToken,
        $createDispatchRouteParams
    ) {

        //prepare query string for API call
        $_queryBuilder = '/fleet/dispatch/routes';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'access_token'              => $accessToken,
            'access_token' => Configuration::$accessToken,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl(Configuration::$BASEURI . $_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'              => BaseController::USER_AGENT,
            'Accept'                  => 'application/json',
            'content-type'            => 'application/json; charset=utf-8'
        );

        //json encode body
        $_bodyJson = Request\Body::Json($createDispatchRouteParams);

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers, $_bodyJson);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //Error handling using HTTP status codes
        if (($response->code < 200) || ($response->code > 208)) {
            throw new APIException('Unexpected error.', $_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'SamsaraAPILib\\Models\\DispatchRoute');
    }

    /**
     * Fetch current locations of all assets for the group.
     *
     * @param string $accessToken  Samsara API access token.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getAllAssetCurrentLocations(
        $accessToken
    ) {

        //prepare query string for API call
        $_queryBuilder = '/fleet/assets/locations';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'access_token' => $accessToken,
            'access_token' => Configuration::$accessToken,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl(Configuration::$BASEURI . $_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => BaseController::USER_AGENT,
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //Error handling using HTTP status codes
        if (($response->code < 200) || ($response->code > 208)) {
            throw new APIException('Unexpected error.', $_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'SamsaraAPILib\\Models\\GetAllAssetCurrentLocationsResponse');
    }

    /**
     * Fetch all of the assets for the group.
     *
     * @param string $accessToken  Samsara API access token.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getAllAssets(
        $accessToken
    ) {

        //prepare query string for API call
        $_queryBuilder = '/fleet/assets';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'access_token' => $accessToken,
            'access_token' => Configuration::$accessToken,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl(Configuration::$BASEURI . $_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => BaseController::USER_AGENT,
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //Error handling using HTTP status codes
        if (($response->code < 200) || ($response->code > 208)) {
            throw new APIException('Unexpected error.', $_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'SamsaraAPILib\\Models\\GetAllAssetsResponse');
    }

    /**
     * This method adds an address book entry to the specified group.
     *
     * @param string              $accessToken  Samsara API access token.
     * @param Models\AddressParam $addressParam TODO: type description here
     * @return void response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function addFleetAddress(
        $accessToken,
        $addressParam
    ) {

        //prepare query string for API call
        $_queryBuilder = '/fleet/add_address';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'access_token' => $accessToken,
            'access_token' => Configuration::$accessToken,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl(Configuration::$BASEURI . $_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => BaseController::USER_AGENT,
            'content-type'  => 'application/json; charset=utf-8'
        );

        //json encode body
        $_bodyJson = Request\Body::Json($addressParam);

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers, $_bodyJson);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //Error handling using HTTP status codes
        if (($response->code < 200) || ($response->code > 208)) {
            throw new APIException('Unexpected error.', $_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);
    }

    /**
     * Fetch a contact by its id.
     *
     * @param string  $accessToken  Samsara API access token.
     * @param integer $contactId    ID of the contact
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getOrganizationContact(
        $accessToken,
        $contactId
    ) {

        //prepare query string for API call
        $_queryBuilder = '/contacts/{contact_id}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'contact_id'   => $contactId,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'access_token' => $accessToken,
            'access_token' => Configuration::$accessToken,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl(Configuration::$BASEURI . $_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => BaseController::USER_AGENT,
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //Error handling using HTTP status codes
        if (($response->code < 200) || ($response->code > 208)) {
            throw new APIException('Unexpected error.', $_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'SamsaraAPILib\\Models\\Contact');
    }

    /**
     * Fetch all contacts for the organization.
     *
     * @param string $accessToken  Samsara API access token.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function listContacts(
        $accessToken
    ) {

        //prepare query string for API call
        $_queryBuilder = '/contacts';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'access_token' => $accessToken,
            'access_token' => Configuration::$accessToken,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl(Configuration::$BASEURI . $_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => BaseController::USER_AGENT,
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //Error handling using HTTP status codes
        if (($response->code < 200) || ($response->code > 208)) {
            throw new APIException('Unexpected error.', $_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClassArray($response->body, 'SamsaraAPILib\\Models\\Contact');
    }

    /**
     * Delete an address.
     *
     * @param string  $accessToken  Samsara API access token.
     * @param integer $addressId    ID of the address/geofence
     * @return void response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function deleteOrganizationAddress(
        $accessToken,
        $addressId
    ) {

        //prepare query string for API call
        $_queryBuilder = '/addresses/{addressId}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'addressId'    => $addressId,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'access_token' => $accessToken,
            'access_token' => Configuration::$accessToken,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl(Configuration::$BASEURI . $_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => BaseController::USER_AGENT
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::DELETE, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::delete($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //Error handling using HTTP status codes
        if (($response->code < 200) || ($response->code > 208)) {
            throw new APIException('Unexpected error.', $_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);
    }

    /**
     * Fetch an address by its id.
     *
     * @param string  $accessToken  Samsara API access token.
     * @param integer $addressId    ID of the address/geofence
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getOrganizationAddress(
        $accessToken,
        $addressId
    ) {

        //prepare query string for API call
        $_queryBuilder = '/addresses/{addressId}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'addressId'    => $addressId,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'access_token' => $accessToken,
            'access_token' => Configuration::$accessToken,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl(Configuration::$BASEURI . $_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => BaseController::USER_AGENT,
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //Error handling using HTTP status codes
        if (($response->code < 200) || ($response->code > 208)) {
            throw new APIException('Unexpected error.', $_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'SamsaraAPILib\\Models\\Address');
    }

    /**
     * Update the name, formatted address, geofence, notes, or tag and contact Ids for an address. The set
     * of tags or contacts associated with this address will be updated to exactly match the list of IDs
     * passed in. To remove all tags or contacts from an address, pass an empty list; to remove notes, pass
     * an empty string.
     *
     * @param string          $accessToken  Samsara API access token.
     * @param Models\Address1 $address      Update parts of an address's value. If the geofence 'circle' or 'polygon'
     *                                      key is specified, the update will change the type of geofence accordingly.
     * @param integer         $addressId    ID of the address/geofence
     * @return void response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function updateOrganizationAddress(
        $accessToken,
        $address,
        $addressId
    ) {

        //prepare query string for API call
        $_queryBuilder = '/addresses/{addressId}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'addressId'    => $addressId,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'access_token' => $accessToken,
            'access_token' => Configuration::$accessToken,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl(Configuration::$BASEURI . $_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => BaseController::USER_AGENT,
            'content-type'  => 'application/json; charset=utf-8'
        );

        //json encode body
        $_bodyJson = Request\Body::Json($address);

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PATCH, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::patch($_queryUrl, $_headers, $_bodyJson);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //Error handling using HTTP status codes
        if (($response->code < 200) || ($response->code > 208)) {
            throw new APIException('Unexpected error.', $_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);
    }

    /**
     * Fetch all addresses/geofences for the organization. An address contains either a circle or polygon
     * geofence describing the address boundaries.
     *
     * @param string $accessToken  Samsara API access token.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getOrganizationAddresses(
        $accessToken
    ) {

        //prepare query string for API call
        $_queryBuilder = '/addresses';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'access_token' => $accessToken,
            'access_token' => Configuration::$accessToken,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl(Configuration::$BASEURI . $_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => BaseController::USER_AGENT,
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //Error handling using HTTP status codes
        if (($response->code < 200) || ($response->code > 208)) {
            throw new APIException('Unexpected error.', $_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClassArray($response->body, 'SamsaraAPILib\\Models\\Address');
    }

    /**
     * Add one or more addresses to the organization
     *
     * @param string           $accessToken  Samsara API access token.
     * @param Models\Addresses $addresses    List of addresses/geofences to add. Geofences can be circular or a polygon.
     *                                       For each address, only one of 'circle' or 'polygon' should be provided.
     *                                       If both are provided, the geofence will be saved as a polygon.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function addOrganizationAddresses(
        $accessToken,
        $addresses
    ) {

        //prepare query string for API call
        $_queryBuilder = '/addresses';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'access_token' => $accessToken,
            'access_token' => Configuration::$accessToken,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl(Configuration::$BASEURI . $_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => BaseController::USER_AGENT,
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //json encode body
        $_bodyJson = Request\Body::Json($addresses);

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers, $_bodyJson);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //Error handling using HTTP status codes
        if (($response->code < 200) || ($response->code > 208)) {
            throw new APIException('Unexpected error.', $_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClassArray($response->body, 'SamsaraAPILib\\Models\\Address');
    }
}
