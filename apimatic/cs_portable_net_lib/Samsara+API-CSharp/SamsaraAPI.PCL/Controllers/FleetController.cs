/*
 * SamsaraAPI.PCL
 *
 * This file was automatically generated by APIMATIC v2.0 ( https://apimatic.io ).
 */
using System;
using System.Collections.Generic;
using System.Dynamic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Newtonsoft.Json.Converters;
using SamsaraAPI.PCL;
using SamsaraAPI.PCL.Utilities;
using SamsaraAPI.PCL.Http.Request;
using SamsaraAPI.PCL.Http.Response;
using SamsaraAPI.PCL.Http.Client;
using SamsaraAPI.PCL.Exceptions;

namespace SamsaraAPI.PCL.Controllers
{
    public partial class FleetController: BaseController
    {
        #region Singleton Pattern

        //private static variables for the singleton pattern
        private static object syncObject = new object();
        private static FleetController instance = null;

        /// <summary>
        /// Singleton pattern implementation
        /// </summary>
        internal static FleetController Instance
        {
            get
            {
                lock (syncObject)
                {
                    if (null == instance)
                    {
                        instance = new FleetController();
                    }
                }
                return instance;
            }
        }

        #endregion Singleton Pattern

        /// <summary>
        /// Fetch all of the document types.
        /// </summary>
        /// <return>Returns the List<Models.DocumentType> response from the API call</return>
        public List<Models.DocumentType> GetDriverDocumentTypesByOrgId()
        {
            Task<List<Models.DocumentType>> t = GetDriverDocumentTypesByOrgIdAsync();
            APIHelper.RunTaskSynchronously(t);
            return t.Result;
        }

        /// <summary>
        /// Fetch all of the document types.
        /// </summary>
        /// <return>Returns the List<Models.DocumentType> response from the API call</return>
        public async Task<List<Models.DocumentType>> GetDriverDocumentTypesByOrgIdAsync()
        {
            //the base uri for api requests
            string _baseUri = Configuration.BaseUri;

            //prepare query string for API call
            StringBuilder _queryBuilder = new StringBuilder(_baseUri);
            _queryBuilder.Append("/fleet/drivers/document_types");

            //process optional query parameters
            APIHelper.AppendUrlWithQueryParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "access_token", Configuration.AccessToken }
            },ArrayDeserializationFormat,ParameterSeparator);


            //validate and preprocess url
            string _queryUrl = APIHelper.CleanUrl(_queryBuilder);

            //append request with appropriate headers and parameters
            var _headers = new Dictionary<string,string>()
            {
                { "user-agent", "APIMATIC 2.0" },
                { "accept", "application/json" }
            };

            //prepare the API call request to fetch the response
            HttpRequest _request = ClientInstance.Get(_queryUrl,_headers);

            //invoke request and get response
            HttpStringResponse _response = (HttpStringResponse) await ClientInstance.ExecuteAsStringAsync(_request).ConfigureAwait(false);
            HttpContext _context = new HttpContext(_request,_response);

            //Error handling using HTTP status codes
            if ((_response.StatusCode < 200) || (_response.StatusCode > 208)) //[200,208] = HTTP OK
                throw new APIException(@"Unexpected error.", _context);

            //handle errors defined at the API level
            base.ValidateResponse(_response, _context);

            try
            {
                return APIHelper.JsonDeserialize<List<Models.DocumentType>>(_response.Body);
            }
            catch (Exception _ex)
            {
                throw new APIException("Failed to parse the response: " + _ex.Message, _context);
            }
        }

        /// <summary>
        /// Fetch locations for a given vehicle between a start/end time. The maximum query duration is one hour.
        /// </summary>
        /// <param name="accessToken">Required parameter: Samsara API access token.</param>
        /// <param name="vehicleId">Required parameter: ID of the vehicle with the associated routes.</param>
        /// <param name="startMs">Required parameter: Time in Unix epoch milliseconds for the start of the query (cannot exceed 1 hour)</param>
        /// <param name="endMs">Required parameter: Time in Unix epoch milliseconds for the end of the query (cannot exceed 1 hour)</param>
        /// <return>Returns the List<Models.FleetVehicleLocation> response from the API call</return>
        public List<Models.FleetVehicleLocation> GetVehicleLocations(
                string accessToken,
                long vehicleId,
                long startMs,
                long endMs)
        {
            Task<List<Models.FleetVehicleLocation>> t = GetVehicleLocationsAsync(accessToken, vehicleId, startMs, endMs);
            APIHelper.RunTaskSynchronously(t);
            return t.Result;
        }

        /// <summary>
        /// Fetch locations for a given vehicle between a start/end time. The maximum query duration is one hour.
        /// </summary>
        /// <param name="accessToken">Required parameter: Samsara API access token.</param>
        /// <param name="vehicleId">Required parameter: ID of the vehicle with the associated routes.</param>
        /// <param name="startMs">Required parameter: Time in Unix epoch milliseconds for the start of the query (cannot exceed 1 hour)</param>
        /// <param name="endMs">Required parameter: Time in Unix epoch milliseconds for the end of the query (cannot exceed 1 hour)</param>
        /// <return>Returns the List<Models.FleetVehicleLocation> response from the API call</return>
        public async Task<List<Models.FleetVehicleLocation>> GetVehicleLocationsAsync(
                string accessToken,
                long vehicleId,
                long startMs,
                long endMs)
        {
            //the base uri for api requests
            string _baseUri = Configuration.BaseUri;

            //prepare query string for API call
            StringBuilder _queryBuilder = new StringBuilder(_baseUri);
            _queryBuilder.Append("/fleet/vehicles/{vehicle_id}/locations");

            //process optional template parameters
            APIHelper.AppendUrlWithTemplateParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "vehicle_id", vehicleId }
            });

            //process optional query parameters
            APIHelper.AppendUrlWithQueryParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "access_token", accessToken },
                { "startMs", startMs },
                { "endMs", endMs },
                { "access_token", Configuration.AccessToken }
            },ArrayDeserializationFormat,ParameterSeparator);


            //validate and preprocess url
            string _queryUrl = APIHelper.CleanUrl(_queryBuilder);

            //append request with appropriate headers and parameters
            var _headers = new Dictionary<string,string>()
            {
                { "user-agent", "APIMATIC 2.0" },
                { "accept", "application/json" }
            };

            //prepare the API call request to fetch the response
            HttpRequest _request = ClientInstance.Get(_queryUrl,_headers);

            //invoke request and get response
            HttpStringResponse _response = (HttpStringResponse) await ClientInstance.ExecuteAsStringAsync(_request).ConfigureAwait(false);
            HttpContext _context = new HttpContext(_request,_response);

            //Error handling using HTTP status codes
            if ((_response.StatusCode < 200) || (_response.StatusCode > 208)) //[200,208] = HTTP OK
                throw new APIException(@"Unexpected error.", _context);

            //handle errors defined at the API level
            base.ValidateResponse(_response, _context);

            try
            {
                return APIHelper.JsonDeserialize<List<Models.FleetVehicleLocation>>(_response.Body);
            }
            catch (Exception _ex)
            {
                throw new APIException("Failed to parse the response: " + _ex.Message, _context);
            }
        }

        /// <summary>
        /// Create a new dispatch route for the vehicle with vehicle_id.
        /// </summary>
        /// <param name="createDispatchRouteParams">Required parameter: Example: </param>
        /// <param name="accessToken">Required parameter: Samsara API access token.</param>
        /// <param name="vehicleId">Required parameter: ID of the vehicle with the associated routes.</param>
        /// <return>Returns the Models.DispatchRoute response from the API call</return>
        public Models.DispatchRoute CreateVehicleDispatchRoute(Models.DispatchRouteCreate createDispatchRouteParams, string accessToken, long vehicleId)
        {
            Task<Models.DispatchRoute> t = CreateVehicleDispatchRouteAsync(createDispatchRouteParams, accessToken, vehicleId);
            APIHelper.RunTaskSynchronously(t);
            return t.Result;
        }

        /// <summary>
        /// Create a new dispatch route for the vehicle with vehicle_id.
        /// </summary>
        /// <param name="createDispatchRouteParams">Required parameter: Example: </param>
        /// <param name="accessToken">Required parameter: Samsara API access token.</param>
        /// <param name="vehicleId">Required parameter: ID of the vehicle with the associated routes.</param>
        /// <return>Returns the Models.DispatchRoute response from the API call</return>
        public async Task<Models.DispatchRoute> CreateVehicleDispatchRouteAsync(Models.DispatchRouteCreate createDispatchRouteParams, string accessToken, long vehicleId)
        {
            //the base uri for api requests
            string _baseUri = Configuration.BaseUri;

            //prepare query string for API call
            StringBuilder _queryBuilder = new StringBuilder(_baseUri);
            _queryBuilder.Append("/fleet/vehicles/{vehicle_id}/dispatch/routes");

            //process optional template parameters
            APIHelper.AppendUrlWithTemplateParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "vehicle_id", vehicleId }
            });

            //process optional query parameters
            APIHelper.AppendUrlWithQueryParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "access_token", accessToken },
                { "access_token", Configuration.AccessToken }
            },ArrayDeserializationFormat,ParameterSeparator);


            //validate and preprocess url
            string _queryUrl = APIHelper.CleanUrl(_queryBuilder);

            //append request with appropriate headers and parameters
            var _headers = new Dictionary<string,string>()
            {
                { "user-agent", "APIMATIC 2.0" },
                { "accept", "application/json" },
                { "content-type", "application/json; charset=utf-8" }
            };

            //append body params
            var _body = APIHelper.JsonSerialize(createDispatchRouteParams);

            //prepare the API call request to fetch the response
            HttpRequest _request = ClientInstance.PostBody(_queryUrl, _headers, _body);

            //invoke request and get response
            HttpStringResponse _response = (HttpStringResponse) await ClientInstance.ExecuteAsStringAsync(_request).ConfigureAwait(false);
            HttpContext _context = new HttpContext(_request,_response);

            //Error handling using HTTP status codes
            if ((_response.StatusCode < 200) || (_response.StatusCode > 208)) //[200,208] = HTTP OK
                throw new APIException(@"Unexpected error.", _context);

            //handle errors defined at the API level
            base.ValidateResponse(_response, _context);

            try
            {
                return APIHelper.JsonDeserialize<Models.DispatchRoute>(_response.Body);
            }
            catch (Exception _ex)
            {
                throw new APIException("Failed to parse the response: " + _ex.Message, _context);
            }
        }

        /// <summary>
        /// Fetch all of the dispatch routes for a given vehicle.
        /// </summary>
        /// <param name="accessToken">Required parameter: Samsara API access token.</param>
        /// <param name="vehicleId">Required parameter: ID of the vehicle with the associated routes.</param>
        /// <param name="endTime">Optional parameter: Time in unix milliseconds that represents the oldest routes to return. Used in combination with duration. Defaults to now.</param>
        /// <param name="duration">Optional parameter: Time in milliseconds that represents the duration before end_time to query. Defaults to 24 hours.</param>
        /// <return>Returns the List<Models.DispatchRoute> response from the API call</return>
        public List<Models.DispatchRoute> GetDispatchRoutesByVehicleId(
                string accessToken,
                long vehicleId,
                long? endTime = null,
                long? duration = null)
        {
            Task<List<Models.DispatchRoute>> t = GetDispatchRoutesByVehicleIdAsync(accessToken, vehicleId, endTime, duration);
            APIHelper.RunTaskSynchronously(t);
            return t.Result;
        }

        /// <summary>
        /// Fetch all of the dispatch routes for a given vehicle.
        /// </summary>
        /// <param name="accessToken">Required parameter: Samsara API access token.</param>
        /// <param name="vehicleId">Required parameter: ID of the vehicle with the associated routes.</param>
        /// <param name="endTime">Optional parameter: Time in unix milliseconds that represents the oldest routes to return. Used in combination with duration. Defaults to now.</param>
        /// <param name="duration">Optional parameter: Time in milliseconds that represents the duration before end_time to query. Defaults to 24 hours.</param>
        /// <return>Returns the List<Models.DispatchRoute> response from the API call</return>
        public async Task<List<Models.DispatchRoute>> GetDispatchRoutesByVehicleIdAsync(
                string accessToken,
                long vehicleId,
                long? endTime = null,
                long? duration = null)
        {
            //the base uri for api requests
            string _baseUri = Configuration.BaseUri;

            //prepare query string for API call
            StringBuilder _queryBuilder = new StringBuilder(_baseUri);
            _queryBuilder.Append("/fleet/vehicles/{vehicle_id}/dispatch/routes");

            //process optional template parameters
            APIHelper.AppendUrlWithTemplateParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "vehicle_id", vehicleId }
            });

            //process optional query parameters
            APIHelper.AppendUrlWithQueryParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "access_token", accessToken },
                { "end_time", endTime },
                { "duration", duration },
                { "access_token", Configuration.AccessToken }
            },ArrayDeserializationFormat,ParameterSeparator);


            //validate and preprocess url
            string _queryUrl = APIHelper.CleanUrl(_queryBuilder);

            //append request with appropriate headers and parameters
            var _headers = new Dictionary<string,string>()
            {
                { "user-agent", "APIMATIC 2.0" },
                { "accept", "application/json" }
            };

            //prepare the API call request to fetch the response
            HttpRequest _request = ClientInstance.Get(_queryUrl,_headers);

            //invoke request and get response
            HttpStringResponse _response = (HttpStringResponse) await ClientInstance.ExecuteAsStringAsync(_request).ConfigureAwait(false);
            HttpContext _context = new HttpContext(_request,_response);

            //Error handling using HTTP status codes
            if ((_response.StatusCode < 200) || (_response.StatusCode > 208)) //[200,208] = HTTP OK
                throw new APIException(@"Unexpected error.", _context);

            //handle errors defined at the API level
            base.ValidateResponse(_response, _context);

            try
            {
                return APIHelper.JsonDeserialize<List<Models.DispatchRoute>>(_response.Body);
            }
            catch (Exception _ex)
            {
                throw new APIException("Failed to parse the response: " + _ex.Message, _context);
            }
        }

        /// <summary>
        /// Updates the specified vehicle using JSON merge patch format. See IETF RFC 7396: https://tools.ietf.org/html/rfc7396.
        /// </summary>
        /// <param name="accessToken">Required parameter: Samsara API access token.</param>
        /// <param name="vehicleIdOrExternalId">Required parameter: ID of the vehicle.  This must be either the numeric ID generated by Samsara or the external ID of the vehicle.  External IDs are customer specified key-value pairs.</param>
        /// <param name="data">Required parameter: Example: </param>
        /// <return>Returns the Models.FleetVehicleResponse response from the API call</return>
        public Models.FleetVehicleResponse PatchFleetVehicle(string accessToken, string vehicleIdOrExternalId, Models.Data data)
        {
            Task<Models.FleetVehicleResponse> t = PatchFleetVehicleAsync(accessToken, vehicleIdOrExternalId, data);
            APIHelper.RunTaskSynchronously(t);
            return t.Result;
        }

        /// <summary>
        /// Updates the specified vehicle using JSON merge patch format. See IETF RFC 7396: https://tools.ietf.org/html/rfc7396.
        /// </summary>
        /// <param name="accessToken">Required parameter: Samsara API access token.</param>
        /// <param name="vehicleIdOrExternalId">Required parameter: ID of the vehicle.  This must be either the numeric ID generated by Samsara or the external ID of the vehicle.  External IDs are customer specified key-value pairs.</param>
        /// <param name="data">Required parameter: Example: </param>
        /// <return>Returns the Models.FleetVehicleResponse response from the API call</return>
        public async Task<Models.FleetVehicleResponse> PatchFleetVehicleAsync(string accessToken, string vehicleIdOrExternalId, Models.Data data)
        {
            //the base uri for api requests
            string _baseUri = Configuration.BaseUri;

            //prepare query string for API call
            StringBuilder _queryBuilder = new StringBuilder(_baseUri);
            _queryBuilder.Append("/fleet/vehicles/{vehicle_id_or_external_id}");

            //process optional template parameters
            APIHelper.AppendUrlWithTemplateParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "vehicle_id_or_external_id", vehicleIdOrExternalId }
            });

            //process optional query parameters
            APIHelper.AppendUrlWithQueryParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "access_token", accessToken },
                { "access_token", Configuration.AccessToken }
            },ArrayDeserializationFormat,ParameterSeparator);


            //validate and preprocess url
            string _queryUrl = APIHelper.CleanUrl(_queryBuilder);

            //append request with appropriate headers and parameters
            var _headers = new Dictionary<string,string>()
            {
                { "user-agent", "APIMATIC 2.0" },
                { "accept", "application/json" },
                { "content-type", "application/json; charset=utf-8" }
            };

            //append body params
            var _body = APIHelper.JsonSerialize(data);

            //prepare the API call request to fetch the response
            HttpRequest _request = ClientInstance.PatchBody(_queryUrl, _headers, _body);

            //invoke request and get response
            HttpStringResponse _response = (HttpStringResponse) await ClientInstance.ExecuteAsStringAsync(_request).ConfigureAwait(false);
            HttpContext _context = new HttpContext(_request,_response);

            //Error handling using HTTP status codes
            if ((_response.StatusCode < 200) || (_response.StatusCode > 208)) //[200,208] = HTTP OK
                throw new APIException(@"Unexpected error.", _context);

            //handle errors defined at the API level
            base.ValidateResponse(_response, _context);

            try
            {
                return APIHelper.JsonDeserialize<Models.FleetVehicleResponse>(_response.Body);
            }
            catch (Exception _ex)
            {
                throw new APIException("Failed to parse the response: " + _ex.Message, _context);
            }
        }

        /// <summary>
        /// Fetch the safety score for the vehicle.
        /// </summary>
        /// <param name="accessToken">Required parameter: Samsara API access token.</param>
        /// <param name="startMs">Required parameter: Timestamp in milliseconds representing the start of the period to fetch, inclusive. Used in combination with endMs.</param>
        /// <param name="endMs">Required parameter: Timestamp in milliseconds representing the end of the period to fetch, inclusive. Used in combination with startMs.</param>
        /// <param name="vehicleId">Required parameter: ID of the vehicle</param>
        /// <return>Returns the Models.VehicleSafetyScoreResponse response from the API call</return>
        public Models.VehicleSafetyScoreResponse GetVehicleSafetyScore(
                string accessToken,
                long startMs,
                long endMs,
                long vehicleId)
        {
            Task<Models.VehicleSafetyScoreResponse> t = GetVehicleSafetyScoreAsync(accessToken, startMs, endMs, vehicleId);
            APIHelper.RunTaskSynchronously(t);
            return t.Result;
        }

        /// <summary>
        /// Fetch the safety score for the vehicle.
        /// </summary>
        /// <param name="accessToken">Required parameter: Samsara API access token.</param>
        /// <param name="startMs">Required parameter: Timestamp in milliseconds representing the start of the period to fetch, inclusive. Used in combination with endMs.</param>
        /// <param name="endMs">Required parameter: Timestamp in milliseconds representing the end of the period to fetch, inclusive. Used in combination with startMs.</param>
        /// <param name="vehicleId">Required parameter: ID of the vehicle</param>
        /// <return>Returns the Models.VehicleSafetyScoreResponse response from the API call</return>
        public async Task<Models.VehicleSafetyScoreResponse> GetVehicleSafetyScoreAsync(
                string accessToken,
                long startMs,
                long endMs,
                long vehicleId)
        {
            //the base uri for api requests
            string _baseUri = Configuration.BaseUri;

            //prepare query string for API call
            StringBuilder _queryBuilder = new StringBuilder(_baseUri);
            _queryBuilder.Append("/fleet/vehicles/{vehicleId}/safety/score");

            //process optional template parameters
            APIHelper.AppendUrlWithTemplateParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "vehicleId", vehicleId }
            });

            //process optional query parameters
            APIHelper.AppendUrlWithQueryParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "access_token", accessToken },
                { "startMs", startMs },
                { "endMs", endMs },
                { "access_token", Configuration.AccessToken }
            },ArrayDeserializationFormat,ParameterSeparator);


            //validate and preprocess url
            string _queryUrl = APIHelper.CleanUrl(_queryBuilder);

            //append request with appropriate headers and parameters
            var _headers = new Dictionary<string,string>()
            {
                { "user-agent", "APIMATIC 2.0" },
                { "accept", "application/json" }
            };

            //prepare the API call request to fetch the response
            HttpRequest _request = ClientInstance.Get(_queryUrl,_headers);

            //invoke request and get response
            HttpStringResponse _response = (HttpStringResponse) await ClientInstance.ExecuteAsStringAsync(_request).ConfigureAwait(false);
            HttpContext _context = new HttpContext(_request,_response);

            //Error handling using HTTP status codes
            if ((_response.StatusCode < 200) || (_response.StatusCode > 208)) //[200,208] = HTTP OK
                throw new APIException(@"Unexpected error.", _context);

            //handle errors defined at the API level
            base.ValidateResponse(_response, _context);

            try
            {
                return APIHelper.JsonDeserialize<Models.VehicleSafetyScoreResponse>(_response.Body);
            }
            catch (Exception _ex)
            {
                throw new APIException("Failed to parse the response: " + _ex.Message, _context);
            }
        }

        /// <summary>
        /// Fetch harsh event details for a vehicle.
        /// </summary>
        /// <param name="accessToken">Required parameter: Samsara API access token.</param>
        /// <param name="timestamp">Required parameter: Timestamp in milliseconds representing the timestamp of a harsh event.</param>
        /// <param name="vehicleId">Required parameter: ID of the vehicle</param>
        /// <return>Returns the Models.VehicleHarshEventResponse response from the API call</return>
        public Models.VehicleHarshEventResponse GetVehicleHarshEvent(string accessToken, long timestamp, long vehicleId)
        {
            Task<Models.VehicleHarshEventResponse> t = GetVehicleHarshEventAsync(accessToken, timestamp, vehicleId);
            APIHelper.RunTaskSynchronously(t);
            return t.Result;
        }

        /// <summary>
        /// Fetch harsh event details for a vehicle.
        /// </summary>
        /// <param name="accessToken">Required parameter: Samsara API access token.</param>
        /// <param name="timestamp">Required parameter: Timestamp in milliseconds representing the timestamp of a harsh event.</param>
        /// <param name="vehicleId">Required parameter: ID of the vehicle</param>
        /// <return>Returns the Models.VehicleHarshEventResponse response from the API call</return>
        public async Task<Models.VehicleHarshEventResponse> GetVehicleHarshEventAsync(string accessToken, long timestamp, long vehicleId)
        {
            //the base uri for api requests
            string _baseUri = Configuration.BaseUri;

            //prepare query string for API call
            StringBuilder _queryBuilder = new StringBuilder(_baseUri);
            _queryBuilder.Append("/fleet/vehicles/{vehicleId}/safety/harsh_event");

            //process optional template parameters
            APIHelper.AppendUrlWithTemplateParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "vehicleId", vehicleId }
            });

            //process optional query parameters
            APIHelper.AppendUrlWithQueryParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "access_token", accessToken },
                { "timestamp", timestamp },
                { "access_token", Configuration.AccessToken }
            },ArrayDeserializationFormat,ParameterSeparator);


            //validate and preprocess url
            string _queryUrl = APIHelper.CleanUrl(_queryBuilder);

            //append request with appropriate headers and parameters
            var _headers = new Dictionary<string,string>()
            {
                { "user-agent", "APIMATIC 2.0" },
                { "accept", "application/json" }
            };

            //prepare the API call request to fetch the response
            HttpRequest _request = ClientInstance.Get(_queryUrl,_headers);

            //invoke request and get response
            HttpStringResponse _response = (HttpStringResponse) await ClientInstance.ExecuteAsStringAsync(_request).ConfigureAwait(false);
            HttpContext _context = new HttpContext(_request,_response);

            //Error handling using HTTP status codes
            if ((_response.StatusCode < 200) || (_response.StatusCode > 208)) //[200,208] = HTTP OK
                throw new APIException(@"Unexpected error.", _context);

            //handle errors defined at the API level
            base.ValidateResponse(_response, _context);

            try
            {
                return APIHelper.JsonDeserialize<Models.VehicleHarshEventResponse>(_response.Body);
            }
            catch (Exception _ex)
            {
                throw new APIException("Failed to parse the response: " + _ex.Message, _context);
            }
        }

        /// <summary>
        /// Fetch locations for a given vehicle between a start/end time. The maximum query duration is 30 minutes.
        /// </summary>
        /// <param name="accessToken">Required parameter: Samsara API access token.</param>
        /// <param name="startMs">Required parameter: Time in Unix epoch milliseconds for the start of the query (cannot exceed 30 minutes)</param>
        /// <param name="endMs">Required parameter: Time in Unix epoch milliseconds for the end of the query (cannot exceed 30 minutes)</param>
        /// <return>Returns the List<Models.FleetVehiclesLocation> response from the API call</return>
        public List<Models.FleetVehiclesLocation> GetVehiclesLocations(string accessToken, int startMs, int endMs)
        {
            Task<List<Models.FleetVehiclesLocation>> t = GetVehiclesLocationsAsync(accessToken, startMs, endMs);
            APIHelper.RunTaskSynchronously(t);
            return t.Result;
        }

        /// <summary>
        /// Fetch locations for a given vehicle between a start/end time. The maximum query duration is 30 minutes.
        /// </summary>
        /// <param name="accessToken">Required parameter: Samsara API access token.</param>
        /// <param name="startMs">Required parameter: Time in Unix epoch milliseconds for the start of the query (cannot exceed 30 minutes)</param>
        /// <param name="endMs">Required parameter: Time in Unix epoch milliseconds for the end of the query (cannot exceed 30 minutes)</param>
        /// <return>Returns the List<Models.FleetVehiclesLocation> response from the API call</return>
        public async Task<List<Models.FleetVehiclesLocation>> GetVehiclesLocationsAsync(string accessToken, int startMs, int endMs)
        {
            //the base uri for api requests
            string _baseUri = Configuration.BaseUri;

            //prepare query string for API call
            StringBuilder _queryBuilder = new StringBuilder(_baseUri);
            _queryBuilder.Append("/fleet/vehicles/locations");

            //process optional query parameters
            APIHelper.AppendUrlWithQueryParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "access_token", accessToken },
                { "startMs", startMs },
                { "endMs", endMs },
                { "access_token", Configuration.AccessToken }
            },ArrayDeserializationFormat,ParameterSeparator);


            //validate and preprocess url
            string _queryUrl = APIHelper.CleanUrl(_queryBuilder);

            //append request with appropriate headers and parameters
            var _headers = new Dictionary<string,string>()
            {
                { "user-agent", "APIMATIC 2.0" },
                { "accept", "application/json" }
            };

            //prepare the API call request to fetch the response
            HttpRequest _request = ClientInstance.Get(_queryUrl,_headers);

            //invoke request and get response
            HttpStringResponse _response = (HttpStringResponse) await ClientInstance.ExecuteAsStringAsync(_request).ConfigureAwait(false);
            HttpContext _context = new HttpContext(_request,_response);

            //Error handling using HTTP status codes
            if ((_response.StatusCode < 200) || (_response.StatusCode > 208)) //[200,208] = HTTP OK
                throw new APIException(@"Unexpected error.", _context);

            //handle errors defined at the API level
            base.ValidateResponse(_response, _context);

            try
            {
                return APIHelper.JsonDeserialize<List<Models.FleetVehiclesLocation>>(_response.Body);
            }
            catch (Exception _ex)
            {
                throw new APIException("Failed to parse the response: " + _ex.Message, _context);
            }
        }

        /// <summary>
        /// Get DVIRs for the org within provided time constraints
        /// </summary>
        /// <param name="accessToken">Required parameter: Samsara API access token.</param>
        /// <param name="endMs">Required parameter: time in millis until the last dvir log.</param>
        /// <param name="durationMs">Required parameter: time in millis which corresponds to the duration before the end_ms.</param>
        /// <param name="groupId">Optional parameter: Group ID to query.</param>
        /// <return>Returns the Models.DvirListResponse response from the API call</return>
        public Models.DvirListResponse GetDvirs(
                string accessToken,
                int endMs,
                int durationMs,
                int? groupId = null)
        {
            Task<Models.DvirListResponse> t = GetDvirsAsync(accessToken, endMs, durationMs, groupId);
            APIHelper.RunTaskSynchronously(t);
            return t.Result;
        }

        /// <summary>
        /// Get DVIRs for the org within provided time constraints
        /// </summary>
        /// <param name="accessToken">Required parameter: Samsara API access token.</param>
        /// <param name="endMs">Required parameter: time in millis until the last dvir log.</param>
        /// <param name="durationMs">Required parameter: time in millis which corresponds to the duration before the end_ms.</param>
        /// <param name="groupId">Optional parameter: Group ID to query.</param>
        /// <return>Returns the Models.DvirListResponse response from the API call</return>
        public async Task<Models.DvirListResponse> GetDvirsAsync(
                string accessToken,
                int endMs,
                int durationMs,
                int? groupId = null)
        {
            //the base uri for api requests
            string _baseUri = Configuration.BaseUri;

            //prepare query string for API call
            StringBuilder _queryBuilder = new StringBuilder(_baseUri);
            _queryBuilder.Append("/fleet/maintenance/dvirs");

            //process optional query parameters
            APIHelper.AppendUrlWithQueryParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "access_token", accessToken },
                { "end_ms", endMs },
                { "duration_ms", durationMs },
                { "group_id", groupId },
                { "access_token", Configuration.AccessToken }
            },ArrayDeserializationFormat,ParameterSeparator);


            //validate and preprocess url
            string _queryUrl = APIHelper.CleanUrl(_queryBuilder);

            //append request with appropriate headers and parameters
            var _headers = new Dictionary<string,string>()
            {
                { "user-agent", "APIMATIC 2.0" },
                { "accept", "application/json" }
            };

            //prepare the API call request to fetch the response
            HttpRequest _request = ClientInstance.Get(_queryUrl,_headers);

            //invoke request and get response
            HttpStringResponse _response = (HttpStringResponse) await ClientInstance.ExecuteAsStringAsync(_request).ConfigureAwait(false);
            HttpContext _context = new HttpContext(_request,_response);

            //Error handling using HTTP status codes
            if ((_response.StatusCode < 200) || (_response.StatusCode > 208)) //[200,208] = HTTP OK
                throw new APIException(@"Unexpected error.", _context);

            //handle errors defined at the API level
            base.ValidateResponse(_response, _context);

            try
            {
                return APIHelper.JsonDeserialize<Models.DvirListResponse>(_response.Body);
            }
            catch (Exception _ex)
            {
                throw new APIException("Failed to parse the response: " + _ex.Message, _context);
            }
        }

        /// <summary>
        /// Gets a specific vehicle.
        /// </summary>
        /// <param name="accessToken">Required parameter: Samsara API access token.</param>
        /// <param name="vehicleIdOrExternalId">Required parameter: ID of the vehicle.  This must be either the numeric ID generated by Samsara or the external ID of the vehicle.  External IDs are customer specified key-value pairs.</param>
        /// <return>Returns the Models.FleetVehicleResponse response from the API call</return>
        public Models.FleetVehicleResponse GetFleetVehicle(string accessToken, string vehicleIdOrExternalId)
        {
            Task<Models.FleetVehicleResponse> t = GetFleetVehicleAsync(accessToken, vehicleIdOrExternalId);
            APIHelper.RunTaskSynchronously(t);
            return t.Result;
        }

        /// <summary>
        /// Gets a specific vehicle.
        /// </summary>
        /// <param name="accessToken">Required parameter: Samsara API access token.</param>
        /// <param name="vehicleIdOrExternalId">Required parameter: ID of the vehicle.  This must be either the numeric ID generated by Samsara or the external ID of the vehicle.  External IDs are customer specified key-value pairs.</param>
        /// <return>Returns the Models.FleetVehicleResponse response from the API call</return>
        public async Task<Models.FleetVehicleResponse> GetFleetVehicleAsync(string accessToken, string vehicleIdOrExternalId)
        {
            //the base uri for api requests
            string _baseUri = Configuration.BaseUri;

            //prepare query string for API call
            StringBuilder _queryBuilder = new StringBuilder(_baseUri);
            _queryBuilder.Append("/fleet/vehicles/{vehicle_id_or_external_id}");

            //process optional template parameters
            APIHelper.AppendUrlWithTemplateParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "vehicle_id_or_external_id", vehicleIdOrExternalId }
            });

            //process optional query parameters
            APIHelper.AppendUrlWithQueryParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "access_token", accessToken },
                { "access_token", Configuration.AccessToken }
            },ArrayDeserializationFormat,ParameterSeparator);


            //validate and preprocess url
            string _queryUrl = APIHelper.CleanUrl(_queryBuilder);

            //append request with appropriate headers and parameters
            var _headers = new Dictionary<string,string>()
            {
                { "user-agent", "APIMATIC 2.0" },
                { "accept", "application/json" }
            };

            //prepare the API call request to fetch the response
            HttpRequest _request = ClientInstance.Get(_queryUrl,_headers);

            //invoke request and get response
            HttpStringResponse _response = (HttpStringResponse) await ClientInstance.ExecuteAsStringAsync(_request).ConfigureAwait(false);
            HttpContext _context = new HttpContext(_request,_response);

            //Error handling using HTTP status codes
            if ((_response.StatusCode < 200) || (_response.StatusCode > 208)) //[200,208] = HTTP OK
                throw new APIException(@"Unexpected error.", _context);

            //handle errors defined at the API level
            base.ValidateResponse(_response, _context);

            try
            {
                return APIHelper.JsonDeserialize<Models.FleetVehicleResponse>(_response.Body);
            }
            catch (Exception _ex)
            {
                throw new APIException("Failed to parse the response: " + _ex.Message, _context);
            }
        }

        /// <summary>
        /// Get list of the vehicles. This method returns a list of the vehicles in the Samsara Cloud and information about them.
        /// </summary>
        /// <param name="accessToken">Required parameter: Samsara API access token.</param>
        /// <param name="groupParam">Required parameter: Group ID to query.</param>
        /// <param name="startingAfter">Optional parameter: Pagination parameter indicating the cursor position to continue returning results after. Used in conjunction with the 'limit' parameter. Mutually exclusive with 'endingBefore' parameter.</param>
        /// <param name="endingBefore">Optional parameter: Pagination parameter indicating the cursor position to return results before. Used in conjunction with the 'limit' parameter. Mutually exclusive with 'startingAfter' parameter.</param>
        /// <param name="limit">Optional parameter: Pagination parameter indicating the number of results to return in this request. Used in conjunction with either 'startingAfter' or 'endingBefore'.</param>
        /// <return>Returns the Models.ListFleetResponse response from the API call</return>
        public Models.ListFleetResponse CreateListFleet(
                string accessToken,
                Models.GroupParam groupParam,
                string startingAfter = null,
                string endingBefore = null,
                long? limit = null)
        {
            Task<Models.ListFleetResponse> t = CreateListFleetAsync(accessToken, groupParam, startingAfter, endingBefore, limit);
            APIHelper.RunTaskSynchronously(t);
            return t.Result;
        }

        /// <summary>
        /// Get list of the vehicles. This method returns a list of the vehicles in the Samsara Cloud and information about them.
        /// </summary>
        /// <param name="accessToken">Required parameter: Samsara API access token.</param>
        /// <param name="groupParam">Required parameter: Group ID to query.</param>
        /// <param name="startingAfter">Optional parameter: Pagination parameter indicating the cursor position to continue returning results after. Used in conjunction with the 'limit' parameter. Mutually exclusive with 'endingBefore' parameter.</param>
        /// <param name="endingBefore">Optional parameter: Pagination parameter indicating the cursor position to return results before. Used in conjunction with the 'limit' parameter. Mutually exclusive with 'startingAfter' parameter.</param>
        /// <param name="limit">Optional parameter: Pagination parameter indicating the number of results to return in this request. Used in conjunction with either 'startingAfter' or 'endingBefore'.</param>
        /// <return>Returns the Models.ListFleetResponse response from the API call</return>
        public async Task<Models.ListFleetResponse> CreateListFleetAsync(
                string accessToken,
                Models.GroupParam groupParam,
                string startingAfter = null,
                string endingBefore = null,
                long? limit = null)
        {
            //the base uri for api requests
            string _baseUri = Configuration.BaseUri;

            //prepare query string for API call
            StringBuilder _queryBuilder = new StringBuilder(_baseUri);
            _queryBuilder.Append("/fleet/list");

            //process optional query parameters
            APIHelper.AppendUrlWithQueryParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "access_token", accessToken },
                { "startingAfter", startingAfter },
                { "endingBefore", endingBefore },
                { "limit", limit },
                { "access_token", Configuration.AccessToken }
            },ArrayDeserializationFormat,ParameterSeparator);


            //validate and preprocess url
            string _queryUrl = APIHelper.CleanUrl(_queryBuilder);

            //append request with appropriate headers and parameters
            var _headers = new Dictionary<string,string>()
            {
                { "user-agent", "APIMATIC 2.0" },
                { "accept", "application/json" },
                { "content-type", "application/json; charset=utf-8" }
            };

            //append body params
            var _body = APIHelper.JsonSerialize(groupParam);

            //prepare the API call request to fetch the response
            HttpRequest _request = ClientInstance.PostBody(_queryUrl, _headers, _body);

            //invoke request and get response
            HttpStringResponse _response = (HttpStringResponse) await ClientInstance.ExecuteAsStringAsync(_request).ConfigureAwait(false);
            HttpContext _context = new HttpContext(_request,_response);

            //Error handling using HTTP status codes
            if ((_response.StatusCode < 200) || (_response.StatusCode > 208)) //[200,208] = HTTP OK
                throw new APIException(@"Unexpected error.", _context);

            //handle errors defined at the API level
            base.ValidateResponse(_response, _context);

            try
            {
                return APIHelper.JsonDeserialize<Models.ListFleetResponse>(_response.Body);
            }
            catch (Exception _ex)
            {
                throw new APIException("Failed to parse the response: " + _ex.Message, _context);
            }
        }

        /// <summary>
        /// Get summarized daily HOS charts for a specified driver.
        /// </summary>
        /// <param name="accessToken">Required parameter: Samsara API access token.</param>
        /// <param name="driverId">Required parameter: ID of the driver with HOS logs.</param>
        /// <param name="hosLogsParam">Required parameter: Example: </param>
        /// <return>Returns the Models.DriverDailyLogResponse response from the API call</return>
        public Models.DriverDailyLogResponse CreateGetFleetDriversHosDailyLogs(string accessToken, long driverId, Models.HosLogsParam hosLogsParam)
        {
            Task<Models.DriverDailyLogResponse> t = CreateGetFleetDriversHosDailyLogsAsync(accessToken, driverId, hosLogsParam);
            APIHelper.RunTaskSynchronously(t);
            return t.Result;
        }

        /// <summary>
        /// Get summarized daily HOS charts for a specified driver.
        /// </summary>
        /// <param name="accessToken">Required parameter: Samsara API access token.</param>
        /// <param name="driverId">Required parameter: ID of the driver with HOS logs.</param>
        /// <param name="hosLogsParam">Required parameter: Example: </param>
        /// <return>Returns the Models.DriverDailyLogResponse response from the API call</return>
        public async Task<Models.DriverDailyLogResponse> CreateGetFleetDriversHosDailyLogsAsync(string accessToken, long driverId, Models.HosLogsParam hosLogsParam)
        {
            //the base uri for api requests
            string _baseUri = Configuration.BaseUri;

            //prepare query string for API call
            StringBuilder _queryBuilder = new StringBuilder(_baseUri);
            _queryBuilder.Append("/fleet/drivers/{driver_id}/hos_daily_logs");

            //process optional template parameters
            APIHelper.AppendUrlWithTemplateParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "driver_id", driverId }
            });

            //process optional query parameters
            APIHelper.AppendUrlWithQueryParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "access_token", accessToken },
                { "access_token", Configuration.AccessToken }
            },ArrayDeserializationFormat,ParameterSeparator);


            //validate and preprocess url
            string _queryUrl = APIHelper.CleanUrl(_queryBuilder);

            //append request with appropriate headers and parameters
            var _headers = new Dictionary<string,string>()
            {
                { "user-agent", "APIMATIC 2.0" },
                { "accept", "application/json" },
                { "content-type", "application/json; charset=utf-8" }
            };

            //append body params
            var _body = APIHelper.JsonSerialize(hosLogsParam);

            //prepare the API call request to fetch the response
            HttpRequest _request = ClientInstance.PostBody(_queryUrl, _headers, _body);

            //invoke request and get response
            HttpStringResponse _response = (HttpStringResponse) await ClientInstance.ExecuteAsStringAsync(_request).ConfigureAwait(false);
            HttpContext _context = new HttpContext(_request,_response);

            //Error handling using HTTP status codes
            if ((_response.StatusCode < 200) || (_response.StatusCode > 208)) //[200,208] = HTTP OK
                throw new APIException(@"Unexpected error.", _context);

            //handle errors defined at the API level
            base.ValidateResponse(_response, _context);

            try
            {
                return APIHelper.JsonDeserialize<Models.DriverDailyLogResponse>(_response.Body);
            }
            catch (Exception _ex)
            {
                throw new APIException("Failed to parse the response: " + _ex.Message, _context);
            }
        }

        /// <summary>
        /// Create a driver document for the given driver.
        /// </summary>
        /// <param name="createDocumentParams">Required parameter: To create a document for a given document type, the document type's uuid needs to be passed in to documentTypeUuid. The list of fields passed in should match the document type’s list of field types in the correct order. In other words, a field's valueType and value (i.e. only one of: stringValue, numberValue, or photoValue) at index _i_ should match with the document field type’s valueType at index _i_.</param>
        /// <param name="accessToken">Required parameter: Samsara API access token.</param>
        /// <param name="driverId">Required parameter: ID of the driver for whom the document is created.</param>
        /// <return>Returns the Models.Document response from the API call</return>
        public Models.Document CreateDriverDocument(Models.DocumentCreate createDocumentParams, string accessToken, long driverId)
        {
            Task<Models.Document> t = CreateDriverDocumentAsync(createDocumentParams, accessToken, driverId);
            APIHelper.RunTaskSynchronously(t);
            return t.Result;
        }

        /// <summary>
        /// Create a driver document for the given driver.
        /// </summary>
        /// <param name="createDocumentParams">Required parameter: To create a document for a given document type, the document type's uuid needs to be passed in to documentTypeUuid. The list of fields passed in should match the document type’s list of field types in the correct order. In other words, a field's valueType and value (i.e. only one of: stringValue, numberValue, or photoValue) at index _i_ should match with the document field type’s valueType at index _i_.</param>
        /// <param name="accessToken">Required parameter: Samsara API access token.</param>
        /// <param name="driverId">Required parameter: ID of the driver for whom the document is created.</param>
        /// <return>Returns the Models.Document response from the API call</return>
        public async Task<Models.Document> CreateDriverDocumentAsync(Models.DocumentCreate createDocumentParams, string accessToken, long driverId)
        {
            //the base uri for api requests
            string _baseUri = Configuration.BaseUri;

            //prepare query string for API call
            StringBuilder _queryBuilder = new StringBuilder(_baseUri);
            _queryBuilder.Append("/fleet/drivers/{driver_id}/documents");

            //process optional template parameters
            APIHelper.AppendUrlWithTemplateParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "driver_id", driverId }
            });

            //process optional query parameters
            APIHelper.AppendUrlWithQueryParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "access_token", accessToken },
                { "access_token", Configuration.AccessToken }
            },ArrayDeserializationFormat,ParameterSeparator);


            //validate and preprocess url
            string _queryUrl = APIHelper.CleanUrl(_queryBuilder);

            //append request with appropriate headers and parameters
            var _headers = new Dictionary<string,string>()
            {
                { "user-agent", "APIMATIC 2.0" },
                { "accept", "application/json" },
                { "content-type", "application/json; charset=utf-8" }
            };

            //append body params
            var _body = APIHelper.JsonSerialize(createDocumentParams);

            //prepare the API call request to fetch the response
            HttpRequest _request = ClientInstance.PostBody(_queryUrl, _headers, _body);

            //invoke request and get response
            HttpStringResponse _response = (HttpStringResponse) await ClientInstance.ExecuteAsStringAsync(_request).ConfigureAwait(false);
            HttpContext _context = new HttpContext(_request,_response);

            //Error handling using HTTP status codes
            if ((_response.StatusCode < 200) || (_response.StatusCode > 208)) //[200,208] = HTTP OK
                throw new APIException(@"Unexpected error.", _context);

            //handle errors defined at the API level
            base.ValidateResponse(_response, _context);

            try
            {
                return APIHelper.JsonDeserialize<Models.Document>(_response.Body);
            }
            catch (Exception _ex)
            {
                throw new APIException("Failed to parse the response: " + _ex.Message, _context);
            }
        }

        /// <summary>
        /// Create a new dispatch route for the driver with driver_id.
        /// </summary>
        /// <param name="createDispatchRouteParams">Required parameter: Example: </param>
        /// <param name="accessToken">Required parameter: Samsara API access token.</param>
        /// <param name="driverId">Required parameter: ID of the driver with the associated routes.</param>
        /// <return>Returns the Models.DispatchRoute response from the API call</return>
        public Models.DispatchRoute CreateDriverDispatchRoute(Models.DispatchRouteCreate createDispatchRouteParams, string accessToken, long driverId)
        {
            Task<Models.DispatchRoute> t = CreateDriverDispatchRouteAsync(createDispatchRouteParams, accessToken, driverId);
            APIHelper.RunTaskSynchronously(t);
            return t.Result;
        }

        /// <summary>
        /// Create a new dispatch route for the driver with driver_id.
        /// </summary>
        /// <param name="createDispatchRouteParams">Required parameter: Example: </param>
        /// <param name="accessToken">Required parameter: Samsara API access token.</param>
        /// <param name="driverId">Required parameter: ID of the driver with the associated routes.</param>
        /// <return>Returns the Models.DispatchRoute response from the API call</return>
        public async Task<Models.DispatchRoute> CreateDriverDispatchRouteAsync(Models.DispatchRouteCreate createDispatchRouteParams, string accessToken, long driverId)
        {
            //the base uri for api requests
            string _baseUri = Configuration.BaseUri;

            //prepare query string for API call
            StringBuilder _queryBuilder = new StringBuilder(_baseUri);
            _queryBuilder.Append("/fleet/drivers/{driver_id}/dispatch/routes");

            //process optional template parameters
            APIHelper.AppendUrlWithTemplateParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "driver_id", driverId }
            });

            //process optional query parameters
            APIHelper.AppendUrlWithQueryParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "access_token", accessToken },
                { "access_token", Configuration.AccessToken }
            },ArrayDeserializationFormat,ParameterSeparator);


            //validate and preprocess url
            string _queryUrl = APIHelper.CleanUrl(_queryBuilder);

            //append request with appropriate headers and parameters
            var _headers = new Dictionary<string,string>()
            {
                { "user-agent", "APIMATIC 2.0" },
                { "accept", "application/json" },
                { "content-type", "application/json; charset=utf-8" }
            };

            //append body params
            var _body = APIHelper.JsonSerialize(createDispatchRouteParams);

            //prepare the API call request to fetch the response
            HttpRequest _request = ClientInstance.PostBody(_queryUrl, _headers, _body);

            //invoke request and get response
            HttpStringResponse _response = (HttpStringResponse) await ClientInstance.ExecuteAsStringAsync(_request).ConfigureAwait(false);
            HttpContext _context = new HttpContext(_request,_response);

            //Error handling using HTTP status codes
            if ((_response.StatusCode < 200) || (_response.StatusCode > 208)) //[200,208] = HTTP OK
                throw new APIException(@"Unexpected error.", _context);

            //handle errors defined at the API level
            base.ValidateResponse(_response, _context);

            try
            {
                return APIHelper.JsonDeserialize<Models.DispatchRoute>(_response.Body);
            }
            catch (Exception _ex)
            {
                throw new APIException("Failed to parse the response: " + _ex.Message, _context);
            }
        }

        /// <summary>
        /// Get historical trips data for specified vehicle. This method returns a set of historical trips data for the specified vehicle in the specified time range.
        /// </summary>
        /// <param name="accessToken">Required parameter: Samsara API access token.</param>
        /// <param name="tripsParam">Required parameter: Group ID, vehicle ID and time range to query.</param>
        /// <return>Returns the Models.TripResponse response from the API call</return>
        public Models.TripResponse CreateGetFleetTrips(string accessToken, Models.TripsParam tripsParam)
        {
            Task<Models.TripResponse> t = CreateGetFleetTripsAsync(accessToken, tripsParam);
            APIHelper.RunTaskSynchronously(t);
            return t.Result;
        }

        /// <summary>
        /// Get historical trips data for specified vehicle. This method returns a set of historical trips data for the specified vehicle in the specified time range.
        /// </summary>
        /// <param name="accessToken">Required parameter: Samsara API access token.</param>
        /// <param name="tripsParam">Required parameter: Group ID, vehicle ID and time range to query.</param>
        /// <return>Returns the Models.TripResponse response from the API call</return>
        public async Task<Models.TripResponse> CreateGetFleetTripsAsync(string accessToken, Models.TripsParam tripsParam)
        {
            //the base uri for api requests
            string _baseUri = Configuration.BaseUri;

            //prepare query string for API call
            StringBuilder _queryBuilder = new StringBuilder(_baseUri);
            _queryBuilder.Append("/fleet/trips");

            //process optional query parameters
            APIHelper.AppendUrlWithQueryParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "access_token", accessToken },
                { "access_token", Configuration.AccessToken }
            },ArrayDeserializationFormat,ParameterSeparator);


            //validate and preprocess url
            string _queryUrl = APIHelper.CleanUrl(_queryBuilder);

            //append request with appropriate headers and parameters
            var _headers = new Dictionary<string,string>()
            {
                { "user-agent", "APIMATIC 2.0" },
                { "accept", "application/json" },
                { "content-type", "application/json; charset=utf-8" }
            };

            //append body params
            var _body = APIHelper.JsonSerialize(tripsParam);

            //prepare the API call request to fetch the response
            HttpRequest _request = ClientInstance.PostBody(_queryUrl, _headers, _body);

            //invoke request and get response
            HttpStringResponse _response = (HttpStringResponse) await ClientInstance.ExecuteAsStringAsync(_request).ConfigureAwait(false);
            HttpContext _context = new HttpContext(_request,_response);

            //Error handling using HTTP status codes
            if ((_response.StatusCode < 200) || (_response.StatusCode > 208)) //[200,208] = HTTP OK
                throw new APIException(@"Unexpected error.", _context);

            //handle errors defined at the API level
            base.ValidateResponse(_response, _context);

            try
            {
                return APIHelper.JsonDeserialize<Models.TripResponse>(_response.Body);
            }
            catch (Exception _ex)
            {
                throw new APIException("Failed to parse the response: " + _ex.Message, _context);
            }
        }

        /// <summary>
        /// This method enables the mutation of metadata for vehicles in the Samsara Cloud.
        /// </summary>
        /// <param name="accessToken">Required parameter: Samsara API access token.</param>
        /// <param name="vehicleUpdateParam">Required parameter: Example: </param>
        /// <return>Returns the void response from the API call</return>
        public void UpdateVehicles(string accessToken, Models.VehicleUpdateParam vehicleUpdateParam)
        {
            Task t = UpdateVehiclesAsync(accessToken, vehicleUpdateParam);
            APIHelper.RunTaskSynchronously(t);
        }

        /// <summary>
        /// This method enables the mutation of metadata for vehicles in the Samsara Cloud.
        /// </summary>
        /// <param name="accessToken">Required parameter: Samsara API access token.</param>
        /// <param name="vehicleUpdateParam">Required parameter: Example: </param>
        /// <return>Returns the void response from the API call</return>
        public async Task UpdateVehiclesAsync(string accessToken, Models.VehicleUpdateParam vehicleUpdateParam)
        {
            //the base uri for api requests
            string _baseUri = Configuration.BaseUri;

            //prepare query string for API call
            StringBuilder _queryBuilder = new StringBuilder(_baseUri);
            _queryBuilder.Append("/fleet/set_data");

            //process optional query parameters
            APIHelper.AppendUrlWithQueryParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "access_token", accessToken },
                { "access_token", Configuration.AccessToken }
            },ArrayDeserializationFormat,ParameterSeparator);


            //validate and preprocess url
            string _queryUrl = APIHelper.CleanUrl(_queryBuilder);

            //append request with appropriate headers and parameters
            var _headers = new Dictionary<string,string>()
            {
                { "user-agent", "APIMATIC 2.0" },
                { "content-type", "application/json; charset=utf-8" }
            };

            //append body params
            var _body = APIHelper.JsonSerialize(vehicleUpdateParam);

            //prepare the API call request to fetch the response
            HttpRequest _request = ClientInstance.PostBody(_queryUrl, _headers, _body);

            //invoke request and get response
            HttpStringResponse _response = (HttpStringResponse) await ClientInstance.ExecuteAsStringAsync(_request).ConfigureAwait(false);
            HttpContext _context = new HttpContext(_request,_response);

            //Error handling using HTTP status codes
            if ((_response.StatusCode < 200) || (_response.StatusCode > 208)) //[200,208] = HTTP OK
                throw new APIException(@"Unexpected error.", _context);

            //handle errors defined at the API level
            base.ValidateResponse(_response, _context);

        }

        /// <summary>
        /// Get list of the vehicles with any engine faults or check light data.
        /// </summary>
        /// <param name="accessToken">Required parameter: Samsara API access token.</param>
        /// <param name="groupParam">Required parameter: Group ID to query.</param>
        /// <return>Returns the Models.GetFleetMaintenanceListResponse response from the API call</return>
        public Models.GetFleetMaintenanceListResponse CreateGetFleetMaintenanceList(string accessToken, Models.GroupParam groupParam)
        {
            Task<Models.GetFleetMaintenanceListResponse> t = CreateGetFleetMaintenanceListAsync(accessToken, groupParam);
            APIHelper.RunTaskSynchronously(t);
            return t.Result;
        }

        /// <summary>
        /// Get list of the vehicles with any engine faults or check light data.
        /// </summary>
        /// <param name="accessToken">Required parameter: Samsara API access token.</param>
        /// <param name="groupParam">Required parameter: Group ID to query.</param>
        /// <return>Returns the Models.GetFleetMaintenanceListResponse response from the API call</return>
        public async Task<Models.GetFleetMaintenanceListResponse> CreateGetFleetMaintenanceListAsync(string accessToken, Models.GroupParam groupParam)
        {
            //the base uri for api requests
            string _baseUri = Configuration.BaseUri;

            //prepare query string for API call
            StringBuilder _queryBuilder = new StringBuilder(_baseUri);
            _queryBuilder.Append("/fleet/maintenance/list");

            //process optional query parameters
            APIHelper.AppendUrlWithQueryParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "access_token", accessToken },
                { "access_token", Configuration.AccessToken }
            },ArrayDeserializationFormat,ParameterSeparator);


            //validate and preprocess url
            string _queryUrl = APIHelper.CleanUrl(_queryBuilder);

            //append request with appropriate headers and parameters
            var _headers = new Dictionary<string,string>()
            {
                { "user-agent", "APIMATIC 2.0" },
                { "accept", "application/json" },
                { "content-type", "application/json; charset=utf-8" }
            };

            //append body params
            var _body = APIHelper.JsonSerialize(groupParam);

            //prepare the API call request to fetch the response
            HttpRequest _request = ClientInstance.PostBody(_queryUrl, _headers, _body);

            //invoke request and get response
            HttpStringResponse _response = (HttpStringResponse) await ClientInstance.ExecuteAsStringAsync(_request).ConfigureAwait(false);
            HttpContext _context = new HttpContext(_request,_response);

            //Error handling using HTTP status codes
            if ((_response.StatusCode < 200) || (_response.StatusCode > 208)) //[200,208] = HTTP OK
                throw new APIException(@"Unexpected error.", _context);

            //handle errors defined at the API level
            base.ValidateResponse(_response, _context);

            try
            {
                return APIHelper.JsonDeserialize<Models.GetFleetMaintenanceListResponse>(_response.Body);
            }
            catch (Exception _ex)
            {
                throw new APIException("Failed to parse the response: " + _ex.Message, _context);
            }
        }

        /// <summary>
        /// Fetch all of the dispatch routes for a given driver.
        /// </summary>
        /// <param name="accessToken">Required parameter: Samsara API access token.</param>
        /// <param name="driverId">Required parameter: ID of the driver with the associated routes.</param>
        /// <param name="endTime">Optional parameter: Time in unix milliseconds that represents the oldest routes to return. Used in combination with duration. Defaults to now.</param>
        /// <param name="duration">Optional parameter: Time in milliseconds that represents the duration before end_time to query. Defaults to 24 hours.</param>
        /// <return>Returns the List<Models.DispatchRoute> response from the API call</return>
        public List<Models.DispatchRoute> GetDispatchRoutesByDriverId(
                string accessToken,
                long driverId,
                long? endTime = null,
                long? duration = null)
        {
            Task<List<Models.DispatchRoute>> t = GetDispatchRoutesByDriverIdAsync(accessToken, driverId, endTime, duration);
            APIHelper.RunTaskSynchronously(t);
            return t.Result;
        }

        /// <summary>
        /// Fetch all of the dispatch routes for a given driver.
        /// </summary>
        /// <param name="accessToken">Required parameter: Samsara API access token.</param>
        /// <param name="driverId">Required parameter: ID of the driver with the associated routes.</param>
        /// <param name="endTime">Optional parameter: Time in unix milliseconds that represents the oldest routes to return. Used in combination with duration. Defaults to now.</param>
        /// <param name="duration">Optional parameter: Time in milliseconds that represents the duration before end_time to query. Defaults to 24 hours.</param>
        /// <return>Returns the List<Models.DispatchRoute> response from the API call</return>
        public async Task<List<Models.DispatchRoute>> GetDispatchRoutesByDriverIdAsync(
                string accessToken,
                long driverId,
                long? endTime = null,
                long? duration = null)
        {
            //the base uri for api requests
            string _baseUri = Configuration.BaseUri;

            //prepare query string for API call
            StringBuilder _queryBuilder = new StringBuilder(_baseUri);
            _queryBuilder.Append("/fleet/drivers/{driver_id}/dispatch/routes");

            //process optional template parameters
            APIHelper.AppendUrlWithTemplateParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "driver_id", driverId }
            });

            //process optional query parameters
            APIHelper.AppendUrlWithQueryParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "access_token", accessToken },
                { "end_time", endTime },
                { "duration", duration },
                { "access_token", Configuration.AccessToken }
            },ArrayDeserializationFormat,ParameterSeparator);


            //validate and preprocess url
            string _queryUrl = APIHelper.CleanUrl(_queryBuilder);

            //append request with appropriate headers and parameters
            var _headers = new Dictionary<string,string>()
            {
                { "user-agent", "APIMATIC 2.0" },
                { "accept", "application/json" }
            };

            //prepare the API call request to fetch the response
            HttpRequest _request = ClientInstance.Get(_queryUrl,_headers);

            //invoke request and get response
            HttpStringResponse _response = (HttpStringResponse) await ClientInstance.ExecuteAsStringAsync(_request).ConfigureAwait(false);
            HttpContext _context = new HttpContext(_request,_response);

            //Error handling using HTTP status codes
            if ((_response.StatusCode < 200) || (_response.StatusCode > 208)) //[200,208] = HTTP OK
                throw new APIException(@"Unexpected error.", _context);

            //handle errors defined at the API level
            base.ValidateResponse(_response, _context);

            try
            {
                return APIHelper.JsonDeserialize<List<Models.DispatchRoute>>(_response.Body);
            }
            catch (Exception _ex)
            {
                throw new APIException("Failed to parse the response: " + _ex.Message, _context);
            }
        }

        /// <summary>
        /// Create a new dvir, marking a vehicle or trailer safe or unsafe.
        /// </summary>
        /// <param name="accessToken">Required parameter: Samsara API access token.</param>
        /// <param name="createDvirParam">Required parameter: DVIR creation body</param>
        /// <return>Returns the Models.DvirBase response from the API call</return>
        public Models.DvirBase CreateDvir(string accessToken, Models.CreateDvirParam createDvirParam)
        {
            Task<Models.DvirBase> t = CreateDvirAsync(accessToken, createDvirParam);
            APIHelper.RunTaskSynchronously(t);
            return t.Result;
        }

        /// <summary>
        /// Create a new dvir, marking a vehicle or trailer safe or unsafe.
        /// </summary>
        /// <param name="accessToken">Required parameter: Samsara API access token.</param>
        /// <param name="createDvirParam">Required parameter: DVIR creation body</param>
        /// <return>Returns the Models.DvirBase response from the API call</return>
        public async Task<Models.DvirBase> CreateDvirAsync(string accessToken, Models.CreateDvirParam createDvirParam)
        {
            //the base uri for api requests
            string _baseUri = Configuration.BaseUri;

            //prepare query string for API call
            StringBuilder _queryBuilder = new StringBuilder(_baseUri);
            _queryBuilder.Append("/fleet/maintenance/dvirs");

            //process optional query parameters
            APIHelper.AppendUrlWithQueryParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "access_token", accessToken },
                { "access_token", Configuration.AccessToken }
            },ArrayDeserializationFormat,ParameterSeparator);


            //validate and preprocess url
            string _queryUrl = APIHelper.CleanUrl(_queryBuilder);

            //append request with appropriate headers and parameters
            var _headers = new Dictionary<string,string>()
            {
                { "user-agent", "APIMATIC 2.0" },
                { "accept", "application/json" },
                { "content-type", "application/json; charset=utf-8" }
            };

            //append body params
            var _body = APIHelper.JsonSerialize(createDvirParam);

            //prepare the API call request to fetch the response
            HttpRequest _request = ClientInstance.PostBody(_queryUrl, _headers, _body);

            //invoke request and get response
            HttpStringResponse _response = (HttpStringResponse) await ClientInstance.ExecuteAsStringAsync(_request).ConfigureAwait(false);
            HttpContext _context = new HttpContext(_request,_response);

            //Error handling using HTTP status codes
            if ((_response.StatusCode < 200) || (_response.StatusCode > 208)) //[200,208] = HTTP OK
                throw new APIException(@"Unexpected error.", _context);

            //handle errors defined at the API level
            base.ValidateResponse(_response, _context);

            try
            {
                return APIHelper.JsonDeserialize<Models.DvirBase>(_response.Body);
            }
            catch (Exception _ex)
            {
                throw new APIException("Failed to parse the response: " + _ex.Message, _context);
            }
        }

        /// <summary>
        /// Fetch the safety score for the driver.
        /// </summary>
        /// <param name="accessToken">Required parameter: Samsara API access token.</param>
        /// <param name="startMs">Required parameter: Timestamp in milliseconds representing the start of the period to fetch, inclusive. Used in combination with endMs.</param>
        /// <param name="endMs">Required parameter: Timestamp in milliseconds representing the end of the period to fetch, inclusive. Used in combination with startMs.</param>
        /// <param name="driverId">Required parameter: ID of the driver</param>
        /// <return>Returns the Models.DriverSafetyScoreResponse response from the API call</return>
        public Models.DriverSafetyScoreResponse GetDriverSafetyScore(
                string accessToken,
                long startMs,
                long endMs,
                long driverId)
        {
            Task<Models.DriverSafetyScoreResponse> t = GetDriverSafetyScoreAsync(accessToken, startMs, endMs, driverId);
            APIHelper.RunTaskSynchronously(t);
            return t.Result;
        }

        /// <summary>
        /// Fetch the safety score for the driver.
        /// </summary>
        /// <param name="accessToken">Required parameter: Samsara API access token.</param>
        /// <param name="startMs">Required parameter: Timestamp in milliseconds representing the start of the period to fetch, inclusive. Used in combination with endMs.</param>
        /// <param name="endMs">Required parameter: Timestamp in milliseconds representing the end of the period to fetch, inclusive. Used in combination with startMs.</param>
        /// <param name="driverId">Required parameter: ID of the driver</param>
        /// <return>Returns the Models.DriverSafetyScoreResponse response from the API call</return>
        public async Task<Models.DriverSafetyScoreResponse> GetDriverSafetyScoreAsync(
                string accessToken,
                long startMs,
                long endMs,
                long driverId)
        {
            //the base uri for api requests
            string _baseUri = Configuration.BaseUri;

            //prepare query string for API call
            StringBuilder _queryBuilder = new StringBuilder(_baseUri);
            _queryBuilder.Append("/fleet/drivers/{driverId}/safety/score");

            //process optional template parameters
            APIHelper.AppendUrlWithTemplateParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "driverId", driverId }
            });

            //process optional query parameters
            APIHelper.AppendUrlWithQueryParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "access_token", accessToken },
                { "startMs", startMs },
                { "endMs", endMs },
                { "access_token", Configuration.AccessToken }
            },ArrayDeserializationFormat,ParameterSeparator);


            //validate and preprocess url
            string _queryUrl = APIHelper.CleanUrl(_queryBuilder);

            //append request with appropriate headers and parameters
            var _headers = new Dictionary<string,string>()
            {
                { "user-agent", "APIMATIC 2.0" },
                { "accept", "application/json" }
            };

            //prepare the API call request to fetch the response
            HttpRequest _request = ClientInstance.Get(_queryUrl,_headers);

            //invoke request and get response
            HttpStringResponse _response = (HttpStringResponse) await ClientInstance.ExecuteAsStringAsync(_request).ConfigureAwait(false);
            HttpContext _context = new HttpContext(_request,_response);

            //Error handling using HTTP status codes
            if ((_response.StatusCode < 200) || (_response.StatusCode > 208)) //[200,208] = HTTP OK
                throw new APIException(@"Unexpected error.", _context);

            //handle errors defined at the API level
            base.ValidateResponse(_response, _context);

            try
            {
                return APIHelper.JsonDeserialize<Models.DriverSafetyScoreResponse>(_response.Body);
            }
            catch (Exception _ex)
            {
                throw new APIException("Failed to parse the response: " + _ex.Message, _context);
            }
        }

        /// <summary>
        /// Get current location of vehicles in a group. This method returns the current location in latitude and longitude of all vehicles in a requested group.
        /// </summary>
        /// <param name="accessToken">Required parameter: Samsara API access token.</param>
        /// <param name="groupParam">Required parameter: Group ID to query.</param>
        /// <return>Returns the Models.GetFleetLocationsResponse response from the API call</return>
        public Models.GetFleetLocationsResponse CreateGetFleetLocations(string accessToken, Models.GroupParam groupParam)
        {
            Task<Models.GetFleetLocationsResponse> t = CreateGetFleetLocationsAsync(accessToken, groupParam);
            APIHelper.RunTaskSynchronously(t);
            return t.Result;
        }

        /// <summary>
        /// Get current location of vehicles in a group. This method returns the current location in latitude and longitude of all vehicles in a requested group.
        /// </summary>
        /// <param name="accessToken">Required parameter: Samsara API access token.</param>
        /// <param name="groupParam">Required parameter: Group ID to query.</param>
        /// <return>Returns the Models.GetFleetLocationsResponse response from the API call</return>
        public async Task<Models.GetFleetLocationsResponse> CreateGetFleetLocationsAsync(string accessToken, Models.GroupParam groupParam)
        {
            //the base uri for api requests
            string _baseUri = Configuration.BaseUri;

            //prepare query string for API call
            StringBuilder _queryBuilder = new StringBuilder(_baseUri);
            _queryBuilder.Append("/fleet/locations");

            //process optional query parameters
            APIHelper.AppendUrlWithQueryParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "access_token", accessToken },
                { "access_token", Configuration.AccessToken }
            },ArrayDeserializationFormat,ParameterSeparator);


            //validate and preprocess url
            string _queryUrl = APIHelper.CleanUrl(_queryBuilder);

            //append request with appropriate headers and parameters
            var _headers = new Dictionary<string,string>()
            {
                { "user-agent", "APIMATIC 2.0" },
                { "accept", "application/json" },
                { "content-type", "application/json; charset=utf-8" }
            };

            //append body params
            var _body = APIHelper.JsonSerialize(groupParam);

            //prepare the API call request to fetch the response
            HttpRequest _request = ClientInstance.PostBody(_queryUrl, _headers, _body);

            //invoke request and get response
            HttpStringResponse _response = (HttpStringResponse) await ClientInstance.ExecuteAsStringAsync(_request).ConfigureAwait(false);
            HttpContext _context = new HttpContext(_request,_response);

            //Error handling using HTTP status codes
            if ((_response.StatusCode < 200) || (_response.StatusCode > 208)) //[200,208] = HTTP OK
                throw new APIException(@"Unexpected error.", _context);

            //handle errors defined at the API level
            base.ValidateResponse(_response, _context);

            try
            {
                return APIHelper.JsonDeserialize<Models.GetFleetLocationsResponse>(_response.Body);
            }
            catch (Exception _ex)
            {
                throw new APIException("Failed to parse the response: " + _ex.Message, _context);
            }
        }

        /// <summary>
        /// Get the current HOS status for all drivers in the group.
        /// </summary>
        /// <param name="accessToken">Required parameter: Samsara API access token.</param>
        /// <param name="hosLogsParam">Required parameter: Example: </param>
        /// <return>Returns the Models.HosLogsSummaryResponse response from the API call</return>
        public Models.HosLogsSummaryResponse CreateGetFleetHosLogsSummary(string accessToken, Models.HosLogsParam2 hosLogsParam)
        {
            Task<Models.HosLogsSummaryResponse> t = CreateGetFleetHosLogsSummaryAsync(accessToken, hosLogsParam);
            APIHelper.RunTaskSynchronously(t);
            return t.Result;
        }

        /// <summary>
        /// Get the current HOS status for all drivers in the group.
        /// </summary>
        /// <param name="accessToken">Required parameter: Samsara API access token.</param>
        /// <param name="hosLogsParam">Required parameter: Example: </param>
        /// <return>Returns the Models.HosLogsSummaryResponse response from the API call</return>
        public async Task<Models.HosLogsSummaryResponse> CreateGetFleetHosLogsSummaryAsync(string accessToken, Models.HosLogsParam2 hosLogsParam)
        {
            //the base uri for api requests
            string _baseUri = Configuration.BaseUri;

            //prepare query string for API call
            StringBuilder _queryBuilder = new StringBuilder(_baseUri);
            _queryBuilder.Append("/fleet/hos_logs_summary");

            //process optional query parameters
            APIHelper.AppendUrlWithQueryParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "access_token", accessToken },
                { "access_token", Configuration.AccessToken }
            },ArrayDeserializationFormat,ParameterSeparator);


            //validate and preprocess url
            string _queryUrl = APIHelper.CleanUrl(_queryBuilder);

            //append request with appropriate headers and parameters
            var _headers = new Dictionary<string,string>()
            {
                { "user-agent", "APIMATIC 2.0" },
                { "accept", "application/json" },
                { "content-type", "application/json; charset=utf-8" }
            };

            //append body params
            var _body = APIHelper.JsonSerialize(hosLogsParam);

            //prepare the API call request to fetch the response
            HttpRequest _request = ClientInstance.PostBody(_queryUrl, _headers, _body);

            //invoke request and get response
            HttpStringResponse _response = (HttpStringResponse) await ClientInstance.ExecuteAsStringAsync(_request).ConfigureAwait(false);
            HttpContext _context = new HttpContext(_request,_response);

            //Error handling using HTTP status codes
            if ((_response.StatusCode < 200) || (_response.StatusCode > 208)) //[200,208] = HTTP OK
                throw new APIException(@"Unexpected error.", _context);

            //handle errors defined at the API level
            base.ValidateResponse(_response, _context);

            try
            {
                return APIHelper.JsonDeserialize<Models.HosLogsSummaryResponse>(_response.Body);
            }
            catch (Exception _ex)
            {
                throw new APIException("Failed to parse the response: " + _ex.Message, _context);
            }
        }

        /// <summary>
        /// Get the HOS (hours of service) logs for the specified driver. This method returns all the HOS statuses that the driver was in during this time period.
        /// </summary>
        /// <param name="accessToken">Required parameter: Samsara API access token.</param>
        /// <param name="hosLogsParam">Required parameter: Example: </param>
        /// <return>Returns the Models.HosLogsResponse response from the API call</return>
        public Models.HosLogsResponse CreateGetFleetHosLogs(string accessToken, Models.HosLogsParam hosLogsParam)
        {
            Task<Models.HosLogsResponse> t = CreateGetFleetHosLogsAsync(accessToken, hosLogsParam);
            APIHelper.RunTaskSynchronously(t);
            return t.Result;
        }

        /// <summary>
        /// Get the HOS (hours of service) logs for the specified driver. This method returns all the HOS statuses that the driver was in during this time period.
        /// </summary>
        /// <param name="accessToken">Required parameter: Samsara API access token.</param>
        /// <param name="hosLogsParam">Required parameter: Example: </param>
        /// <return>Returns the Models.HosLogsResponse response from the API call</return>
        public async Task<Models.HosLogsResponse> CreateGetFleetHosLogsAsync(string accessToken, Models.HosLogsParam hosLogsParam)
        {
            //the base uri for api requests
            string _baseUri = Configuration.BaseUri;

            //prepare query string for API call
            StringBuilder _queryBuilder = new StringBuilder(_baseUri);
            _queryBuilder.Append("/fleet/hos_logs");

            //process optional query parameters
            APIHelper.AppendUrlWithQueryParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "access_token", accessToken },
                { "access_token", Configuration.AccessToken }
            },ArrayDeserializationFormat,ParameterSeparator);


            //validate and preprocess url
            string _queryUrl = APIHelper.CleanUrl(_queryBuilder);

            //append request with appropriate headers and parameters
            var _headers = new Dictionary<string,string>()
            {
                { "user-agent", "APIMATIC 2.0" },
                { "accept", "application/json" },
                { "content-type", "application/json; charset=utf-8" }
            };

            //append body params
            var _body = APIHelper.JsonSerialize(hosLogsParam);

            //prepare the API call request to fetch the response
            HttpRequest _request = ClientInstance.PostBody(_queryUrl, _headers, _body);

            //invoke request and get response
            HttpStringResponse _response = (HttpStringResponse) await ClientInstance.ExecuteAsStringAsync(_request).ConfigureAwait(false);
            HttpContext _context = new HttpContext(_request,_response);

            //Error handling using HTTP status codes
            if ((_response.StatusCode < 200) || (_response.StatusCode > 208)) //[200,208] = HTTP OK
                throw new APIException(@"Unexpected error.", _context);

            //handle errors defined at the API level
            base.ValidateResponse(_response, _context);

            try
            {
                return APIHelper.JsonDeserialize<Models.HosLogsResponse>(_response.Body);
            }
            catch (Exception _ex)
            {
                throw new APIException("Failed to parse the response: " + _ex.Message, _context);
            }
        }

        /// <summary>
        /// Get the HOS (hours of service) signin and signout logs for the specified driver. Only signout logs include location information.
        /// </summary>
        /// <param name="accessToken">Required parameter: Samsara API access token.</param>
        /// <param name="hosAuthenticationLogsParam">Required parameter: Example: </param>
        /// <return>Returns the Models.HosAuthenticationLogsResponse response from the API call</return>
        public Models.HosAuthenticationLogsResponse CreateGetFleetHosAuthenticationLogs(string accessToken, Models.HosAuthenticationLogsParam hosAuthenticationLogsParam)
        {
            Task<Models.HosAuthenticationLogsResponse> t = CreateGetFleetHosAuthenticationLogsAsync(accessToken, hosAuthenticationLogsParam);
            APIHelper.RunTaskSynchronously(t);
            return t.Result;
        }

        /// <summary>
        /// Get the HOS (hours of service) signin and signout logs for the specified driver. Only signout logs include location information.
        /// </summary>
        /// <param name="accessToken">Required parameter: Samsara API access token.</param>
        /// <param name="hosAuthenticationLogsParam">Required parameter: Example: </param>
        /// <return>Returns the Models.HosAuthenticationLogsResponse response from the API call</return>
        public async Task<Models.HosAuthenticationLogsResponse> CreateGetFleetHosAuthenticationLogsAsync(string accessToken, Models.HosAuthenticationLogsParam hosAuthenticationLogsParam)
        {
            //the base uri for api requests
            string _baseUri = Configuration.BaseUri;

            //prepare query string for API call
            StringBuilder _queryBuilder = new StringBuilder(_baseUri);
            _queryBuilder.Append("/fleet/hos_authentication_logs");

            //process optional query parameters
            APIHelper.AppendUrlWithQueryParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "access_token", accessToken },
                { "access_token", Configuration.AccessToken }
            },ArrayDeserializationFormat,ParameterSeparator);


            //validate and preprocess url
            string _queryUrl = APIHelper.CleanUrl(_queryBuilder);

            //append request with appropriate headers and parameters
            var _headers = new Dictionary<string,string>()
            {
                { "user-agent", "APIMATIC 2.0" },
                { "accept", "application/json" },
                { "content-type", "application/json; charset=utf-8" }
            };

            //append body params
            var _body = APIHelper.JsonSerialize(hosAuthenticationLogsParam);

            //prepare the API call request to fetch the response
            HttpRequest _request = ClientInstance.PostBody(_queryUrl, _headers, _body);

            //invoke request and get response
            HttpStringResponse _response = (HttpStringResponse) await ClientInstance.ExecuteAsStringAsync(_request).ConfigureAwait(false);
            HttpContext _context = new HttpContext(_request,_response);

            //Error handling using HTTP status codes
            if ((_response.StatusCode < 200) || (_response.StatusCode > 208)) //[200,208] = HTTP OK
                throw new APIException(@"Unexpected error.", _context);

            //handle errors defined at the API level
            base.ValidateResponse(_response, _context);

            try
            {
                return APIHelper.JsonDeserialize<Models.HosAuthenticationLogsResponse>(_response.Body);
            }
            catch (Exception _ex)
            {
                throw new APIException("Failed to parse the response: " + _ex.Message, _context);
            }
        }

        /// <summary>
        /// Get the distance and time each driver in an organization has driven in a given time period.
        /// </summary>
        /// <param name="accessToken">Required parameter: Samsara API access token.</param>
        /// <param name="driversSummaryParam">Required parameter: Org ID and time range to query.</param>
        /// <param name="snapToDayBounds">Optional parameter: Snap query result to HOS day boundaries.</param>
        /// <return>Returns the Models.DriversSummaryResponse response from the API call</return>
        public Models.DriversSummaryResponse CreateGetFleetDriversSummary(string accessToken, Models.DriversSummaryParam driversSummaryParam, bool? snapToDayBounds = null)
        {
            Task<Models.DriversSummaryResponse> t = CreateGetFleetDriversSummaryAsync(accessToken, driversSummaryParam, snapToDayBounds);
            APIHelper.RunTaskSynchronously(t);
            return t.Result;
        }

        /// <summary>
        /// Get the distance and time each driver in an organization has driven in a given time period.
        /// </summary>
        /// <param name="accessToken">Required parameter: Samsara API access token.</param>
        /// <param name="driversSummaryParam">Required parameter: Org ID and time range to query.</param>
        /// <param name="snapToDayBounds">Optional parameter: Snap query result to HOS day boundaries.</param>
        /// <return>Returns the Models.DriversSummaryResponse response from the API call</return>
        public async Task<Models.DriversSummaryResponse> CreateGetFleetDriversSummaryAsync(string accessToken, Models.DriversSummaryParam driversSummaryParam, bool? snapToDayBounds = null)
        {
            //the base uri for api requests
            string _baseUri = Configuration.BaseUri;

            //prepare query string for API call
            StringBuilder _queryBuilder = new StringBuilder(_baseUri);
            _queryBuilder.Append("/fleet/drivers/summary");

            //process optional query parameters
            APIHelper.AppendUrlWithQueryParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "access_token", accessToken },
                { "snap_to_day_bounds", snapToDayBounds },
                { "access_token", Configuration.AccessToken }
            },ArrayDeserializationFormat,ParameterSeparator);


            //validate and preprocess url
            string _queryUrl = APIHelper.CleanUrl(_queryBuilder);

            //append request with appropriate headers and parameters
            var _headers = new Dictionary<string,string>()
            {
                { "user-agent", "APIMATIC 2.0" },
                { "accept", "application/json" },
                { "content-type", "application/json; charset=utf-8" }
            };

            //append body params
            var _body = APIHelper.JsonSerialize(driversSummaryParam);

            //prepare the API call request to fetch the response
            HttpRequest _request = ClientInstance.PostBody(_queryUrl, _headers, _body);

            //invoke request and get response
            HttpStringResponse _response = (HttpStringResponse) await ClientInstance.ExecuteAsStringAsync(_request).ConfigureAwait(false);
            HttpContext _context = new HttpContext(_request,_response);

            //Error handling using HTTP status codes
            if ((_response.StatusCode < 200) || (_response.StatusCode > 208)) //[200,208] = HTTP OK
                throw new APIException(@"Unexpected error.", _context);

            //handle errors defined at the API level
            base.ValidateResponse(_response, _context);

            try
            {
                return APIHelper.JsonDeserialize<Models.DriversSummaryResponse>(_response.Body);
            }
            catch (Exception _ex)
            {
                throw new APIException("Failed to parse the response: " + _ex.Message, _context);
            }
        }

        /// <summary>
        /// Fetch engine state and aux input data for all vehicles in the group between a start/end time. Data returned may be affected by device connectivity and processing time.
        /// </summary>
        /// <param name="accessToken">Required parameter: Samsara API access token.</param>
        /// <param name="startMs">Required parameter: Time in Unix epoch milliseconds for the start of the query.</param>
        /// <param name="endMs">Required parameter: Time in Unix epoch milliseconds for the end of the query.</param>
        /// <param name="series">Optional parameter: Comma-separated list of stat types. Options are engineState, auxInput1, and auxInput2. If this parameter is excluded, all 3 stat types will be returned. Example: series=engineState,auxInput2</param>
        /// <param name="tagIds">Optional parameter: Comma-separated list of tag ids. Example: tagIds=1,2,3</param>
        /// <param name="startingAfter">Optional parameter: Pagination parameter indicating the cursor position to continue returning results after. Used in conjunction with the 'limit' parameter. Mutually exclusive with 'endingBefore' parameter.</param>
        /// <param name="endingBefore">Optional parameter: Pagination parameter indicating the cursor position to return results before. Used in conjunction with the 'limit' parameter. Mutually exclusive with 'startingAfter' parameter.</param>
        /// <param name="limit">Optional parameter: Pagination parameter indicating the number of results to return in this request. Used in conjunction with either 'startingAfter' or 'endingBefore'.</param>
        /// <return>Returns the Models.GetVehicleStatsResponse response from the API call</return>
        public Models.GetVehicleStatsResponse GetVehicleStats(
                string accessToken,
                int startMs,
                int endMs,
                Models.SeriesEnum? series = null,
                string tagIds = null,
                string startingAfter = null,
                string endingBefore = null,
                long? limit = null)
        {
            Task<Models.GetVehicleStatsResponse> t = GetVehicleStatsAsync(accessToken, startMs, endMs, series, tagIds, startingAfter, endingBefore, limit);
            APIHelper.RunTaskSynchronously(t);
            return t.Result;
        }

        /// <summary>
        /// Fetch engine state and aux input data for all vehicles in the group between a start/end time. Data returned may be affected by device connectivity and processing time.
        /// </summary>
        /// <param name="accessToken">Required parameter: Samsara API access token.</param>
        /// <param name="startMs">Required parameter: Time in Unix epoch milliseconds for the start of the query.</param>
        /// <param name="endMs">Required parameter: Time in Unix epoch milliseconds for the end of the query.</param>
        /// <param name="series">Optional parameter: Comma-separated list of stat types. Options are engineState, auxInput1, and auxInput2. If this parameter is excluded, all 3 stat types will be returned. Example: series=engineState,auxInput2</param>
        /// <param name="tagIds">Optional parameter: Comma-separated list of tag ids. Example: tagIds=1,2,3</param>
        /// <param name="startingAfter">Optional parameter: Pagination parameter indicating the cursor position to continue returning results after. Used in conjunction with the 'limit' parameter. Mutually exclusive with 'endingBefore' parameter.</param>
        /// <param name="endingBefore">Optional parameter: Pagination parameter indicating the cursor position to return results before. Used in conjunction with the 'limit' parameter. Mutually exclusive with 'startingAfter' parameter.</param>
        /// <param name="limit">Optional parameter: Pagination parameter indicating the number of results to return in this request. Used in conjunction with either 'startingAfter' or 'endingBefore'.</param>
        /// <return>Returns the Models.GetVehicleStatsResponse response from the API call</return>
        public async Task<Models.GetVehicleStatsResponse> GetVehicleStatsAsync(
                string accessToken,
                int startMs,
                int endMs,
                Models.SeriesEnum? series = null,
                string tagIds = null,
                string startingAfter = null,
                string endingBefore = null,
                long? limit = null)
        {
            //the base uri for api requests
            string _baseUri = Configuration.BaseUri;

            //prepare query string for API call
            StringBuilder _queryBuilder = new StringBuilder(_baseUri);
            _queryBuilder.Append("/fleet/vehicles/stats");

            //process optional query parameters
            APIHelper.AppendUrlWithQueryParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "access_token", accessToken },
                { "startMs", startMs },
                { "endMs", endMs },
                { "series", (series.HasValue) ? Models.SeriesEnumHelper.ToValue(series.Value) : null },
                { "tagIds", tagIds },
                { "startingAfter", startingAfter },
                { "endingBefore", endingBefore },
                { "limit", limit },
                { "access_token", Configuration.AccessToken }
            },ArrayDeserializationFormat,ParameterSeparator);


            //validate and preprocess url
            string _queryUrl = APIHelper.CleanUrl(_queryBuilder);

            //append request with appropriate headers and parameters
            var _headers = new Dictionary<string,string>()
            {
                { "user-agent", "APIMATIC 2.0" },
                { "accept", "application/json" }
            };

            //prepare the API call request to fetch the response
            HttpRequest _request = ClientInstance.Get(_queryUrl,_headers);

            //invoke request and get response
            HttpStringResponse _response = (HttpStringResponse) await ClientInstance.ExecuteAsStringAsync(_request).ConfigureAwait(false);
            HttpContext _context = new HttpContext(_request,_response);

            //Error handling using HTTP status codes
            if ((_response.StatusCode < 200) || (_response.StatusCode > 208)) //[200,208] = HTTP OK
                throw new APIException(@"Unexpected error.", _context);

            //handle errors defined at the API level
            base.ValidateResponse(_response, _context);

            try
            {
                return APIHelper.JsonDeserialize<Models.GetVehicleStatsResponse>(_response.Body);
            }
            catch (Exception _ex)
            {
                throw new APIException("Failed to parse the response: " + _ex.Message, _context);
            }
        }

        /// <summary>
        /// Reactivate the inactive driver having id.
        /// </summary>
        /// <param name="reactivateDriverParam">Required parameter: Driver reactivation body</param>
        /// <param name="accessToken">Required parameter: Samsara API access token.</param>
        /// <param name="driverIdOrExternalId">Required parameter: ID of the driver.  This must be either the numeric ID generated by Samsara or the external ID of the driver.  External IDs are customer specified key-value pairs.</param>
        /// <return>Returns the Models.Driver response from the API call</return>
        public Models.Driver UpdateReactivateDriverById(Models.ReactivateDriverParam reactivateDriverParam, string accessToken, string driverIdOrExternalId)
        {
            Task<Models.Driver> t = UpdateReactivateDriverByIdAsync(reactivateDriverParam, accessToken, driverIdOrExternalId);
            APIHelper.RunTaskSynchronously(t);
            return t.Result;
        }

        /// <summary>
        /// Reactivate the inactive driver having id.
        /// </summary>
        /// <param name="reactivateDriverParam">Required parameter: Driver reactivation body</param>
        /// <param name="accessToken">Required parameter: Samsara API access token.</param>
        /// <param name="driverIdOrExternalId">Required parameter: ID of the driver.  This must be either the numeric ID generated by Samsara or the external ID of the driver.  External IDs are customer specified key-value pairs.</param>
        /// <return>Returns the Models.Driver response from the API call</return>
        public async Task<Models.Driver> UpdateReactivateDriverByIdAsync(Models.ReactivateDriverParam reactivateDriverParam, string accessToken, string driverIdOrExternalId)
        {
            //the base uri for api requests
            string _baseUri = Configuration.BaseUri;

            //prepare query string for API call
            StringBuilder _queryBuilder = new StringBuilder(_baseUri);
            _queryBuilder.Append("/fleet/drivers/inactive/{driver_id_or_external_id}");

            //process optional template parameters
            APIHelper.AppendUrlWithTemplateParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "driver_id_or_external_id", driverIdOrExternalId }
            });

            //process optional query parameters
            APIHelper.AppendUrlWithQueryParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "access_token", accessToken },
                { "access_token", Configuration.AccessToken }
            },ArrayDeserializationFormat,ParameterSeparator);


            //validate and preprocess url
            string _queryUrl = APIHelper.CleanUrl(_queryBuilder);

            //append request with appropriate headers and parameters
            var _headers = new Dictionary<string,string>()
            {
                { "user-agent", "APIMATIC 2.0" },
                { "accept", "application/json" },
                { "content-type", "application/json; charset=utf-8" }
            };

            //append body params
            var _body = APIHelper.JsonSerialize(reactivateDriverParam);

            //prepare the API call request to fetch the response
            HttpRequest _request = ClientInstance.PutBody(_queryUrl, _headers, _body);

            //invoke request and get response
            HttpStringResponse _response = (HttpStringResponse) await ClientInstance.ExecuteAsStringAsync(_request).ConfigureAwait(false);
            HttpContext _context = new HttpContext(_request,_response);

            //Error handling using HTTP status codes
            if ((_response.StatusCode < 200) || (_response.StatusCode > 208)) //[200,208] = HTTP OK
                throw new APIException(@"Unexpected error.", _context);

            //handle errors defined at the API level
            base.ValidateResponse(_response, _context);

            try
            {
                return APIHelper.JsonDeserialize<Models.Driver>(_response.Body);
            }
            catch (Exception _ex)
            {
                throw new APIException("Failed to parse the response: " + _ex.Message, _context);
            }
        }

        /// <summary>
        /// Fetch all of the documents.
        /// </summary>
        /// <param name="accessToken">Required parameter: Samsara API access token.</param>
        /// <param name="endMs">Optional parameter: Time in unix milliseconds that represents the oldest documents to return. Used in combination with durationMs. Defaults to now.</param>
        /// <param name="durationMs">Optional parameter: Time in milliseconds that represents the duration before endMs to query. Defaults to 24 hours.</param>
        /// <return>Returns the List<Models.Document> response from the API call</return>
        public List<Models.Document> GetDriverDocumentsByOrgId(string accessToken, long? endMs = null, long? durationMs = null)
        {
            Task<List<Models.Document>> t = GetDriverDocumentsByOrgIdAsync(accessToken, endMs, durationMs);
            APIHelper.RunTaskSynchronously(t);
            return t.Result;
        }

        /// <summary>
        /// Fetch all of the documents.
        /// </summary>
        /// <param name="accessToken">Required parameter: Samsara API access token.</param>
        /// <param name="endMs">Optional parameter: Time in unix milliseconds that represents the oldest documents to return. Used in combination with durationMs. Defaults to now.</param>
        /// <param name="durationMs">Optional parameter: Time in milliseconds that represents the duration before endMs to query. Defaults to 24 hours.</param>
        /// <return>Returns the List<Models.Document> response from the API call</return>
        public async Task<List<Models.Document>> GetDriverDocumentsByOrgIdAsync(string accessToken, long? endMs = null, long? durationMs = null)
        {
            //the base uri for api requests
            string _baseUri = Configuration.BaseUri;

            //prepare query string for API call
            StringBuilder _queryBuilder = new StringBuilder(_baseUri);
            _queryBuilder.Append("/fleet/drivers/documents");

            //process optional query parameters
            APIHelper.AppendUrlWithQueryParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "access_token", accessToken },
                { "endMs", endMs },
                { "durationMs", durationMs },
                { "access_token", Configuration.AccessToken }
            },ArrayDeserializationFormat,ParameterSeparator);


            //validate and preprocess url
            string _queryUrl = APIHelper.CleanUrl(_queryBuilder);

            //append request with appropriate headers and parameters
            var _headers = new Dictionary<string,string>()
            {
                { "user-agent", "APIMATIC 2.0" },
                { "accept", "application/json" }
            };

            //prepare the API call request to fetch the response
            HttpRequest _request = ClientInstance.Get(_queryUrl,_headers);

            //invoke request and get response
            HttpStringResponse _response = (HttpStringResponse) await ClientInstance.ExecuteAsStringAsync(_request).ConfigureAwait(false);
            HttpContext _context = new HttpContext(_request,_response);

            //Error handling using HTTP status codes
            if ((_response.StatusCode < 200) || (_response.StatusCode > 208)) //[200,208] = HTTP OK
                throw new APIException(@"Unexpected error.", _context);

            //handle errors defined at the API level
            base.ValidateResponse(_response, _context);

            try
            {
                return APIHelper.JsonDeserialize<List<Models.Document>>(_response.Body);
            }
            catch (Exception _ex)
            {
                throw new APIException("Failed to parse the response: " + _ex.Message, _context);
            }
        }

        /// <summary>
        /// Deactivate a driver with the given id.
        /// </summary>
        /// <param name="accessToken">Required parameter: Samsara API access token.</param>
        /// <param name="driverIdOrExternalId">Required parameter: ID of the driver.  This must be either the numeric ID generated by Samsara or the external ID of the driver.  External IDs are customer specified key-value pairs.</param>
        /// <return>Returns the void response from the API call</return>
        public void DeleteDeactivateDriver(string accessToken, string driverIdOrExternalId)
        {
            Task t = DeleteDeactivateDriverAsync(accessToken, driverIdOrExternalId);
            APIHelper.RunTaskSynchronously(t);
        }

        /// <summary>
        /// Deactivate a driver with the given id.
        /// </summary>
        /// <param name="accessToken">Required parameter: Samsara API access token.</param>
        /// <param name="driverIdOrExternalId">Required parameter: ID of the driver.  This must be either the numeric ID generated by Samsara or the external ID of the driver.  External IDs are customer specified key-value pairs.</param>
        /// <return>Returns the void response from the API call</return>
        public async Task DeleteDeactivateDriverAsync(string accessToken, string driverIdOrExternalId)
        {
            //the base uri for api requests
            string _baseUri = Configuration.BaseUri;

            //prepare query string for API call
            StringBuilder _queryBuilder = new StringBuilder(_baseUri);
            _queryBuilder.Append("/fleet/drivers/{driver_id_or_external_id}");

            //process optional template parameters
            APIHelper.AppendUrlWithTemplateParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "driver_id_or_external_id", driverIdOrExternalId }
            });

            //process optional query parameters
            APIHelper.AppendUrlWithQueryParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "access_token", accessToken },
                { "access_token", Configuration.AccessToken }
            },ArrayDeserializationFormat,ParameterSeparator);


            //validate and preprocess url
            string _queryUrl = APIHelper.CleanUrl(_queryBuilder);

            //append request with appropriate headers and parameters
            var _headers = new Dictionary<string,string>()
            {
                { "user-agent", "APIMATIC 2.0" }
            };

            //prepare the API call request to fetch the response
            HttpRequest _request = ClientInstance.Delete(_queryUrl, _headers, null);

            //invoke request and get response
            HttpStringResponse _response = (HttpStringResponse) await ClientInstance.ExecuteAsStringAsync(_request).ConfigureAwait(false);
            HttpContext _context = new HttpContext(_request,_response);

            //Error handling using HTTP status codes
            if ((_response.StatusCode < 200) || (_response.StatusCode > 208)) //[200,208] = HTTP OK
                throw new APIException(@"Unexpected error.", _context);

            //handle errors defined at the API level
            base.ValidateResponse(_response, _context);

        }

        /// <summary>
        /// Fetch the history of a dispatch route.
        /// </summary>
        /// <param name="accessToken">Required parameter: Samsara API access token.</param>
        /// <param name="routeId">Required parameter: ID of the route with history.</param>
        /// <param name="startTime">Optional parameter: Timestamp representing the start of the period to fetch, inclusive. Used in combination with end_time. Defaults to 0.</param>
        /// <param name="endTime">Optional parameter: Timestamp representing the end of the period to fetch, inclusive. Used in combination with start_time. Defaults to nowMs.</param>
        /// <return>Returns the Models.DispatchRouteHistory response from the API call</return>
        public Models.DispatchRouteHistory GetDispatchRouteHistory(
                string accessToken,
                long routeId,
                long? startTime = null,
                long? endTime = null)
        {
            Task<Models.DispatchRouteHistory> t = GetDispatchRouteHistoryAsync(accessToken, routeId, startTime, endTime);
            APIHelper.RunTaskSynchronously(t);
            return t.Result;
        }

        /// <summary>
        /// Fetch the history of a dispatch route.
        /// </summary>
        /// <param name="accessToken">Required parameter: Samsara API access token.</param>
        /// <param name="routeId">Required parameter: ID of the route with history.</param>
        /// <param name="startTime">Optional parameter: Timestamp representing the start of the period to fetch, inclusive. Used in combination with end_time. Defaults to 0.</param>
        /// <param name="endTime">Optional parameter: Timestamp representing the end of the period to fetch, inclusive. Used in combination with start_time. Defaults to nowMs.</param>
        /// <return>Returns the Models.DispatchRouteHistory response from the API call</return>
        public async Task<Models.DispatchRouteHistory> GetDispatchRouteHistoryAsync(
                string accessToken,
                long routeId,
                long? startTime = null,
                long? endTime = null)
        {
            //the base uri for api requests
            string _baseUri = Configuration.BaseUri;

            //prepare query string for API call
            StringBuilder _queryBuilder = new StringBuilder(_baseUri);
            _queryBuilder.Append("/fleet/dispatch/routes/{route_id}/history");

            //process optional template parameters
            APIHelper.AppendUrlWithTemplateParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "route_id", routeId }
            });

            //process optional query parameters
            APIHelper.AppendUrlWithQueryParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "access_token", accessToken },
                { "start_time", startTime },
                { "end_time", endTime },
                { "access_token", Configuration.AccessToken }
            },ArrayDeserializationFormat,ParameterSeparator);


            //validate and preprocess url
            string _queryUrl = APIHelper.CleanUrl(_queryBuilder);

            //append request with appropriate headers and parameters
            var _headers = new Dictionary<string,string>()
            {
                { "user-agent", "APIMATIC 2.0" },
                { "accept", "application/json" }
            };

            //prepare the API call request to fetch the response
            HttpRequest _request = ClientInstance.Get(_queryUrl,_headers);

            //invoke request and get response
            HttpStringResponse _response = (HttpStringResponse) await ClientInstance.ExecuteAsStringAsync(_request).ConfigureAwait(false);
            HttpContext _context = new HttpContext(_request,_response);

            //Error handling using HTTP status codes
            if ((_response.StatusCode < 200) || (_response.StatusCode > 208)) //[200,208] = HTTP OK
                throw new APIException(@"Unexpected error.", _context);

            //handle errors defined at the API level
            base.ValidateResponse(_response, _context);

            try
            {
                return APIHelper.JsonDeserialize<Models.DispatchRouteHistory>(_response.Body);
            }
            catch (Exception _ex)
            {
                throw new APIException("Failed to parse the response: " + _ex.Message, _context);
            }
        }

        /// <summary>
        /// Update a dispatch route and its associated jobs.
        /// </summary>
        /// <param name="updateDispatchRouteParams">Required parameter: Example: </param>
        /// <param name="accessToken">Required parameter: Samsara API access token.</param>
        /// <param name="routeId">Required parameter: ID of the dispatch route.</param>
        /// <return>Returns the Models.DispatchRoute response from the API call</return>
        public Models.DispatchRoute UpdateDispatchRouteById(Models.DispatchRoute updateDispatchRouteParams, string accessToken, long routeId)
        {
            Task<Models.DispatchRoute> t = UpdateDispatchRouteByIdAsync(updateDispatchRouteParams, accessToken, routeId);
            APIHelper.RunTaskSynchronously(t);
            return t.Result;
        }

        /// <summary>
        /// Update a dispatch route and its associated jobs.
        /// </summary>
        /// <param name="updateDispatchRouteParams">Required parameter: Example: </param>
        /// <param name="accessToken">Required parameter: Samsara API access token.</param>
        /// <param name="routeId">Required parameter: ID of the dispatch route.</param>
        /// <return>Returns the Models.DispatchRoute response from the API call</return>
        public async Task<Models.DispatchRoute> UpdateDispatchRouteByIdAsync(Models.DispatchRoute updateDispatchRouteParams, string accessToken, long routeId)
        {
            //the base uri for api requests
            string _baseUri = Configuration.BaseUri;

            //prepare query string for API call
            StringBuilder _queryBuilder = new StringBuilder(_baseUri);
            _queryBuilder.Append("/fleet/dispatch/routes/{route_id}");

            //process optional template parameters
            APIHelper.AppendUrlWithTemplateParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "route_id", routeId }
            });

            //process optional query parameters
            APIHelper.AppendUrlWithQueryParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "access_token", accessToken },
                { "access_token", Configuration.AccessToken }
            },ArrayDeserializationFormat,ParameterSeparator);


            //validate and preprocess url
            string _queryUrl = APIHelper.CleanUrl(_queryBuilder);

            //append request with appropriate headers and parameters
            var _headers = new Dictionary<string,string>()
            {
                { "user-agent", "APIMATIC 2.0" },
                { "accept", "application/json" },
                { "content-type", "application/json; charset=utf-8" }
            };

            //append body params
            var _body = APIHelper.JsonSerialize(updateDispatchRouteParams);

            //prepare the API call request to fetch the response
            HttpRequest _request = ClientInstance.PutBody(_queryUrl, _headers, _body);

            //invoke request and get response
            HttpStringResponse _response = (HttpStringResponse) await ClientInstance.ExecuteAsStringAsync(_request).ConfigureAwait(false);
            HttpContext _context = new HttpContext(_request,_response);

            //Error handling using HTTP status codes
            if ((_response.StatusCode < 200) || (_response.StatusCode > 208)) //[200,208] = HTTP OK
                throw new APIException(@"Unexpected error.", _context);

            //handle errors defined at the API level
            base.ValidateResponse(_response, _context);

            try
            {
                return APIHelper.JsonDeserialize<Models.DispatchRoute>(_response.Body);
            }
            catch (Exception _ex)
            {
                throw new APIException("Failed to parse the response: " + _ex.Message, _context);
            }
        }

        /// <summary>
        /// Fetch all updates to a job including route data in the last 24 hours or subsequent to an sequence ID
        /// </summary>
        /// <param name="accessToken">Required parameter: Samsara API access token.</param>
        /// <param name="groupId">Optional parameter: Optional group ID if the organization has multiple groups (uncommon).</param>
        /// <param name="sequenceId">Optional parameter: Sequence ID from the response payload of the last request. Defaults to fetching updates from last 24 hours.</param>
        /// <param name="include">Optional parameter: Optionally set include=route to include route object in response payload.</param>
        /// <return>Returns the Models.AllRouteJobUpdates response from the API call</return>
        public Models.AllRouteJobUpdates FetchAllRouteJobUpdates(
                string accessToken,
                long? groupId = null,
                string sequenceId = null,
                string include = null)
        {
            Task<Models.AllRouteJobUpdates> t = FetchAllRouteJobUpdatesAsync(accessToken, groupId, sequenceId, include);
            APIHelper.RunTaskSynchronously(t);
            return t.Result;
        }

        /// <summary>
        /// Fetch all updates to a job including route data in the last 24 hours or subsequent to an sequence ID
        /// </summary>
        /// <param name="accessToken">Required parameter: Samsara API access token.</param>
        /// <param name="groupId">Optional parameter: Optional group ID if the organization has multiple groups (uncommon).</param>
        /// <param name="sequenceId">Optional parameter: Sequence ID from the response payload of the last request. Defaults to fetching updates from last 24 hours.</param>
        /// <param name="include">Optional parameter: Optionally set include=route to include route object in response payload.</param>
        /// <return>Returns the Models.AllRouteJobUpdates response from the API call</return>
        public async Task<Models.AllRouteJobUpdates> FetchAllRouteJobUpdatesAsync(
                string accessToken,
                long? groupId = null,
                string sequenceId = null,
                string include = null)
        {
            //the base uri for api requests
            string _baseUri = Configuration.BaseUri;

            //prepare query string for API call
            StringBuilder _queryBuilder = new StringBuilder(_baseUri);
            _queryBuilder.Append("/fleet/dispatch/routes/job_updates");

            //process optional query parameters
            APIHelper.AppendUrlWithQueryParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "access_token", accessToken },
                { "group_id", groupId },
                { "sequence_id", sequenceId },
                { "include", include },
                { "access_token", Configuration.AccessToken }
            },ArrayDeserializationFormat,ParameterSeparator);


            //validate and preprocess url
            string _queryUrl = APIHelper.CleanUrl(_queryBuilder);

            //append request with appropriate headers and parameters
            var _headers = new Dictionary<string,string>()
            {
                { "user-agent", "APIMATIC 2.0" },
                { "accept", "application/json" }
            };

            //prepare the API call request to fetch the response
            HttpRequest _request = ClientInstance.Get(_queryUrl,_headers);

            //invoke request and get response
            HttpStringResponse _response = (HttpStringResponse) await ClientInstance.ExecuteAsStringAsync(_request).ConfigureAwait(false);
            HttpContext _context = new HttpContext(_request,_response);

            //Error handling using HTTP status codes
            if ((_response.StatusCode < 200) || (_response.StatusCode > 208)) //[200,208] = HTTP OK
                throw new APIException(@"Unexpected error.", _context);

            //handle errors defined at the API level
            base.ValidateResponse(_response, _context);

            try
            {
                return APIHelper.JsonDeserialize<Models.AllRouteJobUpdates>(_response.Body);
            }
            catch (Exception _ex)
            {
                throw new APIException("Failed to parse the response: " + _ex.Message, _context);
            }
        }

        /// <summary>
        /// Fetch all of the dispatch routes for the group.
        /// </summary>
        /// <param name="accessToken">Required parameter: Samsara API access token.</param>
        /// <param name="groupId">Optional parameter: Optional group ID if the organization has multiple groups (uncommon).</param>
        /// <param name="endTime">Optional parameter: Time in unix milliseconds that represents the oldest routes to return. Used in combination with duration. Defaults to now.</param>
        /// <param name="duration">Optional parameter: Time in milliseconds that represents the duration before end_time to query. Defaults to 24 hours.</param>
        /// <return>Returns the List<Models.DispatchRoute> response from the API call</return>
        public List<Models.DispatchRoute> FetchAllDispatchRoutes(
                string accessToken,
                long? groupId = null,
                long? endTime = null,
                long? duration = null)
        {
            Task<List<Models.DispatchRoute>> t = FetchAllDispatchRoutesAsync(accessToken, groupId, endTime, duration);
            APIHelper.RunTaskSynchronously(t);
            return t.Result;
        }

        /// <summary>
        /// Fetch all of the dispatch routes for the group.
        /// </summary>
        /// <param name="accessToken">Required parameter: Samsara API access token.</param>
        /// <param name="groupId">Optional parameter: Optional group ID if the organization has multiple groups (uncommon).</param>
        /// <param name="endTime">Optional parameter: Time in unix milliseconds that represents the oldest routes to return. Used in combination with duration. Defaults to now.</param>
        /// <param name="duration">Optional parameter: Time in milliseconds that represents the duration before end_time to query. Defaults to 24 hours.</param>
        /// <return>Returns the List<Models.DispatchRoute> response from the API call</return>
        public async Task<List<Models.DispatchRoute>> FetchAllDispatchRoutesAsync(
                string accessToken,
                long? groupId = null,
                long? endTime = null,
                long? duration = null)
        {
            //the base uri for api requests
            string _baseUri = Configuration.BaseUri;

            //prepare query string for API call
            StringBuilder _queryBuilder = new StringBuilder(_baseUri);
            _queryBuilder.Append("/fleet/dispatch/routes");

            //process optional query parameters
            APIHelper.AppendUrlWithQueryParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "access_token", accessToken },
                { "group_id", groupId },
                { "end_time", endTime },
                { "duration", duration },
                { "access_token", Configuration.AccessToken }
            },ArrayDeserializationFormat,ParameterSeparator);


            //validate and preprocess url
            string _queryUrl = APIHelper.CleanUrl(_queryBuilder);

            //append request with appropriate headers and parameters
            var _headers = new Dictionary<string,string>()
            {
                { "user-agent", "APIMATIC 2.0" },
                { "accept", "application/json" }
            };

            //prepare the API call request to fetch the response
            HttpRequest _request = ClientInstance.Get(_queryUrl,_headers);

            //invoke request and get response
            HttpStringResponse _response = (HttpStringResponse) await ClientInstance.ExecuteAsStringAsync(_request).ConfigureAwait(false);
            HttpContext _context = new HttpContext(_request,_response);

            //Error handling using HTTP status codes
            if ((_response.StatusCode < 200) || (_response.StatusCode > 208)) //[200,208] = HTTP OK
                throw new APIException(@"Unexpected error.", _context);

            //handle errors defined at the API level
            base.ValidateResponse(_response, _context);

            try
            {
                return APIHelper.JsonDeserialize<List<Models.DispatchRoute>>(_response.Body);
            }
            catch (Exception _ex)
            {
                throw new APIException("Failed to parse the response: " + _ex.Message, _context);
            }
        }

        /// <summary>
        /// Fetch the reefer-specific stats of an asset.
        /// </summary>
        /// <param name="accessToken">Required parameter: Samsara API access token.</param>
        /// <param name="assetId">Required parameter: ID of the asset</param>
        /// <param name="startMs">Required parameter: Timestamp in milliseconds representing the start of the period to fetch, inclusive. Used in combination with endMs.</param>
        /// <param name="endMs">Required parameter: Timestamp in milliseconds representing the end of the period to fetch, inclusive. Used in combination with startMs.</param>
        /// <return>Returns the Models.AssetReeferResponse response from the API call</return>
        public Models.AssetReeferResponse GetAssetReefer(
                string accessToken,
                long assetId,
                long startMs,
                long endMs)
        {
            Task<Models.AssetReeferResponse> t = GetAssetReeferAsync(accessToken, assetId, startMs, endMs);
            APIHelper.RunTaskSynchronously(t);
            return t.Result;
        }

        /// <summary>
        /// Fetch the reefer-specific stats of an asset.
        /// </summary>
        /// <param name="accessToken">Required parameter: Samsara API access token.</param>
        /// <param name="assetId">Required parameter: ID of the asset</param>
        /// <param name="startMs">Required parameter: Timestamp in milliseconds representing the start of the period to fetch, inclusive. Used in combination with endMs.</param>
        /// <param name="endMs">Required parameter: Timestamp in milliseconds representing the end of the period to fetch, inclusive. Used in combination with startMs.</param>
        /// <return>Returns the Models.AssetReeferResponse response from the API call</return>
        public async Task<Models.AssetReeferResponse> GetAssetReeferAsync(
                string accessToken,
                long assetId,
                long startMs,
                long endMs)
        {
            //the base uri for api requests
            string _baseUri = Configuration.BaseUri;

            //prepare query string for API call
            StringBuilder _queryBuilder = new StringBuilder(_baseUri);
            _queryBuilder.Append("/fleet/assets/{asset_id}/reefer");

            //process optional template parameters
            APIHelper.AppendUrlWithTemplateParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "asset_id", assetId }
            });

            //process optional query parameters
            APIHelper.AppendUrlWithQueryParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "access_token", accessToken },
                { "startMs", startMs },
                { "endMs", endMs },
                { "access_token", Configuration.AccessToken }
            },ArrayDeserializationFormat,ParameterSeparator);


            //validate and preprocess url
            string _queryUrl = APIHelper.CleanUrl(_queryBuilder);

            //append request with appropriate headers and parameters
            var _headers = new Dictionary<string,string>()
            {
                { "user-agent", "APIMATIC 2.0" },
                { "accept", "application/json" }
            };

            //prepare the API call request to fetch the response
            HttpRequest _request = ClientInstance.Get(_queryUrl,_headers);

            //invoke request and get response
            HttpStringResponse _response = (HttpStringResponse) await ClientInstance.ExecuteAsStringAsync(_request).ConfigureAwait(false);
            HttpContext _context = new HttpContext(_request,_response);

            //Error handling using HTTP status codes
            if ((_response.StatusCode < 200) || (_response.StatusCode > 208)) //[200,208] = HTTP OK
                throw new APIException(@"Unexpected error.", _context);

            //handle errors defined at the API level
            base.ValidateResponse(_response, _context);

            try
            {
                return APIHelper.JsonDeserialize<Models.AssetReeferResponse>(_response.Body);
            }
            catch (Exception _ex)
            {
                throw new APIException("Failed to parse the response: " + _ex.Message, _context);
            }
        }

        /// <summary>
        /// Fetch the historical locations for the asset.
        /// </summary>
        /// <param name="accessToken">Required parameter: Samsara API access token.</param>
        /// <param name="assetId">Required parameter: ID of the asset</param>
        /// <param name="startMs">Required parameter: Timestamp in milliseconds representing the start of the period to fetch, inclusive. Used in combination with endMs.</param>
        /// <param name="endMs">Required parameter: Timestamp in milliseconds representing the end of the period to fetch, inclusive. Used in combination with startMs.</param>
        /// <return>Returns the List<Models.AssetLocationResponse> response from the API call</return>
        public List<Models.AssetLocationResponse> GetAssetLocation(
                string accessToken,
                long assetId,
                long startMs,
                long endMs)
        {
            Task<List<Models.AssetLocationResponse>> t = GetAssetLocationAsync(accessToken, assetId, startMs, endMs);
            APIHelper.RunTaskSynchronously(t);
            return t.Result;
        }

        /// <summary>
        /// Fetch the historical locations for the asset.
        /// </summary>
        /// <param name="accessToken">Required parameter: Samsara API access token.</param>
        /// <param name="assetId">Required parameter: ID of the asset</param>
        /// <param name="startMs">Required parameter: Timestamp in milliseconds representing the start of the period to fetch, inclusive. Used in combination with endMs.</param>
        /// <param name="endMs">Required parameter: Timestamp in milliseconds representing the end of the period to fetch, inclusive. Used in combination with startMs.</param>
        /// <return>Returns the List<Models.AssetLocationResponse> response from the API call</return>
        public async Task<List<Models.AssetLocationResponse>> GetAssetLocationAsync(
                string accessToken,
                long assetId,
                long startMs,
                long endMs)
        {
            //the base uri for api requests
            string _baseUri = Configuration.BaseUri;

            //prepare query string for API call
            StringBuilder _queryBuilder = new StringBuilder(_baseUri);
            _queryBuilder.Append("/fleet/assets/{asset_id}/locations");

            //process optional template parameters
            APIHelper.AppendUrlWithTemplateParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "asset_id", assetId }
            });

            //process optional query parameters
            APIHelper.AppendUrlWithQueryParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "access_token", accessToken },
                { "startMs", startMs },
                { "endMs", endMs },
                { "access_token", Configuration.AccessToken }
            },ArrayDeserializationFormat,ParameterSeparator);


            //validate and preprocess url
            string _queryUrl = APIHelper.CleanUrl(_queryBuilder);

            //append request with appropriate headers and parameters
            var _headers = new Dictionary<string,string>()
            {
                { "user-agent", "APIMATIC 2.0" },
                { "accept", "application/json" }
            };

            //prepare the API call request to fetch the response
            HttpRequest _request = ClientInstance.Get(_queryUrl,_headers);

            //invoke request and get response
            HttpStringResponse _response = (HttpStringResponse) await ClientInstance.ExecuteAsStringAsync(_request).ConfigureAwait(false);
            HttpContext _context = new HttpContext(_request,_response);

            //Error handling using HTTP status codes
            if ((_response.StatusCode < 200) || (_response.StatusCode > 208)) //[200,208] = HTTP OK
                throw new APIException(@"Unexpected error.", _context);

            //handle errors defined at the API level
            base.ValidateResponse(_response, _context);

            try
            {
                return APIHelper.JsonDeserialize<List<Models.AssetLocationResponse>>(_response.Body);
            }
            catch (Exception _ex)
            {
                throw new APIException("Failed to parse the response: " + _ex.Message, _context);
            }
        }

        /// <summary>
        /// Fetch driver by id.
        /// </summary>
        /// <param name="accessToken">Required parameter: Samsara API access token.</param>
        /// <param name="driverIdOrExternalId">Required parameter: ID of the driver.  This must be either the numeric ID generated by Samsara or the external ID of the driver.  External IDs are customer specified key-value pairs.</param>
        /// <return>Returns the Models.Driver response from the API call</return>
        public Models.Driver GetDriverById(string accessToken, string driverIdOrExternalId)
        {
            Task<Models.Driver> t = GetDriverByIdAsync(accessToken, driverIdOrExternalId);
            APIHelper.RunTaskSynchronously(t);
            return t.Result;
        }

        /// <summary>
        /// Fetch driver by id.
        /// </summary>
        /// <param name="accessToken">Required parameter: Samsara API access token.</param>
        /// <param name="driverIdOrExternalId">Required parameter: ID of the driver.  This must be either the numeric ID generated by Samsara or the external ID of the driver.  External IDs are customer specified key-value pairs.</param>
        /// <return>Returns the Models.Driver response from the API call</return>
        public async Task<Models.Driver> GetDriverByIdAsync(string accessToken, string driverIdOrExternalId)
        {
            //the base uri for api requests
            string _baseUri = Configuration.BaseUri;

            //prepare query string for API call
            StringBuilder _queryBuilder = new StringBuilder(_baseUri);
            _queryBuilder.Append("/fleet/drivers/{driver_id_or_external_id}");

            //process optional template parameters
            APIHelper.AppendUrlWithTemplateParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "driver_id_or_external_id", driverIdOrExternalId }
            });

            //process optional query parameters
            APIHelper.AppendUrlWithQueryParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "access_token", accessToken },
                { "access_token", Configuration.AccessToken }
            },ArrayDeserializationFormat,ParameterSeparator);


            //validate and preprocess url
            string _queryUrl = APIHelper.CleanUrl(_queryBuilder);

            //append request with appropriate headers and parameters
            var _headers = new Dictionary<string,string>()
            {
                { "user-agent", "APIMATIC 2.0" },
                { "accept", "application/json" }
            };

            //prepare the API call request to fetch the response
            HttpRequest _request = ClientInstance.Get(_queryUrl,_headers);

            //invoke request and get response
            HttpStringResponse _response = (HttpStringResponse) await ClientInstance.ExecuteAsStringAsync(_request).ConfigureAwait(false);
            HttpContext _context = new HttpContext(_request,_response);

            //Error handling using HTTP status codes
            if ((_response.StatusCode < 200) || (_response.StatusCode > 208)) //[200,208] = HTTP OK
                throw new APIException(@"Unexpected error.", _context);

            //handle errors defined at the API level
            base.ValidateResponse(_response, _context);

            try
            {
                return APIHelper.JsonDeserialize<Models.Driver>(_response.Body);
            }
            catch (Exception _ex)
            {
                throw new APIException("Failed to parse the response: " + _ex.Message, _context);
            }
        }

        /// <summary>
        /// Fetch deactivated driver by id.
        /// </summary>
        /// <param name="accessToken">Required parameter: Samsara API access token.</param>
        /// <param name="driverIdOrExternalId">Required parameter: ID of the driver.  This must be either the numeric ID generated by Samsara or the external ID of the driver.  External IDs are customer specified key-value pairs.</param>
        /// <return>Returns the Models.Driver response from the API call</return>
        public Models.Driver GetDeactivatedDriverById(string accessToken, string driverIdOrExternalId)
        {
            Task<Models.Driver> t = GetDeactivatedDriverByIdAsync(accessToken, driverIdOrExternalId);
            APIHelper.RunTaskSynchronously(t);
            return t.Result;
        }

        /// <summary>
        /// Fetch deactivated driver by id.
        /// </summary>
        /// <param name="accessToken">Required parameter: Samsara API access token.</param>
        /// <param name="driverIdOrExternalId">Required parameter: ID of the driver.  This must be either the numeric ID generated by Samsara or the external ID of the driver.  External IDs are customer specified key-value pairs.</param>
        /// <return>Returns the Models.Driver response from the API call</return>
        public async Task<Models.Driver> GetDeactivatedDriverByIdAsync(string accessToken, string driverIdOrExternalId)
        {
            //the base uri for api requests
            string _baseUri = Configuration.BaseUri;

            //prepare query string for API call
            StringBuilder _queryBuilder = new StringBuilder(_baseUri);
            _queryBuilder.Append("/fleet/drivers/inactive/{driver_id_or_external_id}");

            //process optional template parameters
            APIHelper.AppendUrlWithTemplateParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "driver_id_or_external_id", driverIdOrExternalId }
            });

            //process optional query parameters
            APIHelper.AppendUrlWithQueryParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "access_token", accessToken },
                { "access_token", Configuration.AccessToken }
            },ArrayDeserializationFormat,ParameterSeparator);


            //validate and preprocess url
            string _queryUrl = APIHelper.CleanUrl(_queryBuilder);

            //append request with appropriate headers and parameters
            var _headers = new Dictionary<string,string>()
            {
                { "user-agent", "APIMATIC 2.0" },
                { "accept", "application/json" }
            };

            //prepare the API call request to fetch the response
            HttpRequest _request = ClientInstance.Get(_queryUrl,_headers);

            //invoke request and get response
            HttpStringResponse _response = (HttpStringResponse) await ClientInstance.ExecuteAsStringAsync(_request).ConfigureAwait(false);
            HttpContext _context = new HttpContext(_request,_response);

            //Error handling using HTTP status codes
            if ((_response.StatusCode < 200) || (_response.StatusCode > 208)) //[200,208] = HTTP OK
                throw new APIException(@"Unexpected error.", _context);

            //handle errors defined at the API level
            base.ValidateResponse(_response, _context);

            try
            {
                return APIHelper.JsonDeserialize<Models.Driver>(_response.Body);
            }
            catch (Exception _ex)
            {
                throw new APIException("Failed to parse the response: " + _ex.Message, _context);
            }
        }

        /// <summary>
        /// Fetch all deactivated drivers for the group.
        /// </summary>
        /// <param name="accessToken">Required parameter: Samsara API access token.</param>
        /// <param name="groupId">Optional parameter: Optional group ID if the organization has multiple groups (uncommon).</param>
        /// <return>Returns the List<Models.Driver> response from the API call</return>
        public List<Models.Driver> GetAllDeactivatedDrivers(string accessToken, long? groupId = null)
        {
            Task<List<Models.Driver>> t = GetAllDeactivatedDriversAsync(accessToken, groupId);
            APIHelper.RunTaskSynchronously(t);
            return t.Result;
        }

        /// <summary>
        /// Fetch all deactivated drivers for the group.
        /// </summary>
        /// <param name="accessToken">Required parameter: Samsara API access token.</param>
        /// <param name="groupId">Optional parameter: Optional group ID if the organization has multiple groups (uncommon).</param>
        /// <return>Returns the List<Models.Driver> response from the API call</return>
        public async Task<List<Models.Driver>> GetAllDeactivatedDriversAsync(string accessToken, long? groupId = null)
        {
            //the base uri for api requests
            string _baseUri = Configuration.BaseUri;

            //prepare query string for API call
            StringBuilder _queryBuilder = new StringBuilder(_baseUri);
            _queryBuilder.Append("/fleet/drivers/inactive");

            //process optional query parameters
            APIHelper.AppendUrlWithQueryParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "access_token", accessToken },
                { "group_id", groupId },
                { "access_token", Configuration.AccessToken }
            },ArrayDeserializationFormat,ParameterSeparator);


            //validate and preprocess url
            string _queryUrl = APIHelper.CleanUrl(_queryBuilder);

            //append request with appropriate headers and parameters
            var _headers = new Dictionary<string,string>()
            {
                { "user-agent", "APIMATIC 2.0" },
                { "accept", "application/json" }
            };

            //prepare the API call request to fetch the response
            HttpRequest _request = ClientInstance.Get(_queryUrl,_headers);

            //invoke request and get response
            HttpStringResponse _response = (HttpStringResponse) await ClientInstance.ExecuteAsStringAsync(_request).ConfigureAwait(false);
            HttpContext _context = new HttpContext(_request,_response);

            //Error handling using HTTP status codes
            if ((_response.StatusCode < 200) || (_response.StatusCode > 208)) //[200,208] = HTTP OK
                throw new APIException(@"Unexpected error.", _context);

            //handle errors defined at the API level
            base.ValidateResponse(_response, _context);

            try
            {
                return APIHelper.JsonDeserialize<List<Models.Driver>>(_response.Body);
            }
            catch (Exception _ex)
            {
                throw new APIException("Failed to parse the response: " + _ex.Message, _context);
            }
        }

        /// <summary>
        /// Create a new driver.
        /// </summary>
        /// <param name="accessToken">Required parameter: Samsara API access token.</param>
        /// <param name="createDriverParam">Required parameter: Driver creation body</param>
        /// <return>Returns the Models.Driver response from the API call</return>
        public Models.Driver CreateDriver(string accessToken, Models.DriverForCreate createDriverParam)
        {
            Task<Models.Driver> t = CreateDriverAsync(accessToken, createDriverParam);
            APIHelper.RunTaskSynchronously(t);
            return t.Result;
        }

        /// <summary>
        /// Create a new driver.
        /// </summary>
        /// <param name="accessToken">Required parameter: Samsara API access token.</param>
        /// <param name="createDriverParam">Required parameter: Driver creation body</param>
        /// <return>Returns the Models.Driver response from the API call</return>
        public async Task<Models.Driver> CreateDriverAsync(string accessToken, Models.DriverForCreate createDriverParam)
        {
            //the base uri for api requests
            string _baseUri = Configuration.BaseUri;

            //prepare query string for API call
            StringBuilder _queryBuilder = new StringBuilder(_baseUri);
            _queryBuilder.Append("/fleet/drivers/create");

            //process optional query parameters
            APIHelper.AppendUrlWithQueryParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "access_token", accessToken },
                { "access_token", Configuration.AccessToken }
            },ArrayDeserializationFormat,ParameterSeparator);


            //validate and preprocess url
            string _queryUrl = APIHelper.CleanUrl(_queryBuilder);

            //append request with appropriate headers and parameters
            var _headers = new Dictionary<string,string>()
            {
                { "user-agent", "APIMATIC 2.0" },
                { "accept", "application/json" },
                { "content-type", "application/json; charset=utf-8" }
            };

            //append body params
            var _body = APIHelper.JsonSerialize(createDriverParam);

            //prepare the API call request to fetch the response
            HttpRequest _request = ClientInstance.PostBody(_queryUrl, _headers, _body);

            //invoke request and get response
            HttpStringResponse _response = (HttpStringResponse) await ClientInstance.ExecuteAsStringAsync(_request).ConfigureAwait(false);
            HttpContext _context = new HttpContext(_request,_response);

            //Error handling using HTTP status codes
            if ((_response.StatusCode < 200) || (_response.StatusCode > 208)) //[200,208] = HTTP OK
                throw new APIException(@"Unexpected error.", _context);

            //handle errors defined at the API level
            base.ValidateResponse(_response, _context);

            try
            {
                return APIHelper.JsonDeserialize<Models.Driver>(_response.Body);
            }
            catch (Exception _ex)
            {
                throw new APIException("Failed to parse the response: " + _ex.Message, _context);
            }
        }

        /// <summary>
        /// Get all the drivers for the specified group.
        /// </summary>
        /// <param name="accessToken">Required parameter: Samsara API access token.</param>
        /// <param name="groupDriversParam">Required parameter: Example: </param>
        /// <return>Returns the Models.DriversResponse response from the API call</return>
        public Models.DriversResponse CreateGetFleetDrivers(string accessToken, Models.GroupDriversParam groupDriversParam)
        {
            Task<Models.DriversResponse> t = CreateGetFleetDriversAsync(accessToken, groupDriversParam);
            APIHelper.RunTaskSynchronously(t);
            return t.Result;
        }

        /// <summary>
        /// Get all the drivers for the specified group.
        /// </summary>
        /// <param name="accessToken">Required parameter: Samsara API access token.</param>
        /// <param name="groupDriversParam">Required parameter: Example: </param>
        /// <return>Returns the Models.DriversResponse response from the API call</return>
        public async Task<Models.DriversResponse> CreateGetFleetDriversAsync(string accessToken, Models.GroupDriversParam groupDriversParam)
        {
            //the base uri for api requests
            string _baseUri = Configuration.BaseUri;

            //prepare query string for API call
            StringBuilder _queryBuilder = new StringBuilder(_baseUri);
            _queryBuilder.Append("/fleet/drivers");

            //process optional query parameters
            APIHelper.AppendUrlWithQueryParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "access_token", accessToken },
                { "access_token", Configuration.AccessToken }
            },ArrayDeserializationFormat,ParameterSeparator);


            //validate and preprocess url
            string _queryUrl = APIHelper.CleanUrl(_queryBuilder);

            //append request with appropriate headers and parameters
            var _headers = new Dictionary<string,string>()
            {
                { "user-agent", "APIMATIC 2.0" },
                { "accept", "application/json" },
                { "content-type", "application/json; charset=utf-8" }
            };

            //append body params
            var _body = APIHelper.JsonSerialize(groupDriversParam);

            //prepare the API call request to fetch the response
            HttpRequest _request = ClientInstance.PostBody(_queryUrl, _headers, _body);

            //invoke request and get response
            HttpStringResponse _response = (HttpStringResponse) await ClientInstance.ExecuteAsStringAsync(_request).ConfigureAwait(false);
            HttpContext _context = new HttpContext(_request,_response);

            //Error handling using HTTP status codes
            if ((_response.StatusCode < 200) || (_response.StatusCode > 208)) //[200,208] = HTTP OK
                throw new APIException(@"Unexpected error.", _context);

            //handle errors defined at the API level
            base.ValidateResponse(_response, _context);

            try
            {
                return APIHelper.JsonDeserialize<Models.DriversResponse>(_response.Body);
            }
            catch (Exception _ex)
            {
                throw new APIException("Failed to parse the response: " + _ex.Message, _context);
            }
        }

        /// <summary>
        /// Delete a dispatch route and its associated jobs.
        /// </summary>
        /// <param name="accessToken">Required parameter: Samsara API access token.</param>
        /// <param name="routeId">Required parameter: ID of the dispatch route.</param>
        /// <return>Returns the void response from the API call</return>
        public void DeleteDispatchRouteById(string accessToken, long routeId)
        {
            Task t = DeleteDispatchRouteByIdAsync(accessToken, routeId);
            APIHelper.RunTaskSynchronously(t);
        }

        /// <summary>
        /// Delete a dispatch route and its associated jobs.
        /// </summary>
        /// <param name="accessToken">Required parameter: Samsara API access token.</param>
        /// <param name="routeId">Required parameter: ID of the dispatch route.</param>
        /// <return>Returns the void response from the API call</return>
        public async Task DeleteDispatchRouteByIdAsync(string accessToken, long routeId)
        {
            //the base uri for api requests
            string _baseUri = Configuration.BaseUri;

            //prepare query string for API call
            StringBuilder _queryBuilder = new StringBuilder(_baseUri);
            _queryBuilder.Append("/fleet/dispatch/routes/{route_id}");

            //process optional template parameters
            APIHelper.AppendUrlWithTemplateParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "route_id", routeId }
            });

            //process optional query parameters
            APIHelper.AppendUrlWithQueryParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "access_token", accessToken },
                { "access_token", Configuration.AccessToken }
            },ArrayDeserializationFormat,ParameterSeparator);


            //validate and preprocess url
            string _queryUrl = APIHelper.CleanUrl(_queryBuilder);

            //append request with appropriate headers and parameters
            var _headers = new Dictionary<string,string>()
            {
                { "user-agent", "APIMATIC 2.0" }
            };

            //prepare the API call request to fetch the response
            HttpRequest _request = ClientInstance.Delete(_queryUrl, _headers, null);

            //invoke request and get response
            HttpStringResponse _response = (HttpStringResponse) await ClientInstance.ExecuteAsStringAsync(_request).ConfigureAwait(false);
            HttpContext _context = new HttpContext(_request,_response);

            //Error handling using HTTP status codes
            if ((_response.StatusCode < 200) || (_response.StatusCode > 208)) //[200,208] = HTTP OK
                throw new APIException(@"Unexpected error.", _context);

            //handle errors defined at the API level
            base.ValidateResponse(_response, _context);

        }

        /// <summary>
        /// Fetch a dispatch route by id.
        /// </summary>
        /// <param name="accessToken">Required parameter: Samsara API access token.</param>
        /// <param name="routeId">Required parameter: ID of the dispatch route.</param>
        /// <return>Returns the Models.DispatchRoute response from the API call</return>
        public Models.DispatchRoute GetDispatchRouteById(string accessToken, long routeId)
        {
            Task<Models.DispatchRoute> t = GetDispatchRouteByIdAsync(accessToken, routeId);
            APIHelper.RunTaskSynchronously(t);
            return t.Result;
        }

        /// <summary>
        /// Fetch a dispatch route by id.
        /// </summary>
        /// <param name="accessToken">Required parameter: Samsara API access token.</param>
        /// <param name="routeId">Required parameter: ID of the dispatch route.</param>
        /// <return>Returns the Models.DispatchRoute response from the API call</return>
        public async Task<Models.DispatchRoute> GetDispatchRouteByIdAsync(string accessToken, long routeId)
        {
            //the base uri for api requests
            string _baseUri = Configuration.BaseUri;

            //prepare query string for API call
            StringBuilder _queryBuilder = new StringBuilder(_baseUri);
            _queryBuilder.Append("/fleet/dispatch/routes/{route_id}");

            //process optional template parameters
            APIHelper.AppendUrlWithTemplateParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "route_id", routeId }
            });

            //process optional query parameters
            APIHelper.AppendUrlWithQueryParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "access_token", accessToken },
                { "access_token", Configuration.AccessToken }
            },ArrayDeserializationFormat,ParameterSeparator);


            //validate and preprocess url
            string _queryUrl = APIHelper.CleanUrl(_queryBuilder);

            //append request with appropriate headers and parameters
            var _headers = new Dictionary<string,string>()
            {
                { "user-agent", "APIMATIC 2.0" },
                { "accept", "application/json" }
            };

            //prepare the API call request to fetch the response
            HttpRequest _request = ClientInstance.Get(_queryUrl,_headers);

            //invoke request and get response
            HttpStringResponse _response = (HttpStringResponse) await ClientInstance.ExecuteAsStringAsync(_request).ConfigureAwait(false);
            HttpContext _context = new HttpContext(_request,_response);

            //Error handling using HTTP status codes
            if ((_response.StatusCode < 200) || (_response.StatusCode > 208)) //[200,208] = HTTP OK
                throw new APIException(@"Unexpected error.", _context);

            //handle errors defined at the API level
            base.ValidateResponse(_response, _context);

            try
            {
                return APIHelper.JsonDeserialize<Models.DispatchRoute>(_response.Body);
            }
            catch (Exception _ex)
            {
                throw new APIException("Failed to parse the response: " + _ex.Message, _context);
            }
        }

        /// <summary>
        /// Create a new dispatch route.
        /// </summary>
        /// <param name="accessToken">Required parameter: Samsara API access token.</param>
        /// <param name="createDispatchRouteParams">Required parameter: Example: </param>
        /// <return>Returns the Models.DispatchRoute response from the API call</return>
        public Models.DispatchRoute CreateDispatchRoute(string accessToken, Models.DispatchRouteCreate createDispatchRouteParams)
        {
            Task<Models.DispatchRoute> t = CreateDispatchRouteAsync(accessToken, createDispatchRouteParams);
            APIHelper.RunTaskSynchronously(t);
            return t.Result;
        }

        /// <summary>
        /// Create a new dispatch route.
        /// </summary>
        /// <param name="accessToken">Required parameter: Samsara API access token.</param>
        /// <param name="createDispatchRouteParams">Required parameter: Example: </param>
        /// <return>Returns the Models.DispatchRoute response from the API call</return>
        public async Task<Models.DispatchRoute> CreateDispatchRouteAsync(string accessToken, Models.DispatchRouteCreate createDispatchRouteParams)
        {
            //the base uri for api requests
            string _baseUri = Configuration.BaseUri;

            //prepare query string for API call
            StringBuilder _queryBuilder = new StringBuilder(_baseUri);
            _queryBuilder.Append("/fleet/dispatch/routes");

            //process optional query parameters
            APIHelper.AppendUrlWithQueryParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "access_token", accessToken },
                { "access_token", Configuration.AccessToken }
            },ArrayDeserializationFormat,ParameterSeparator);


            //validate and preprocess url
            string _queryUrl = APIHelper.CleanUrl(_queryBuilder);

            //append request with appropriate headers and parameters
            var _headers = new Dictionary<string,string>()
            {
                { "user-agent", "APIMATIC 2.0" },
                { "accept", "application/json" },
                { "content-type", "application/json; charset=utf-8" }
            };

            //append body params
            var _body = APIHelper.JsonSerialize(createDispatchRouteParams);

            //prepare the API call request to fetch the response
            HttpRequest _request = ClientInstance.PostBody(_queryUrl, _headers, _body);

            //invoke request and get response
            HttpStringResponse _response = (HttpStringResponse) await ClientInstance.ExecuteAsStringAsync(_request).ConfigureAwait(false);
            HttpContext _context = new HttpContext(_request,_response);

            //Error handling using HTTP status codes
            if ((_response.StatusCode < 200) || (_response.StatusCode > 208)) //[200,208] = HTTP OK
                throw new APIException(@"Unexpected error.", _context);

            //handle errors defined at the API level
            base.ValidateResponse(_response, _context);

            try
            {
                return APIHelper.JsonDeserialize<Models.DispatchRoute>(_response.Body);
            }
            catch (Exception _ex)
            {
                throw new APIException("Failed to parse the response: " + _ex.Message, _context);
            }
        }

        /// <summary>
        /// Fetch current locations of all assets for the group.
        /// </summary>
        /// <param name="accessToken">Required parameter: Samsara API access token.</param>
        /// <return>Returns the Models.GetAllAssetCurrentLocationsResponse response from the API call</return>
        public Models.GetAllAssetCurrentLocationsResponse GetAllAssetCurrentLocations(string accessToken)
        {
            Task<Models.GetAllAssetCurrentLocationsResponse> t = GetAllAssetCurrentLocationsAsync(accessToken);
            APIHelper.RunTaskSynchronously(t);
            return t.Result;
        }

        /// <summary>
        /// Fetch current locations of all assets for the group.
        /// </summary>
        /// <param name="accessToken">Required parameter: Samsara API access token.</param>
        /// <return>Returns the Models.GetAllAssetCurrentLocationsResponse response from the API call</return>
        public async Task<Models.GetAllAssetCurrentLocationsResponse> GetAllAssetCurrentLocationsAsync(string accessToken)
        {
            //the base uri for api requests
            string _baseUri = Configuration.BaseUri;

            //prepare query string for API call
            StringBuilder _queryBuilder = new StringBuilder(_baseUri);
            _queryBuilder.Append("/fleet/assets/locations");

            //process optional query parameters
            APIHelper.AppendUrlWithQueryParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "access_token", accessToken },
                { "access_token", Configuration.AccessToken }
            },ArrayDeserializationFormat,ParameterSeparator);


            //validate and preprocess url
            string _queryUrl = APIHelper.CleanUrl(_queryBuilder);

            //append request with appropriate headers and parameters
            var _headers = new Dictionary<string,string>()
            {
                { "user-agent", "APIMATIC 2.0" },
                { "accept", "application/json" }
            };

            //prepare the API call request to fetch the response
            HttpRequest _request = ClientInstance.Get(_queryUrl,_headers);

            //invoke request and get response
            HttpStringResponse _response = (HttpStringResponse) await ClientInstance.ExecuteAsStringAsync(_request).ConfigureAwait(false);
            HttpContext _context = new HttpContext(_request,_response);

            //Error handling using HTTP status codes
            if ((_response.StatusCode < 200) || (_response.StatusCode > 208)) //[200,208] = HTTP OK
                throw new APIException(@"Unexpected error.", _context);

            //handle errors defined at the API level
            base.ValidateResponse(_response, _context);

            try
            {
                return APIHelper.JsonDeserialize<Models.GetAllAssetCurrentLocationsResponse>(_response.Body);
            }
            catch (Exception _ex)
            {
                throw new APIException("Failed to parse the response: " + _ex.Message, _context);
            }
        }

        /// <summary>
        /// Fetch all of the assets for the group.
        /// </summary>
        /// <param name="accessToken">Required parameter: Samsara API access token.</param>
        /// <return>Returns the Models.GetAllAssetsResponse response from the API call</return>
        public Models.GetAllAssetsResponse GetAllAssets(string accessToken)
        {
            Task<Models.GetAllAssetsResponse> t = GetAllAssetsAsync(accessToken);
            APIHelper.RunTaskSynchronously(t);
            return t.Result;
        }

        /// <summary>
        /// Fetch all of the assets for the group.
        /// </summary>
        /// <param name="accessToken">Required parameter: Samsara API access token.</param>
        /// <return>Returns the Models.GetAllAssetsResponse response from the API call</return>
        public async Task<Models.GetAllAssetsResponse> GetAllAssetsAsync(string accessToken)
        {
            //the base uri for api requests
            string _baseUri = Configuration.BaseUri;

            //prepare query string for API call
            StringBuilder _queryBuilder = new StringBuilder(_baseUri);
            _queryBuilder.Append("/fleet/assets");

            //process optional query parameters
            APIHelper.AppendUrlWithQueryParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "access_token", accessToken },
                { "access_token", Configuration.AccessToken }
            },ArrayDeserializationFormat,ParameterSeparator);


            //validate and preprocess url
            string _queryUrl = APIHelper.CleanUrl(_queryBuilder);

            //append request with appropriate headers and parameters
            var _headers = new Dictionary<string,string>()
            {
                { "user-agent", "APIMATIC 2.0" },
                { "accept", "application/json" }
            };

            //prepare the API call request to fetch the response
            HttpRequest _request = ClientInstance.Get(_queryUrl,_headers);

            //invoke request and get response
            HttpStringResponse _response = (HttpStringResponse) await ClientInstance.ExecuteAsStringAsync(_request).ConfigureAwait(false);
            HttpContext _context = new HttpContext(_request,_response);

            //Error handling using HTTP status codes
            if ((_response.StatusCode < 200) || (_response.StatusCode > 208)) //[200,208] = HTTP OK
                throw new APIException(@"Unexpected error.", _context);

            //handle errors defined at the API level
            base.ValidateResponse(_response, _context);

            try
            {
                return APIHelper.JsonDeserialize<Models.GetAllAssetsResponse>(_response.Body);
            }
            catch (Exception _ex)
            {
                throw new APIException("Failed to parse the response: " + _ex.Message, _context);
            }
        }

        /// <summary>
        /// This method adds an address book entry to the specified group.
        /// </summary>
        /// <param name="accessToken">Required parameter: Samsara API access token.</param>
        /// <param name="addressParam">Required parameter: Example: </param>
        /// <return>Returns the void response from the API call</return>
        public void AddFleetAddress(string accessToken, Models.AddressParam addressParam)
        {
            Task t = AddFleetAddressAsync(accessToken, addressParam);
            APIHelper.RunTaskSynchronously(t);
        }

        /// <summary>
        /// This method adds an address book entry to the specified group.
        /// </summary>
        /// <param name="accessToken">Required parameter: Samsara API access token.</param>
        /// <param name="addressParam">Required parameter: Example: </param>
        /// <return>Returns the void response from the API call</return>
        public async Task AddFleetAddressAsync(string accessToken, Models.AddressParam addressParam)
        {
            //the base uri for api requests
            string _baseUri = Configuration.BaseUri;

            //prepare query string for API call
            StringBuilder _queryBuilder = new StringBuilder(_baseUri);
            _queryBuilder.Append("/fleet/add_address");

            //process optional query parameters
            APIHelper.AppendUrlWithQueryParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "access_token", accessToken },
                { "access_token", Configuration.AccessToken }
            },ArrayDeserializationFormat,ParameterSeparator);


            //validate and preprocess url
            string _queryUrl = APIHelper.CleanUrl(_queryBuilder);

            //append request with appropriate headers and parameters
            var _headers = new Dictionary<string,string>()
            {
                { "user-agent", "APIMATIC 2.0" },
                { "content-type", "application/json; charset=utf-8" }
            };

            //append body params
            var _body = APIHelper.JsonSerialize(addressParam);

            //prepare the API call request to fetch the response
            HttpRequest _request = ClientInstance.PostBody(_queryUrl, _headers, _body);

            //invoke request and get response
            HttpStringResponse _response = (HttpStringResponse) await ClientInstance.ExecuteAsStringAsync(_request).ConfigureAwait(false);
            HttpContext _context = new HttpContext(_request,_response);

            //Error handling using HTTP status codes
            if ((_response.StatusCode < 200) || (_response.StatusCode > 208)) //[200,208] = HTTP OK
                throw new APIException(@"Unexpected error.", _context);

            //handle errors defined at the API level
            base.ValidateResponse(_response, _context);

        }

        /// <summary>
        /// Fetch a contact by its id.
        /// </summary>
        /// <param name="accessToken">Required parameter: Samsara API access token.</param>
        /// <param name="contactId">Required parameter: ID of the contact</param>
        /// <return>Returns the Models.Contact response from the API call</return>
        public Models.Contact GetOrganizationContact(string accessToken, long contactId)
        {
            Task<Models.Contact> t = GetOrganizationContactAsync(accessToken, contactId);
            APIHelper.RunTaskSynchronously(t);
            return t.Result;
        }

        /// <summary>
        /// Fetch a contact by its id.
        /// </summary>
        /// <param name="accessToken">Required parameter: Samsara API access token.</param>
        /// <param name="contactId">Required parameter: ID of the contact</param>
        /// <return>Returns the Models.Contact response from the API call</return>
        public async Task<Models.Contact> GetOrganizationContactAsync(string accessToken, long contactId)
        {
            //the base uri for api requests
            string _baseUri = Configuration.BaseUri;

            //prepare query string for API call
            StringBuilder _queryBuilder = new StringBuilder(_baseUri);
            _queryBuilder.Append("/contacts/{contact_id}");

            //process optional template parameters
            APIHelper.AppendUrlWithTemplateParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "contact_id", contactId }
            });

            //process optional query parameters
            APIHelper.AppendUrlWithQueryParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "access_token", accessToken },
                { "access_token", Configuration.AccessToken }
            },ArrayDeserializationFormat,ParameterSeparator);


            //validate and preprocess url
            string _queryUrl = APIHelper.CleanUrl(_queryBuilder);

            //append request with appropriate headers and parameters
            var _headers = new Dictionary<string,string>()
            {
                { "user-agent", "APIMATIC 2.0" },
                { "accept", "application/json" }
            };

            //prepare the API call request to fetch the response
            HttpRequest _request = ClientInstance.Get(_queryUrl,_headers);

            //invoke request and get response
            HttpStringResponse _response = (HttpStringResponse) await ClientInstance.ExecuteAsStringAsync(_request).ConfigureAwait(false);
            HttpContext _context = new HttpContext(_request,_response);

            //Error handling using HTTP status codes
            if ((_response.StatusCode < 200) || (_response.StatusCode > 208)) //[200,208] = HTTP OK
                throw new APIException(@"Unexpected error.", _context);

            //handle errors defined at the API level
            base.ValidateResponse(_response, _context);

            try
            {
                return APIHelper.JsonDeserialize<Models.Contact>(_response.Body);
            }
            catch (Exception _ex)
            {
                throw new APIException("Failed to parse the response: " + _ex.Message, _context);
            }
        }

        /// <summary>
        /// Fetch all contacts for the organization.
        /// </summary>
        /// <param name="accessToken">Required parameter: Samsara API access token.</param>
        /// <return>Returns the List<Models.Contact> response from the API call</return>
        public List<Models.Contact> ListContacts(string accessToken)
        {
            Task<List<Models.Contact>> t = ListContactsAsync(accessToken);
            APIHelper.RunTaskSynchronously(t);
            return t.Result;
        }

        /// <summary>
        /// Fetch all contacts for the organization.
        /// </summary>
        /// <param name="accessToken">Required parameter: Samsara API access token.</param>
        /// <return>Returns the List<Models.Contact> response from the API call</return>
        public async Task<List<Models.Contact>> ListContactsAsync(string accessToken)
        {
            //the base uri for api requests
            string _baseUri = Configuration.BaseUri;

            //prepare query string for API call
            StringBuilder _queryBuilder = new StringBuilder(_baseUri);
            _queryBuilder.Append("/contacts");

            //process optional query parameters
            APIHelper.AppendUrlWithQueryParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "access_token", accessToken },
                { "access_token", Configuration.AccessToken }
            },ArrayDeserializationFormat,ParameterSeparator);


            //validate and preprocess url
            string _queryUrl = APIHelper.CleanUrl(_queryBuilder);

            //append request with appropriate headers and parameters
            var _headers = new Dictionary<string,string>()
            {
                { "user-agent", "APIMATIC 2.0" },
                { "accept", "application/json" }
            };

            //prepare the API call request to fetch the response
            HttpRequest _request = ClientInstance.Get(_queryUrl,_headers);

            //invoke request and get response
            HttpStringResponse _response = (HttpStringResponse) await ClientInstance.ExecuteAsStringAsync(_request).ConfigureAwait(false);
            HttpContext _context = new HttpContext(_request,_response);

            //Error handling using HTTP status codes
            if ((_response.StatusCode < 200) || (_response.StatusCode > 208)) //[200,208] = HTTP OK
                throw new APIException(@"Unexpected error.", _context);

            //handle errors defined at the API level
            base.ValidateResponse(_response, _context);

            try
            {
                return APIHelper.JsonDeserialize<List<Models.Contact>>(_response.Body);
            }
            catch (Exception _ex)
            {
                throw new APIException("Failed to parse the response: " + _ex.Message, _context);
            }
        }

        /// <summary>
        /// Delete an address.
        /// </summary>
        /// <param name="accessToken">Required parameter: Samsara API access token.</param>
        /// <param name="addressId">Required parameter: ID of the address/geofence</param>
        /// <return>Returns the void response from the API call</return>
        public void DeleteOrganizationAddress(string accessToken, long addressId)
        {
            Task t = DeleteOrganizationAddressAsync(accessToken, addressId);
            APIHelper.RunTaskSynchronously(t);
        }

        /// <summary>
        /// Delete an address.
        /// </summary>
        /// <param name="accessToken">Required parameter: Samsara API access token.</param>
        /// <param name="addressId">Required parameter: ID of the address/geofence</param>
        /// <return>Returns the void response from the API call</return>
        public async Task DeleteOrganizationAddressAsync(string accessToken, long addressId)
        {
            //the base uri for api requests
            string _baseUri = Configuration.BaseUri;

            //prepare query string for API call
            StringBuilder _queryBuilder = new StringBuilder(_baseUri);
            _queryBuilder.Append("/addresses/{addressId}");

            //process optional template parameters
            APIHelper.AppendUrlWithTemplateParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "addressId", addressId }
            });

            //process optional query parameters
            APIHelper.AppendUrlWithQueryParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "access_token", accessToken },
                { "access_token", Configuration.AccessToken }
            },ArrayDeserializationFormat,ParameterSeparator);


            //validate and preprocess url
            string _queryUrl = APIHelper.CleanUrl(_queryBuilder);

            //append request with appropriate headers and parameters
            var _headers = new Dictionary<string,string>()
            {
                { "user-agent", "APIMATIC 2.0" }
            };

            //prepare the API call request to fetch the response
            HttpRequest _request = ClientInstance.Delete(_queryUrl, _headers, null);

            //invoke request and get response
            HttpStringResponse _response = (HttpStringResponse) await ClientInstance.ExecuteAsStringAsync(_request).ConfigureAwait(false);
            HttpContext _context = new HttpContext(_request,_response);

            //Error handling using HTTP status codes
            if ((_response.StatusCode < 200) || (_response.StatusCode > 208)) //[200,208] = HTTP OK
                throw new APIException(@"Unexpected error.", _context);

            //handle errors defined at the API level
            base.ValidateResponse(_response, _context);

        }

        /// <summary>
        /// Fetch an address by its id.
        /// </summary>
        /// <param name="accessToken">Required parameter: Samsara API access token.</param>
        /// <param name="addressId">Required parameter: ID of the address/geofence</param>
        /// <return>Returns the Models.Address response from the API call</return>
        public Models.Address GetOrganizationAddress(string accessToken, long addressId)
        {
            Task<Models.Address> t = GetOrganizationAddressAsync(accessToken, addressId);
            APIHelper.RunTaskSynchronously(t);
            return t.Result;
        }

        /// <summary>
        /// Fetch an address by its id.
        /// </summary>
        /// <param name="accessToken">Required parameter: Samsara API access token.</param>
        /// <param name="addressId">Required parameter: ID of the address/geofence</param>
        /// <return>Returns the Models.Address response from the API call</return>
        public async Task<Models.Address> GetOrganizationAddressAsync(string accessToken, long addressId)
        {
            //the base uri for api requests
            string _baseUri = Configuration.BaseUri;

            //prepare query string for API call
            StringBuilder _queryBuilder = new StringBuilder(_baseUri);
            _queryBuilder.Append("/addresses/{addressId}");

            //process optional template parameters
            APIHelper.AppendUrlWithTemplateParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "addressId", addressId }
            });

            //process optional query parameters
            APIHelper.AppendUrlWithQueryParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "access_token", accessToken },
                { "access_token", Configuration.AccessToken }
            },ArrayDeserializationFormat,ParameterSeparator);


            //validate and preprocess url
            string _queryUrl = APIHelper.CleanUrl(_queryBuilder);

            //append request with appropriate headers and parameters
            var _headers = new Dictionary<string,string>()
            {
                { "user-agent", "APIMATIC 2.0" },
                { "accept", "application/json" }
            };

            //prepare the API call request to fetch the response
            HttpRequest _request = ClientInstance.Get(_queryUrl,_headers);

            //invoke request and get response
            HttpStringResponse _response = (HttpStringResponse) await ClientInstance.ExecuteAsStringAsync(_request).ConfigureAwait(false);
            HttpContext _context = new HttpContext(_request,_response);

            //Error handling using HTTP status codes
            if ((_response.StatusCode < 200) || (_response.StatusCode > 208)) //[200,208] = HTTP OK
                throw new APIException(@"Unexpected error.", _context);

            //handle errors defined at the API level
            base.ValidateResponse(_response, _context);

            try
            {
                return APIHelper.JsonDeserialize<Models.Address>(_response.Body);
            }
            catch (Exception _ex)
            {
                throw new APIException("Failed to parse the response: " + _ex.Message, _context);
            }
        }

        /// <summary>
        /// Update the name, formatted address, geofence, notes, or tag and contact Ids for an address. The set of tags or contacts associated with this address will be updated to exactly match the list of IDs passed in. To remove all tags or contacts from an address, pass an empty list; to remove notes, pass an empty string.
        /// </summary>
        /// <param name="accessToken">Required parameter: Samsara API access token.</param>
        /// <param name="address">Required parameter: Update parts of an address's value. If the geofence 'circle' or 'polygon' key is specified, the update will change the type of geofence accordingly.</param>
        /// <param name="addressId">Required parameter: ID of the address/geofence</param>
        /// <return>Returns the void response from the API call</return>
        public void UpdateOrganizationAddress(string accessToken, Models.Address1 address, long addressId)
        {
            Task t = UpdateOrganizationAddressAsync(accessToken, address, addressId);
            APIHelper.RunTaskSynchronously(t);
        }

        /// <summary>
        /// Update the name, formatted address, geofence, notes, or tag and contact Ids for an address. The set of tags or contacts associated with this address will be updated to exactly match the list of IDs passed in. To remove all tags or contacts from an address, pass an empty list; to remove notes, pass an empty string.
        /// </summary>
        /// <param name="accessToken">Required parameter: Samsara API access token.</param>
        /// <param name="address">Required parameter: Update parts of an address's value. If the geofence 'circle' or 'polygon' key is specified, the update will change the type of geofence accordingly.</param>
        /// <param name="addressId">Required parameter: ID of the address/geofence</param>
        /// <return>Returns the void response from the API call</return>
        public async Task UpdateOrganizationAddressAsync(string accessToken, Models.Address1 address, long addressId)
        {
            //the base uri for api requests
            string _baseUri = Configuration.BaseUri;

            //prepare query string for API call
            StringBuilder _queryBuilder = new StringBuilder(_baseUri);
            _queryBuilder.Append("/addresses/{addressId}");

            //process optional template parameters
            APIHelper.AppendUrlWithTemplateParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "addressId", addressId }
            });

            //process optional query parameters
            APIHelper.AppendUrlWithQueryParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "access_token", accessToken },
                { "access_token", Configuration.AccessToken }
            },ArrayDeserializationFormat,ParameterSeparator);


            //validate and preprocess url
            string _queryUrl = APIHelper.CleanUrl(_queryBuilder);

            //append request with appropriate headers and parameters
            var _headers = new Dictionary<string,string>()
            {
                { "user-agent", "APIMATIC 2.0" },
                { "content-type", "application/json; charset=utf-8" }
            };

            //append body params
            var _body = APIHelper.JsonSerialize(address);

            //prepare the API call request to fetch the response
            HttpRequest _request = ClientInstance.PatchBody(_queryUrl, _headers, _body);

            //invoke request and get response
            HttpStringResponse _response = (HttpStringResponse) await ClientInstance.ExecuteAsStringAsync(_request).ConfigureAwait(false);
            HttpContext _context = new HttpContext(_request,_response);

            //Error handling using HTTP status codes
            if ((_response.StatusCode < 200) || (_response.StatusCode > 208)) //[200,208] = HTTP OK
                throw new APIException(@"Unexpected error.", _context);

            //handle errors defined at the API level
            base.ValidateResponse(_response, _context);

        }

        /// <summary>
        /// Fetch all addresses/geofences for the organization. An address contains either a circle or polygon geofence describing the address boundaries.
        /// </summary>
        /// <param name="accessToken">Required parameter: Samsara API access token.</param>
        /// <return>Returns the List<Models.Address> response from the API call</return>
        public List<Models.Address> GetOrganizationAddresses(string accessToken)
        {
            Task<List<Models.Address>> t = GetOrganizationAddressesAsync(accessToken);
            APIHelper.RunTaskSynchronously(t);
            return t.Result;
        }

        /// <summary>
        /// Fetch all addresses/geofences for the organization. An address contains either a circle or polygon geofence describing the address boundaries.
        /// </summary>
        /// <param name="accessToken">Required parameter: Samsara API access token.</param>
        /// <return>Returns the List<Models.Address> response from the API call</return>
        public async Task<List<Models.Address>> GetOrganizationAddressesAsync(string accessToken)
        {
            //the base uri for api requests
            string _baseUri = Configuration.BaseUri;

            //prepare query string for API call
            StringBuilder _queryBuilder = new StringBuilder(_baseUri);
            _queryBuilder.Append("/addresses");

            //process optional query parameters
            APIHelper.AppendUrlWithQueryParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "access_token", accessToken },
                { "access_token", Configuration.AccessToken }
            },ArrayDeserializationFormat,ParameterSeparator);


            //validate and preprocess url
            string _queryUrl = APIHelper.CleanUrl(_queryBuilder);

            //append request with appropriate headers and parameters
            var _headers = new Dictionary<string,string>()
            {
                { "user-agent", "APIMATIC 2.0" },
                { "accept", "application/json" }
            };

            //prepare the API call request to fetch the response
            HttpRequest _request = ClientInstance.Get(_queryUrl,_headers);

            //invoke request and get response
            HttpStringResponse _response = (HttpStringResponse) await ClientInstance.ExecuteAsStringAsync(_request).ConfigureAwait(false);
            HttpContext _context = new HttpContext(_request,_response);

            //Error handling using HTTP status codes
            if ((_response.StatusCode < 200) || (_response.StatusCode > 208)) //[200,208] = HTTP OK
                throw new APIException(@"Unexpected error.", _context);

            //handle errors defined at the API level
            base.ValidateResponse(_response, _context);

            try
            {
                return APIHelper.JsonDeserialize<List<Models.Address>>(_response.Body);
            }
            catch (Exception _ex)
            {
                throw new APIException("Failed to parse the response: " + _ex.Message, _context);
            }
        }

        /// <summary>
        /// Add one or more addresses to the organization
        /// </summary>
        /// <param name="accessToken">Required parameter: Samsara API access token.</param>
        /// <param name="addresses">Required parameter: List of addresses/geofences to add. Geofences can be circular or a polygon.  For each address, only one of 'circle' or 'polygon' should be provided. If both are provided, the geofence will be saved as a polygon.</param>
        /// <return>Returns the List<Models.Address> response from the API call</return>
        public List<Models.Address> AddOrganizationAddresses(string accessToken, Models.Addresses addresses)
        {
            Task<List<Models.Address>> t = AddOrganizationAddressesAsync(accessToken, addresses);
            APIHelper.RunTaskSynchronously(t);
            return t.Result;
        }

        /// <summary>
        /// Add one or more addresses to the organization
        /// </summary>
        /// <param name="accessToken">Required parameter: Samsara API access token.</param>
        /// <param name="addresses">Required parameter: List of addresses/geofences to add. Geofences can be circular or a polygon.  For each address, only one of 'circle' or 'polygon' should be provided. If both are provided, the geofence will be saved as a polygon.</param>
        /// <return>Returns the List<Models.Address> response from the API call</return>
        public async Task<List<Models.Address>> AddOrganizationAddressesAsync(string accessToken, Models.Addresses addresses)
        {
            //the base uri for api requests
            string _baseUri = Configuration.BaseUri;

            //prepare query string for API call
            StringBuilder _queryBuilder = new StringBuilder(_baseUri);
            _queryBuilder.Append("/addresses");

            //process optional query parameters
            APIHelper.AppendUrlWithQueryParameters(_queryBuilder, new Dictionary<string, object>()
            {
                { "access_token", accessToken },
                { "access_token", Configuration.AccessToken }
            },ArrayDeserializationFormat,ParameterSeparator);


            //validate and preprocess url
            string _queryUrl = APIHelper.CleanUrl(_queryBuilder);

            //append request with appropriate headers and parameters
            var _headers = new Dictionary<string,string>()
            {
                { "user-agent", "APIMATIC 2.0" },
                { "accept", "application/json" },
                { "content-type", "application/json; charset=utf-8" }
            };

            //append body params
            var _body = APIHelper.JsonSerialize(addresses);

            //prepare the API call request to fetch the response
            HttpRequest _request = ClientInstance.PostBody(_queryUrl, _headers, _body);

            //invoke request and get response
            HttpStringResponse _response = (HttpStringResponse) await ClientInstance.ExecuteAsStringAsync(_request).ConfigureAwait(false);
            HttpContext _context = new HttpContext(_request,_response);

            //Error handling using HTTP status codes
            if ((_response.StatusCode < 200) || (_response.StatusCode > 208)) //[200,208] = HTTP OK
                throw new APIException(@"Unexpected error.", _context);

            //handle errors defined at the API level
            base.ValidateResponse(_response, _context);

            try
            {
                return APIHelper.JsonDeserialize<List<Models.Address>>(_response.Body);
            }
            catch (Exception _ex)
            {
                throw new APIException("Failed to parse the response: " + _ex.Message, _context);
            }
        }

    }
} 