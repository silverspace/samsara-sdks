// Models.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation

protocol JSONEncodable {
    func encodeToJSON() -> Any
}

public enum ErrorResponse : Error {
    case HttpError(statusCode: Int, data: Data?, error: Error)
    case DecodeError(response: Data?, decodeError: DecodeError)
}

open class Response<T> {
    open let statusCode: Int
    open let header: [String: String]
    open let body: T?

    public init(statusCode: Int, header: [String: String], body: T?) {
        self.statusCode = statusCode
        self.header = header
        self.body = body
    }

    public convenience init(response: HTTPURLResponse, body: T?) {
        let rawHeader = response.allHeaderFields
        var header = [String:String]()
        for case let (key, value) as (String, String) in rawHeader {
            header[key] = value
        }
        self.init(statusCode: response.statusCode, header: header, body: body)
    }
}

public enum Decoded<ValueType> {
    case success(ValueType)
    case failure(DecodeError)
}

public extension Decoded {
    var value: ValueType? {
        switch self {
        case let .success(value):
            return value
        case .failure:
            return nil
        }
    }
}

public enum DecodeError {
    case typeMismatch(expected: String, actual: String)
    case missingKey(key: String)
    case parseError(message: String)
}

private var once = Int()
class Decoders {
    static fileprivate var decoders = Dictionary<String, ((AnyObject, AnyObject?) -> AnyObject)>()

    static func addDecoder<T>(clazz: T.Type, decoder: @escaping ((AnyObject, AnyObject?) -> Decoded<T>)) {
        let key = "\(T.self)"
        decoders[key] = { decoder($0, $1) as AnyObject }
    }

    static func decode<T>(clazz: T.Type, discriminator: String, source: AnyObject) -> Decoded<T> {
        let key = discriminator
        if let decoder = decoders[key], let value = decoder(source, nil) as? Decoded<T> {
            return value
        } else {
            return .failure(.typeMismatch(expected: String(describing: clazz), actual: String(describing: source)))
        }
    }

    static func decode<T>(clazz: [T].Type, source: AnyObject) -> Decoded<[T]> {
        if let sourceArray = source as? [AnyObject] {
            var values = [T]()
            for sourceValue in sourceArray {
                switch Decoders.decode(clazz: T.self, source: sourceValue, instance: nil) {
                case let .success(value):
                    values.append(value)
                case let .failure(error):
                    return .failure(error)
                }
            }
            return .success(values)
        } else {
            return .failure(.typeMismatch(expected: String(describing: clazz), actual: String(describing: source)))
        }
    }

    static func decode<T>(clazz: T.Type, source: AnyObject) -> Decoded<T> {
        switch Decoders.decode(clazz: T.self, source: source, instance: nil) {
    	    case let .success(value):
                return .success(value)
            case let .failure(error):
                return .failure(error)
        }
    }

    static open func decode<T: RawRepresentable>(clazz: T.Type, source: AnyObject) -> Decoded<T> {
        if let value = source as? T.RawValue {
            if let enumValue = T.init(rawValue: value) {
                return .success(enumValue)
            } else {
                return .failure(.typeMismatch(expected: "A value from the enumeration \(T.self)", actual: "\(value)"))
            }
        } else {
            return .failure(.typeMismatch(expected: "\(T.RawValue.self) matching a case from the enumeration \(T.self)", actual: String(describing: type(of: source))))
        }
    }

    static func decode<T, Key: Hashable>(clazz: [Key:T].Type, source: AnyObject) -> Decoded<[Key:T]> {
        if let sourceDictionary = source as? [Key: AnyObject] {
            var dictionary = [Key:T]()
            for (key, value) in sourceDictionary {
                switch Decoders.decode(clazz: T.self, source: value, instance: nil) {
                case let .success(value):
                    dictionary[key] = value
                case let .failure(error):
                    return .failure(error)
                }
            }
            return .success(dictionary)
        } else {
            return .failure(.typeMismatch(expected: String(describing: clazz), actual: String(describing: source)))
        }
    }

    static func decodeOptional<T: RawRepresentable>(clazz: T.Type, source: AnyObject?) -> Decoded<T?> {
        guard !(source is NSNull), source != nil else { return .success(nil) }
        if let value = source as? T.RawValue {
            if let enumValue = T.init(rawValue: value) {
                return .success(enumValue)
            } else {
                return .failure(.typeMismatch(expected: "A value from the enumeration \(T.self)", actual: "\(value)"))
            }
        } else {
            return .failure(.typeMismatch(expected: "\(T.RawValue.self) matching a case from the enumeration \(T.self)", actual: String(describing: type(of: source))))
        }
    }

    static func decode<T>(clazz: T.Type, source: AnyObject, instance: AnyObject?) -> Decoded<T> {
        initialize()
        if let sourceNumber = source as? NSNumber, let value = sourceNumber.int32Value as? T, T.self is Int32.Type {
            return .success(value)
        }
        if let sourceNumber = source as? NSNumber, let value = sourceNumber.int32Value as? T, T.self is Int64.Type {
     	    return .success(value)
        }
        if let intermediate = source as? String, let value = UUID(uuidString: intermediate) as? T, source is String, T.self is UUID.Type {
            return .success(value)
        }
        if let value = source as? T {
            return .success(value)
        }
        if let intermediate = source as? String, let value = Data(base64Encoded: intermediate) as? T {
            return .success(value)
        }

        let key = "\(T.self)"
        if let decoder = decoders[key], let value = decoder(source, instance) as? Decoded<T> {
           return value
        } else {
            return .failure(.typeMismatch(expected: String(describing: clazz), actual: String(describing: source)))
        }
    }

    //Convert a Decoded so that its value is optional. DO WE STILL NEED THIS?
    static func toOptional<T>(decoded: Decoded<T>) -> Decoded<T?> {
        return .success(decoded.value)
    }

    static func decodeOptional<T>(clazz: T.Type, source: AnyObject?) -> Decoded<T?> {
        if let source = source, !(source is NSNull) {
            switch Decoders.decode(clazz: clazz, source: source, instance: nil) {
            case let .success(value): return .success(value)
            case let .failure(error): return .failure(error)
            }
        } else {
            return .success(nil)
        }
    }

    static func decodeOptional<T>(clazz: [T].Type, source: AnyObject?) -> Decoded<[T]?> where T: RawRepresentable {
        if let source = source as? [AnyObject] {
            var values = [T]()
            for sourceValue in source {
                switch Decoders.decodeOptional(clazz: T.self, source: sourceValue) {
                case let .success(value): if let value = value { values.append(value) }
                case let .failure(error): return .failure(error)
                }
            }
            return .success(values)
        } else {
            return .success(nil)
        }
    }

    static func decodeOptional<T>(clazz: [T].Type, source: AnyObject?) -> Decoded<[T]?> {
        if let source = source as? [AnyObject] {
            var values = [T]()
            for sourceValue in source {
                switch Decoders.decode(clazz: T.self, source: sourceValue, instance: nil) {
                case let .success(value): values.append(value)
                case let .failure(error): return .failure(error)
                }
            }
            return .success(values)
        } else {
            return .success(nil)
        }
    }

    static func decodeOptional<T, Key: Hashable>(clazz: [Key:T].Type, source: AnyObject?) -> Decoded<[Key:T]?> {
        if let sourceDictionary = source as? [Key: AnyObject] {
            var dictionary = [Key:T]()
            for (key, value) in sourceDictionary {
                switch Decoders.decode(clazz: T.self, source: value, instance: nil) {
                case let .success(value): dictionary[key] = value
                case let .failure(error): return .failure(error)
                }
            }
            return .success(dictionary)
        } else {
            return .success(nil)
        }
    }

    static func decodeOptional<T: RawRepresentable, U: AnyObject>(clazz: T, source: AnyObject) -> Decoded<T?> where T.RawValue == U {
        if let value = source as? U {
            if let enumValue = T.init(rawValue: value) {
                return .success(enumValue)
            } else {
                return .failure(.typeMismatch(expected: "A value from the enumeration \(T.self)", actual: "\(value)"))
            }
        } else {
            return .failure(.typeMismatch(expected: "String", actual: String(describing: type(of: source))))
        }
    }


    private static var __once: () = {
        let formatters = [
            "yyyy-MM-dd",
            "yyyy-MM-dd'T'HH:mm:ssZZZZZ",
            "yyyy-MM-dd'T'HH:mm:ss.SSSZZZZZ",
            "yyyy-MM-dd'T'HH:mm:ss'Z'",
            "yyyy-MM-dd'T'HH:mm:ss.SSS",
            "yyyy-MM-dd HH:mm:ss"
        ].map { (format: String) -> DateFormatter in
            let formatter = DateFormatter()
            formatter.locale = Locale(identifier: "en_US_POSIX")
            formatter.dateFormat = format
            return formatter
        }
        // Decoder for Date
        Decoders.addDecoder(clazz: Date.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<Date> in
           if let sourceString = source as? String {
                for formatter in formatters {
                    if let date = formatter.date(from: sourceString) {
                        return .success(date)
                    }
                }
            }
            if let sourceInt = source as? Int {
                // treat as a java date
                return .success(Date(timeIntervalSince1970: Double(sourceInt / 1000) ))
            }
            if source is String || source is Int {
                return .failure(.parseError(message: "Could not decode date"))
            } else {
                return .failure(.typeMismatch(expected: "String or Int", actual: "\(source)"))
            }
        }

        // Decoder for ISOFullDate
        Decoders.addDecoder(clazz: ISOFullDate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ISOFullDate> in
            if let string = source as? String,
               let isoDate = ISOFullDate.from(string: string) {
                return .success(isoDate)
            } else {
            	return .failure(.typeMismatch(expected: "ISO date", actual: "\(source)"))
            }
        }

        // Decoder for [Address]
        Decoders.addDecoder(clazz: [Address].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[Address]> in
            return Decoders.decode(clazz: [Address].self, source: source)
        }

        // Decoder for Address
        Decoders.addDecoder(clazz: Address.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<Address> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? Address() : instance as! Address
                switch Decoders.decodeOptional(clazz: [Contact].self, source: sourceDictionary["contacts"] as AnyObject?) {
                
                case let .success(value): _result.contacts = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["formattedAddress"] as AnyObject?) {
                
                case let .success(value): _result.formattedAddress = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: AddressGeofence.self, source: sourceDictionary["geofence"] as AnyObject?) {
                
                case let .success(value): _result.geofence = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): _result.id = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): _result.name = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["notes"] as AnyObject?) {
                
                case let .success(value): _result.notes = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [TagMetadata].self, source: sourceDictionary["tags"] as AnyObject?) {
                
                case let .success(value): _result.tags = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "Address", actual: "\(source)"))
            }
        }
        // Decoder for [AddressGeofence]
        Decoders.addDecoder(clazz: [AddressGeofence].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[AddressGeofence]> in
            return Decoders.decode(clazz: [AddressGeofence].self, source: source)
        }

        // Decoder for AddressGeofence
        Decoders.addDecoder(clazz: AddressGeofence.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<AddressGeofence> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? AddressGeofence() : instance as! AddressGeofence
                switch Decoders.decodeOptional(clazz: AddressGeofenceCircle.self, source: sourceDictionary["circle"] as AnyObject?) {
                
                case let .success(value): _result.circle = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: AddressGeofencePolygon.self, source: sourceDictionary["polygon"] as AnyObject?) {
                
                case let .success(value): _result.polygon = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "AddressGeofence", actual: "\(source)"))
            }
        }
        // Decoder for [AddressGeofenceCircle]
        Decoders.addDecoder(clazz: [AddressGeofenceCircle].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[AddressGeofenceCircle]> in
            return Decoders.decode(clazz: [AddressGeofenceCircle].self, source: source)
        }

        // Decoder for AddressGeofenceCircle
        Decoders.addDecoder(clazz: AddressGeofenceCircle.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<AddressGeofenceCircle> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? AddressGeofenceCircle() : instance as! AddressGeofenceCircle
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["latitude"] as AnyObject?) {
                
                case let .success(value): _result.latitude = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["radiusMeters"] as AnyObject?) {
                
                case let .success(value): _result.radiusMeters = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["longitude"] as AnyObject?) {
                
                case let .success(value): _result.longitude = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "AddressGeofenceCircle", actual: "\(source)"))
            }
        }
        // Decoder for [AddressGeofencePolygon]
        Decoders.addDecoder(clazz: [AddressGeofencePolygon].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[AddressGeofencePolygon]> in
            return Decoders.decode(clazz: [AddressGeofencePolygon].self, source: source)
        }

        // Decoder for AddressGeofencePolygon
        Decoders.addDecoder(clazz: AddressGeofencePolygon.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<AddressGeofencePolygon> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? AddressGeofencePolygon() : instance as! AddressGeofencePolygon
                switch Decoders.decodeOptional(clazz: [AddressGeofencePolygonVertices].self, source: sourceDictionary["vertices"] as AnyObject?) {
                
                case let .success(value): _result.vertices = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "AddressGeofencePolygon", actual: "\(source)"))
            }
        }
        // Decoder for [AddressGeofencePolygonVertices]
        Decoders.addDecoder(clazz: [AddressGeofencePolygonVertices].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[AddressGeofencePolygonVertices]> in
            return Decoders.decode(clazz: [AddressGeofencePolygonVertices].self, source: source)
        }

        // Decoder for AddressGeofencePolygonVertices
        Decoders.addDecoder(clazz: AddressGeofencePolygonVertices.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<AddressGeofencePolygonVertices> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? AddressGeofencePolygonVertices() : instance as! AddressGeofencePolygonVertices
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["latitude"] as AnyObject?) {
                
                case let .success(value): _result.latitude = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["longitude"] as AnyObject?) {
                
                case let .success(value): _result.longitude = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "AddressGeofencePolygonVertices", actual: "\(source)"))
            }
        }
        // Decoder for [AddressesAddresses]
        Decoders.addDecoder(clazz: [AddressesAddresses].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[AddressesAddresses]> in
            return Decoders.decode(clazz: [AddressesAddresses].self, source: source)
        }

        // Decoder for AddressesAddresses
        Decoders.addDecoder(clazz: AddressesAddresses.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<AddressesAddresses> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? AddressesAddresses() : instance as! AddressesAddresses
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["notes"] as AnyObject?) {
                
                case let .success(value): _result.notes = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["formattedAddress"] as AnyObject?) {
                
                case let .success(value): _result.formattedAddress = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: AddressGeofence.self, source: sourceDictionary["geofence"] as AnyObject?) {
                
                case let .success(value): _result.geofence = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [Int64].self, source: sourceDictionary["tagIds"] as AnyObject?) {
                
                case let .success(value): _result.tagIds = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): _result.name = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [Int64].self, source: sourceDictionary["contactIds"] as AnyObject?) {
                
                case let .success(value): _result.contactIds = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "AddressesAddresses", actual: "\(source)"))
            }
        }
        // Decoder for [AllRouteJobUpdates]
        Decoders.addDecoder(clazz: [AllRouteJobUpdates].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[AllRouteJobUpdates]> in
            return Decoders.decode(clazz: [AllRouteJobUpdates].self, source: source)
        }

        // Decoder for AllRouteJobUpdates
        Decoders.addDecoder(clazz: AllRouteJobUpdates.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<AllRouteJobUpdates> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? AllRouteJobUpdates() : instance as! AllRouteJobUpdates
                switch Decoders.decodeOptional(clazz: [JobUpdateObject].self, source: sourceDictionary["job_updates"] as AnyObject?) {
                
                case let .success(value): _result.jobUpdates = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["sequence_id"] as AnyObject?) {
                
                case let .success(value): _result.sequenceId = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "AllRouteJobUpdates", actual: "\(source)"))
            }
        }
        // Decoder for [Asset]
        Decoders.addDecoder(clazz: [Asset].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[Asset]> in
            return Decoders.decode(clazz: [Asset].self, source: source)
        }

        // Decoder for Asset
        Decoders.addDecoder(clazz: Asset.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<Asset> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? Asset() : instance as! Asset
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["assetSerialNumber"] as AnyObject?) {
                
                case let .success(value): _result.assetSerialNumber = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [AssetCable].self, source: sourceDictionary["cable"] as AnyObject?) {
                
                case let .success(value): _result.cable = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["engineHours"] as AnyObject?) {
                
                case let .success(value): _result.engineHours = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): _result.id = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): _result.name = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "Asset", actual: "\(source)"))
            }
        }
        // Decoder for [AssetCable]
        Decoders.addDecoder(clazz: [AssetCable].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[AssetCable]> in
            return Decoders.decode(clazz: [AssetCable].self, source: source)
        }

        // Decoder for AssetCable
        Decoders.addDecoder(clazz: AssetCable.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<AssetCable> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? AssetCable() : instance as! AssetCable
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["assetType"] as AnyObject?) {
                
                case let .success(value): _result.assetType = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "AssetCable", actual: "\(source)"))
            }
        }
        // Decoder for [AssetCurrentLocation]
        Decoders.addDecoder(clazz: [AssetCurrentLocation].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[AssetCurrentLocation]> in
            return Decoders.decode(clazz: [AssetCurrentLocation].self, source: source)
        }

        // Decoder for AssetCurrentLocation
        Decoders.addDecoder(clazz: AssetCurrentLocation.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<AssetCurrentLocation> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? AssetCurrentLocation() : instance as! AssetCurrentLocation
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["latitude"] as AnyObject?) {
                
                case let .success(value): _result.latitude = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["location"] as AnyObject?) {
                
                case let .success(value): _result.location = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["longitude"] as AnyObject?) {
                
                case let .success(value): _result.longitude = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["speedMilesPerHour"] as AnyObject?) {
                
                case let .success(value): _result.speedMilesPerHour = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["timeMs"] as AnyObject?) {
                
                case let .success(value): _result.timeMs = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "AssetCurrentLocation", actual: "\(source)"))
            }
        }
        // Decoder for [AssetCurrentLocationsResponse]
        Decoders.addDecoder(clazz: [AssetCurrentLocationsResponse].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[AssetCurrentLocationsResponse]> in
            return Decoders.decode(clazz: [AssetCurrentLocationsResponse].self, source: source)
        }

        // Decoder for AssetCurrentLocationsResponse
        Decoders.addDecoder(clazz: AssetCurrentLocationsResponse.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<AssetCurrentLocationsResponse> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? AssetCurrentLocationsResponse() : instance as! AssetCurrentLocationsResponse
                switch Decoders.decodeOptional(clazz: [AssetCable].self, source: sourceDictionary["cable"] as AnyObject?) {
                
                case let .success(value): _result.cable = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["engineHours"] as AnyObject?) {
                
                case let .success(value): _result.engineHours = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): _result.id = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [AssetCurrentLocation].self, source: sourceDictionary["location"] as AnyObject?) {
                
                case let .success(value): _result.location = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): _result.name = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "AssetCurrentLocationsResponse", actual: "\(source)"))
            }
        }
        // Decoder for [AssetReeferResponse]
        Decoders.addDecoder(clazz: [AssetReeferResponse].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[AssetReeferResponse]> in
            return Decoders.decode(clazz: [AssetReeferResponse].self, source: source)
        }

        // Decoder for AssetReeferResponse
        Decoders.addDecoder(clazz: AssetReeferResponse.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<AssetReeferResponse> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? AssetReeferResponse() : instance as! AssetReeferResponse
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["assetType"] as AnyObject?) {
                
                case let .success(value): _result.assetType = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): _result.id = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): _result.name = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: AssetReeferResponseReeferStats.self, source: sourceDictionary["reeferStats"] as AnyObject?) {
                
                case let .success(value): _result.reeferStats = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "AssetReeferResponse", actual: "\(source)"))
            }
        }
        // Decoder for [AssetReeferResponseReeferStats]
        Decoders.addDecoder(clazz: [AssetReeferResponseReeferStats].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[AssetReeferResponseReeferStats]> in
            return Decoders.decode(clazz: [AssetReeferResponseReeferStats].self, source: source)
        }

        // Decoder for AssetReeferResponseReeferStats
        Decoders.addDecoder(clazz: AssetReeferResponseReeferStats.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<AssetReeferResponseReeferStats> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? AssetReeferResponseReeferStats() : instance as! AssetReeferResponseReeferStats
                switch Decoders.decodeOptional(clazz: [AssetReeferResponseReeferStatsFuelPercentage].self, source: sourceDictionary["fuelPercentage"] as AnyObject?) {
                
                case let .success(value): _result.fuelPercentage = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [AssetReeferResponseReeferStatsPowerStatus].self, source: sourceDictionary["powerStatus"] as AnyObject?) {
                
                case let .success(value): _result.powerStatus = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [AssetReeferResponseReeferStatsEngineHours].self, source: sourceDictionary["engineHours"] as AnyObject?) {
                
                case let .success(value): _result.engineHours = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [AssetReeferResponseReeferStatsSetPoint].self, source: sourceDictionary["setPoint"] as AnyObject?) {
                
                case let .success(value): _result.setPoint = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [AssetReeferResponseReeferStatsReturnAirTemp].self, source: sourceDictionary["returnAirTemp"] as AnyObject?) {
                
                case let .success(value): _result.returnAirTemp = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [AssetReeferResponseReeferStatsAlarms1].self, source: sourceDictionary["alarms"] as AnyObject?) {
                
                case let .success(value): _result.alarms = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "AssetReeferResponseReeferStats", actual: "\(source)"))
            }
        }
        // Decoder for [AssetReeferResponseReeferStatsAlarms]
        Decoders.addDecoder(clazz: [AssetReeferResponseReeferStatsAlarms].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[AssetReeferResponseReeferStatsAlarms]> in
            return Decoders.decode(clazz: [AssetReeferResponseReeferStatsAlarms].self, source: source)
        }

        // Decoder for AssetReeferResponseReeferStatsAlarms
        Decoders.addDecoder(clazz: AssetReeferResponseReeferStatsAlarms.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<AssetReeferResponseReeferStatsAlarms> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? AssetReeferResponseReeferStatsAlarms() : instance as! AssetReeferResponseReeferStatsAlarms
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["severity"] as AnyObject?) {
                
                case let .success(value): _result.severity = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["operatorAction"] as AnyObject?) {
                
                case let .success(value): _result.operatorAction = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                
                case let .success(value): _result.description = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["alarmCode"] as AnyObject?) {
                
                case let .success(value): _result.alarmCode = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "AssetReeferResponseReeferStatsAlarms", actual: "\(source)"))
            }
        }
        // Decoder for [AssetReeferResponseReeferStatsAlarms1]
        Decoders.addDecoder(clazz: [AssetReeferResponseReeferStatsAlarms1].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[AssetReeferResponseReeferStatsAlarms1]> in
            return Decoders.decode(clazz: [AssetReeferResponseReeferStatsAlarms1].self, source: source)
        }

        // Decoder for AssetReeferResponseReeferStatsAlarms1
        Decoders.addDecoder(clazz: AssetReeferResponseReeferStatsAlarms1.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<AssetReeferResponseReeferStatsAlarms1> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? AssetReeferResponseReeferStatsAlarms1() : instance as! AssetReeferResponseReeferStatsAlarms1
                switch Decoders.decodeOptional(clazz: [AssetReeferResponseReeferStatsAlarms].self, source: sourceDictionary["alarms"] as AnyObject?) {
                
                case let .success(value): _result.alarms = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["changedAtMs"] as AnyObject?) {
                
                case let .success(value): _result.changedAtMs = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "AssetReeferResponseReeferStatsAlarms1", actual: "\(source)"))
            }
        }
        // Decoder for [AssetReeferResponseReeferStatsEngineHours]
        Decoders.addDecoder(clazz: [AssetReeferResponseReeferStatsEngineHours].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[AssetReeferResponseReeferStatsEngineHours]> in
            return Decoders.decode(clazz: [AssetReeferResponseReeferStatsEngineHours].self, source: source)
        }

        // Decoder for AssetReeferResponseReeferStatsEngineHours
        Decoders.addDecoder(clazz: AssetReeferResponseReeferStatsEngineHours.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<AssetReeferResponseReeferStatsEngineHours> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? AssetReeferResponseReeferStatsEngineHours() : instance as! AssetReeferResponseReeferStatsEngineHours
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["engineHours"] as AnyObject?) {
                
                case let .success(value): _result.engineHours = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["changedAtMs"] as AnyObject?) {
                
                case let .success(value): _result.changedAtMs = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "AssetReeferResponseReeferStatsEngineHours", actual: "\(source)"))
            }
        }
        // Decoder for [AssetReeferResponseReeferStatsFuelPercentage]
        Decoders.addDecoder(clazz: [AssetReeferResponseReeferStatsFuelPercentage].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[AssetReeferResponseReeferStatsFuelPercentage]> in
            return Decoders.decode(clazz: [AssetReeferResponseReeferStatsFuelPercentage].self, source: source)
        }

        // Decoder for AssetReeferResponseReeferStatsFuelPercentage
        Decoders.addDecoder(clazz: AssetReeferResponseReeferStatsFuelPercentage.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<AssetReeferResponseReeferStatsFuelPercentage> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? AssetReeferResponseReeferStatsFuelPercentage() : instance as! AssetReeferResponseReeferStatsFuelPercentage
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["fuelPercentage"] as AnyObject?) {
                
                case let .success(value): _result.fuelPercentage = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["changedAtMs"] as AnyObject?) {
                
                case let .success(value): _result.changedAtMs = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "AssetReeferResponseReeferStatsFuelPercentage", actual: "\(source)"))
            }
        }
        // Decoder for [AssetReeferResponseReeferStatsPowerStatus]
        Decoders.addDecoder(clazz: [AssetReeferResponseReeferStatsPowerStatus].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[AssetReeferResponseReeferStatsPowerStatus]> in
            return Decoders.decode(clazz: [AssetReeferResponseReeferStatsPowerStatus].self, source: source)
        }

        // Decoder for AssetReeferResponseReeferStatsPowerStatus
        Decoders.addDecoder(clazz: AssetReeferResponseReeferStatsPowerStatus.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<AssetReeferResponseReeferStatsPowerStatus> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? AssetReeferResponseReeferStatsPowerStatus() : instance as! AssetReeferResponseReeferStatsPowerStatus
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["changedAtMs"] as AnyObject?) {
                
                case let .success(value): _result.changedAtMs = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["status"] as AnyObject?) {
                
                case let .success(value): _result.status = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "AssetReeferResponseReeferStatsPowerStatus", actual: "\(source)"))
            }
        }
        // Decoder for [AssetReeferResponseReeferStatsReturnAirTemp]
        Decoders.addDecoder(clazz: [AssetReeferResponseReeferStatsReturnAirTemp].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[AssetReeferResponseReeferStatsReturnAirTemp]> in
            return Decoders.decode(clazz: [AssetReeferResponseReeferStatsReturnAirTemp].self, source: source)
        }

        // Decoder for AssetReeferResponseReeferStatsReturnAirTemp
        Decoders.addDecoder(clazz: AssetReeferResponseReeferStatsReturnAirTemp.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<AssetReeferResponseReeferStatsReturnAirTemp> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? AssetReeferResponseReeferStatsReturnAirTemp() : instance as! AssetReeferResponseReeferStatsReturnAirTemp
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["tempInMilliC"] as AnyObject?) {
                
                case let .success(value): _result.tempInMilliC = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["changedAtMs"] as AnyObject?) {
                
                case let .success(value): _result.changedAtMs = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "AssetReeferResponseReeferStatsReturnAirTemp", actual: "\(source)"))
            }
        }
        // Decoder for [AssetReeferResponseReeferStatsSetPoint]
        Decoders.addDecoder(clazz: [AssetReeferResponseReeferStatsSetPoint].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[AssetReeferResponseReeferStatsSetPoint]> in
            return Decoders.decode(clazz: [AssetReeferResponseReeferStatsSetPoint].self, source: source)
        }

        // Decoder for AssetReeferResponseReeferStatsSetPoint
        Decoders.addDecoder(clazz: AssetReeferResponseReeferStatsSetPoint.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<AssetReeferResponseReeferStatsSetPoint> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? AssetReeferResponseReeferStatsSetPoint() : instance as! AssetReeferResponseReeferStatsSetPoint
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["tempInMilliC"] as AnyObject?) {
                
                case let .success(value): _result.tempInMilliC = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["changedAtMs"] as AnyObject?) {
                
                case let .success(value): _result.changedAtMs = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "AssetReeferResponseReeferStatsSetPoint", actual: "\(source)"))
            }
        }
        // Decoder for [AuxInput]
        Decoders.addDecoder(clazz: [AuxInput].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[AuxInput]> in
            return Decoders.decode(clazz: [AuxInput].self, source: source)
        }

        // Decoder for AuxInput
        Decoders.addDecoder(clazz: AuxInput.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<AuxInput> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? AuxInput() : instance as! AuxInput
                switch Decoders.decodeOptional(clazz: Any.self, source: sourceDictionary["timeMs"] as AnyObject?) {
                
                case let .success(value): _result.timeMs = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["value"] as AnyObject?) {
                
                case let .success(value): _result.value = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "AuxInput", actual: "\(source)"))
            }
        }
        // Decoder for [AuxInputSeries]
        Decoders.addDecoder(clazz: [AuxInputSeries].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[AuxInputSeries]> in
            return Decoders.decode(clazz: [AuxInputSeries].self, source: source)
        }

        // Decoder for AuxInputSeries
        Decoders.addDecoder(clazz: AuxInputSeries.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<AuxInputSeries> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? AuxInputSeries() : instance as! AuxInputSeries
                switch Decoders.decodeOptional(clazz: AuxInputSeries.Name.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): _result.name = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [AuxInput].self, source: sourceDictionary["values"] as AnyObject?) {
                
                case let .success(value): _result.values = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "AuxInputSeries", actual: "\(source)"))
            }
        }
        // Decoder for [CargoResponse]
        Decoders.addDecoder(clazz: [CargoResponse].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[CargoResponse]> in
            return Decoders.decode(clazz: [CargoResponse].self, source: source)
        }

        // Decoder for CargoResponse
        Decoders.addDecoder(clazz: CargoResponse.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<CargoResponse> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? CargoResponse() : instance as! CargoResponse
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["groupId"] as AnyObject?) {
                
                case let .success(value): _result.groupId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [CargoResponseSensors].self, source: sourceDictionary["sensors"] as AnyObject?) {
                
                case let .success(value): _result.sensors = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "CargoResponse", actual: "\(source)"))
            }
        }
        // Decoder for [CargoResponseSensors]
        Decoders.addDecoder(clazz: [CargoResponseSensors].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[CargoResponseSensors]> in
            return Decoders.decode(clazz: [CargoResponseSensors].self, source: source)
        }

        // Decoder for CargoResponseSensors
        Decoders.addDecoder(clazz: CargoResponseSensors.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<CargoResponseSensors> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? CargoResponseSensors() : instance as! CargoResponseSensors
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["cargoEmpty"] as AnyObject?) {
                
                case let .success(value): _result.cargoEmpty = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): _result.name = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): _result.id = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "CargoResponseSensors", actual: "\(source)"))
            }
        }
        // Decoder for [Contact]
        Decoders.addDecoder(clazz: [Contact].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[Contact]> in
            return Decoders.decode(clazz: [Contact].self, source: source)
        }

        // Decoder for Contact
        Decoders.addDecoder(clazz: Contact.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<Contact> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? Contact() : instance as! Contact
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["email"] as AnyObject?) {
                
                case let .success(value): _result.email = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["firstName"] as AnyObject?) {
                
                case let .success(value): _result.firstName = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): _result.id = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["lastName"] as AnyObject?) {
                
                case let .success(value): _result.lastName = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["phone"] as AnyObject?) {
                
                case let .success(value): _result.phone = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "Contact", actual: "\(source)"))
            }
        }
        // Decoder for [CurrentDriver]
        Decoders.addDecoder(clazz: [CurrentDriver].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[CurrentDriver]> in
            return Decoders.decode(clazz: [CurrentDriver].self, source: source)
        }

        // Decoder for CurrentDriver
        Decoders.addDecoder(clazz: CurrentDriver.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<CurrentDriver> in
            if let source = source as? CurrentDriver {
                return .success(source)
            } else {
                return .failure(.typeMismatch(expected: "Typealias CurrentDriver", actual: "\(source)"))
            }
        }
        // Decoder for [DataInputHistoryResponse]
        Decoders.addDecoder(clazz: [DataInputHistoryResponse].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[DataInputHistoryResponse]> in
            return Decoders.decode(clazz: [DataInputHistoryResponse].self, source: source)
        }

        // Decoder for DataInputHistoryResponse
        Decoders.addDecoder(clazz: DataInputHistoryResponse.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<DataInputHistoryResponse> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? DataInputHistoryResponse() : instance as! DataInputHistoryResponse
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): _result.id = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): _result.name = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [DataInputHistoryResponsePoints].self, source: sourceDictionary["points"] as AnyObject?) {
                
                case let .success(value): _result.points = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "DataInputHistoryResponse", actual: "\(source)"))
            }
        }
        // Decoder for [DataInputHistoryResponsePoints]
        Decoders.addDecoder(clazz: [DataInputHistoryResponsePoints].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[DataInputHistoryResponsePoints]> in
            return Decoders.decode(clazz: [DataInputHistoryResponsePoints].self, source: source)
        }

        // Decoder for DataInputHistoryResponsePoints
        Decoders.addDecoder(clazz: DataInputHistoryResponsePoints.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<DataInputHistoryResponsePoints> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? DataInputHistoryResponsePoints() : instance as! DataInputHistoryResponsePoints
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["value"] as AnyObject?) {
                
                case let .success(value): _result.value = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["timeMs"] as AnyObject?) {
                
                case let .success(value): _result.timeMs = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "DataInputHistoryResponsePoints", actual: "\(source)"))
            }
        }
        // Decoder for [DispatchJob]
        Decoders.addDecoder(clazz: [DispatchJob].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[DispatchJob]> in
            return Decoders.decode(clazz: [DispatchJob].self, source: source)
        }

        // Decoder for DispatchJob
        Decoders.addDecoder(clazz: DispatchJob.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<DispatchJob> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? DispatchJob() : instance as! DispatchJob
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["arrived_at_ms"] as AnyObject?) {
                
                case let .success(value): _result.arrivedAtMs = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["completed_at_ms"] as AnyObject?) {
                
                case let .success(value): _result.completedAtMs = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["dispatch_route_id"] as AnyObject?) {
                
                case let .success(value): _result.dispatchRouteId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["driver_id"] as AnyObject?) {
                
                case let .success(value): _result.driverId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["en_route_at_ms"] as AnyObject?) {
                
                case let .success(value): _result.enRouteAtMs = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["estimated_arrival_ms"] as AnyObject?) {
                
                case let .success(value): _result.estimatedArrivalMs = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["fleet_viewer_url"] as AnyObject?) {
                
                case let .success(value): _result.fleetViewerUrl = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["group_id"] as AnyObject?) {
                
                case let .success(value): _result.groupId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): _result.id = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: JobStatus.self, source: sourceDictionary["job_state"] as AnyObject?) {
                
                case let .success(value): _result.jobState = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["skipped_at_ms"] as AnyObject?) {
                
                case let .success(value): _result.skippedAtMs = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["vehicle_id"] as AnyObject?) {
                
                case let .success(value): _result.vehicleId = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "DispatchJob", actual: "\(source)"))
            }
        }
        // Decoder for [DispatchJobCreate]
        Decoders.addDecoder(clazz: [DispatchJobCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[DispatchJobCreate]> in
            return Decoders.decode(clazz: [DispatchJobCreate].self, source: source)
        }

        // Decoder for DispatchJobCreate
        Decoders.addDecoder(clazz: DispatchJobCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<DispatchJobCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? DispatchJobCreate() : instance as! DispatchJobCreate
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["destination_address"] as AnyObject?) {
                
                case let .success(value): _result.destinationAddress = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["destination_address_id"] as AnyObject?) {
                
                case let .success(value): _result.destinationAddressId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["destination_lat"] as AnyObject?) {
                
                case let .success(value): _result.destinationLat = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["destination_lng"] as AnyObject?) {
                
                case let .success(value): _result.destinationLng = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["destination_name"] as AnyObject?) {
                
                case let .success(value): _result.destinationName = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["notes"] as AnyObject?) {
                
                case let .success(value): _result.notes = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["scheduled_arrival_time_ms"] as AnyObject?) {
                
                case let .success(value): _result.scheduledArrivalTimeMs = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["scheduled_departure_time_ms"] as AnyObject?) {
                
                case let .success(value): _result.scheduledDepartureTimeMs = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "DispatchJobCreate", actual: "\(source)"))
            }
        }
        // Decoder for [DispatchRoute]
        Decoders.addDecoder(clazz: [DispatchRoute].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[DispatchRoute]> in
            return Decoders.decode(clazz: [DispatchRoute].self, source: source)
        }

        // Decoder for DispatchRoute
        Decoders.addDecoder(clazz: DispatchRoute.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<DispatchRoute> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? DispatchRoute() : instance as! DispatchRoute
                switch Decoders.decodeOptional(clazz: [DispatchJob].self, source: sourceDictionary["dispatch_jobs"] as AnyObject?) {
                
                case let .success(value): _result.dispatchJobs = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): _result.id = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "DispatchRoute", actual: "\(source)"))
            }
        }
        // Decoder for [DispatchRouteBase]
        Decoders.addDecoder(clazz: [DispatchRouteBase].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[DispatchRouteBase]> in
            return Decoders.decode(clazz: [DispatchRouteBase].self, source: source)
        }

        // Decoder for DispatchRouteBase
        Decoders.addDecoder(clazz: DispatchRouteBase.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<DispatchRouteBase> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? DispatchRouteBase() : instance as! DispatchRouteBase
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["actual_end_ms"] as AnyObject?) {
                
                case let .success(value): _result.actualEndMs = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["actual_start_ms"] as AnyObject?) {
                
                case let .success(value): _result.actualStartMs = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["driver_id"] as AnyObject?) {
                
                case let .success(value): _result.driverId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["group_id"] as AnyObject?) {
                
                case let .success(value): _result.groupId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): _result.name = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["scheduled_end_ms"] as AnyObject?) {
                
                case let .success(value): _result.scheduledEndMs = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["scheduled_meters"] as AnyObject?) {
                
                case let .success(value): _result.scheduledMeters = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["scheduled_start_ms"] as AnyObject?) {
                
                case let .success(value): _result.scheduledStartMs = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["start_location_address"] as AnyObject?) {
                
                case let .success(value): _result.startLocationAddress = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["start_location_address_id"] as AnyObject?) {
                
                case let .success(value): _result.startLocationAddressId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["start_location_lat"] as AnyObject?) {
                
                case let .success(value): _result.startLocationLat = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["start_location_lng"] as AnyObject?) {
                
                case let .success(value): _result.startLocationLng = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["start_location_name"] as AnyObject?) {
                
                case let .success(value): _result.startLocationName = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["trailer_id"] as AnyObject?) {
                
                case let .success(value): _result.trailerId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["vehicle_id"] as AnyObject?) {
                
                case let .success(value): _result.vehicleId = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "DispatchRouteBase", actual: "\(source)"))
            }
        }
        // Decoder for [DispatchRouteCreate]
        Decoders.addDecoder(clazz: [DispatchRouteCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[DispatchRouteCreate]> in
            return Decoders.decode(clazz: [DispatchRouteCreate].self, source: source)
        }

        // Decoder for DispatchRouteCreate
        Decoders.addDecoder(clazz: DispatchRouteCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<DispatchRouteCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? DispatchRouteCreate() : instance as! DispatchRouteCreate
                switch Decoders.decodeOptional(clazz: [DispatchJobCreate].self, source: sourceDictionary["dispatch_jobs"] as AnyObject?) {
                
                case let .success(value): _result.dispatchJobs = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "DispatchRouteCreate", actual: "\(source)"))
            }
        }
        // Decoder for [DispatchRouteHistoricalEntry]
        Decoders.addDecoder(clazz: [DispatchRouteHistoricalEntry].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[DispatchRouteHistoricalEntry]> in
            return Decoders.decode(clazz: [DispatchRouteHistoricalEntry].self, source: source)
        }

        // Decoder for DispatchRouteHistoricalEntry
        Decoders.addDecoder(clazz: DispatchRouteHistoricalEntry.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<DispatchRouteHistoricalEntry> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? DispatchRouteHistoricalEntry() : instance as! DispatchRouteHistoricalEntry
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["changed_at_ms"] as AnyObject?) {
                
                case let .success(value): _result.changedAtMs = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: DispatchRoute.self, source: sourceDictionary["route"] as AnyObject?) {
                
                case let .success(value): _result.route = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "DispatchRouteHistoricalEntry", actual: "\(source)"))
            }
        }
        // Decoder for [DispatchRouteHistory]
        Decoders.addDecoder(clazz: [DispatchRouteHistory].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[DispatchRouteHistory]> in
            return Decoders.decode(clazz: [DispatchRouteHistory].self, source: source)
        }

        // Decoder for DispatchRouteHistory
        Decoders.addDecoder(clazz: DispatchRouteHistory.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<DispatchRouteHistory> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? DispatchRouteHistory() : instance as! DispatchRouteHistory
                switch Decoders.decodeOptional(clazz: [DispatchRouteHistoricalEntry].self, source: sourceDictionary["history"] as AnyObject?) {
                
                case let .success(value): _result.history = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "DispatchRouteHistory", actual: "\(source)"))
            }
        }
        // Decoder for [Document]
        Decoders.addDecoder(clazz: [Document].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[Document]> in
            return Decoders.decode(clazz: [Document].self, source: source)
        }

        // Decoder for Document
        Decoders.addDecoder(clazz: Document.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<Document> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? Document() : instance as! Document
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["documentType"] as AnyObject?) {
                
                case let .success(value): _result.documentType = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["driverCreatedAtMs"] as AnyObject?) {
                
                case let .success(value): _result.driverCreatedAtMs = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["driverId"] as AnyObject?) {
                
                case let .success(value): _result.driverId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [DocumentField].self, source: sourceDictionary["fields"] as AnyObject?) {
                
                case let .success(value): _result.fields = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["vehicleId"] as AnyObject?) {
                
                case let .success(value): _result.vehicleId = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "Document", actual: "\(source)"))
            }
        }
        // Decoder for [DocumentBase]
        Decoders.addDecoder(clazz: [DocumentBase].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[DocumentBase]> in
            return Decoders.decode(clazz: [DocumentBase].self, source: source)
        }

        // Decoder for DocumentBase
        Decoders.addDecoder(clazz: DocumentBase.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<DocumentBase> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? DocumentBase() : instance as! DocumentBase
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["dispatchJobId"] as AnyObject?) {
                
                case let .success(value): _result.dispatchJobId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["notes"] as AnyObject?) {
                
                case let .success(value): _result.notes = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "DocumentBase", actual: "\(source)"))
            }
        }
        // Decoder for [DocumentCreate]
        Decoders.addDecoder(clazz: [DocumentCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[DocumentCreate]> in
            return Decoders.decode(clazz: [DocumentCreate].self, source: source)
        }

        // Decoder for DocumentCreate
        Decoders.addDecoder(clazz: DocumentCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<DocumentCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? DocumentCreate() : instance as! DocumentCreate
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["documentTypeUuid"] as AnyObject?) {
                
                case let .success(value): _result.documentTypeUuid = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [DocumentField].self, source: sourceDictionary["fields"] as AnyObject?) {
                
                case let .success(value): _result.fields = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "DocumentCreate", actual: "\(source)"))
            }
        }
        // Decoder for [DocumentField]
        Decoders.addDecoder(clazz: [DocumentField].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[DocumentField]> in
            return Decoders.decode(clazz: [DocumentField].self, source: source)
        }

        // Decoder for DocumentField
        Decoders.addDecoder(clazz: DocumentField.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<DocumentField> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? DocumentField() : instance as! DocumentField
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["label"] as AnyObject?) {
                
                case let .success(value): _result.label = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Any.self, source: sourceDictionary["value"] as AnyObject?) {
                
                case let .success(value): _result.value = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "DocumentField", actual: "\(source)"))
            }
        }
        // Decoder for [DocumentFieldCreate]
        Decoders.addDecoder(clazz: [DocumentFieldCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[DocumentFieldCreate]> in
            return Decoders.decode(clazz: [DocumentFieldCreate].self, source: source)
        }

        // Decoder for DocumentFieldCreate
        Decoders.addDecoder(clazz: DocumentFieldCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<DocumentFieldCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? DocumentFieldCreate() : instance as! DocumentFieldCreate
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["numberValue"] as AnyObject?) {
                
                case let .success(value): _result.numberValue = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [DocumentFieldCreatePhotoValue].self, source: sourceDictionary["photoValue"] as AnyObject?) {
                
                case let .success(value): _result.photoValue = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["stringValue"] as AnyObject?) {
                
                case let .success(value): _result.stringValue = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["valueType"] as AnyObject?) {
                
                case let .success(value): _result.valueType = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "DocumentFieldCreate", actual: "\(source)"))
            }
        }
        // Decoder for [DocumentFieldCreatePhotoValue]
        Decoders.addDecoder(clazz: [DocumentFieldCreatePhotoValue].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[DocumentFieldCreatePhotoValue]> in
            return Decoders.decode(clazz: [DocumentFieldCreatePhotoValue].self, source: source)
        }

        // Decoder for DocumentFieldCreatePhotoValue
        Decoders.addDecoder(clazz: DocumentFieldCreatePhotoValue.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<DocumentFieldCreatePhotoValue> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? DocumentFieldCreatePhotoValue() : instance as! DocumentFieldCreatePhotoValue
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["url"] as AnyObject?) {
                
                case let .success(value): _result.url = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "DocumentFieldCreatePhotoValue", actual: "\(source)"))
            }
        }
        // Decoder for [DocumentFieldType]
        Decoders.addDecoder(clazz: [DocumentFieldType].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[DocumentFieldType]> in
            return Decoders.decode(clazz: [DocumentFieldType].self, source: source)
        }

        // Decoder for DocumentFieldType
        Decoders.addDecoder(clazz: DocumentFieldType.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<DocumentFieldType> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? DocumentFieldType() : instance as! DocumentFieldType
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["label"] as AnyObject?) {
                
                case let .success(value): _result.label = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: DocumentFieldTypeNumberValueTypeMetadata.self, source: sourceDictionary["numberValueTypeMetadata"] as AnyObject?) {
                
                case let .success(value): _result.numberValueTypeMetadata = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["valueType"] as AnyObject?) {
                
                case let .success(value): _result.valueType = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "DocumentFieldType", actual: "\(source)"))
            }
        }
        // Decoder for [DocumentFieldTypeNumberValueTypeMetadata]
        Decoders.addDecoder(clazz: [DocumentFieldTypeNumberValueTypeMetadata].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[DocumentFieldTypeNumberValueTypeMetadata]> in
            return Decoders.decode(clazz: [DocumentFieldTypeNumberValueTypeMetadata].self, source: source)
        }

        // Decoder for DocumentFieldTypeNumberValueTypeMetadata
        Decoders.addDecoder(clazz: DocumentFieldTypeNumberValueTypeMetadata.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<DocumentFieldTypeNumberValueTypeMetadata> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? DocumentFieldTypeNumberValueTypeMetadata() : instance as! DocumentFieldTypeNumberValueTypeMetadata
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["numDecimalPlaces"] as AnyObject?) {
                
                case let .success(value): _result.numDecimalPlaces = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "DocumentFieldTypeNumberValueTypeMetadata", actual: "\(source)"))
            }
        }
        // Decoder for [DocumentType]
        Decoders.addDecoder(clazz: [DocumentType].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[DocumentType]> in
            return Decoders.decode(clazz: [DocumentType].self, source: source)
        }

        // Decoder for DocumentType
        Decoders.addDecoder(clazz: DocumentType.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<DocumentType> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? DocumentType() : instance as! DocumentType
                switch Decoders.decodeOptional(clazz: [Array].self, source: sourceDictionary["fieldTypes"] as AnyObject?) {
                
                case let .success(value): _result.fieldTypes = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): _result.name = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["orgId"] as AnyObject?) {
                
                case let .success(value): _result.orgId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uuid"] as AnyObject?) {
                
                case let .success(value): _result.uuid = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "DocumentType", actual: "\(source)"))
            }
        }
        // Decoder for [DoorResponse]
        Decoders.addDecoder(clazz: [DoorResponse].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[DoorResponse]> in
            return Decoders.decode(clazz: [DoorResponse].self, source: source)
        }

        // Decoder for DoorResponse
        Decoders.addDecoder(clazz: DoorResponse.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<DoorResponse> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? DoorResponse() : instance as! DoorResponse
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["groupId"] as AnyObject?) {
                
                case let .success(value): _result.groupId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [DoorResponseSensors].self, source: sourceDictionary["sensors"] as AnyObject?) {
                
                case let .success(value): _result.sensors = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "DoorResponse", actual: "\(source)"))
            }
        }
        // Decoder for [DoorResponseSensors]
        Decoders.addDecoder(clazz: [DoorResponseSensors].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[DoorResponseSensors]> in
            return Decoders.decode(clazz: [DoorResponseSensors].self, source: source)
        }

        // Decoder for DoorResponseSensors
        Decoders.addDecoder(clazz: DoorResponseSensors.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<DoorResponseSensors> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? DoorResponseSensors() : instance as! DoorResponseSensors
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["doorClosed"] as AnyObject?) {
                
                case let .success(value): _result.doorClosed = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): _result.name = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): _result.id = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "DoorResponseSensors", actual: "\(source)"))
            }
        }
        // Decoder for [Driver]
        Decoders.addDecoder(clazz: [Driver].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[Driver]> in
            return Decoders.decode(clazz: [Driver].self, source: source)
        }

        // Decoder for Driver
        Decoders.addDecoder(clazz: Driver.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<Driver> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? Driver() : instance as! Driver
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): _result.id = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["isDeactivated"] as AnyObject?) {
                
                case let .success(value): _result.isDeactivated = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [TagMetadata].self, source: sourceDictionary["tags"] as AnyObject?) {
                
                case let .success(value): _result.tags = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "Driver", actual: "\(source)"))
            }
        }
        // Decoder for [DriverBase]
        Decoders.addDecoder(clazz: [DriverBase].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[DriverBase]> in
            return Decoders.decode(clazz: [DriverBase].self, source: source)
        }

        // Decoder for DriverBase
        Decoders.addDecoder(clazz: DriverBase.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<DriverBase> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? DriverBase() : instance as! DriverBase
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["eldAdverseWeatherExemptionEnabled"] as AnyObject?) {
                
                case let .success(value): _result.eldAdverseWeatherExemptionEnabled = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["eldBigDayExemptionEnabled"] as AnyObject?) {
                
                case let .success(value): _result.eldBigDayExemptionEnabled = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["eldDayStartHour"] as AnyObject?) {
                
                case let .success(value): _result.eldDayStartHour = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["eldExempt"] as AnyObject?) {
                
                case let .success(value): _result.eldExempt = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["eldExemptReason"] as AnyObject?) {
                
                case let .success(value): _result.eldExemptReason = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["eldPcEnabled"] as AnyObject?) {
                
                case let .success(value): _result.eldPcEnabled = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["eldYmEnabled"] as AnyObject?) {
                
                case let .success(value): _result.eldYmEnabled = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [String:String].self, source: sourceDictionary["externalIds"] as AnyObject?) {
                
                case let .success(value): _result.externalIds = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["groupId"] as AnyObject?) {
                
                case let .success(value): _result.groupId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["licenseNumber"] as AnyObject?) {
                
                case let .success(value): _result.licenseNumber = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["licenseState"] as AnyObject?) {
                
                case let .success(value): _result.licenseState = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): _result.name = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["notes"] as AnyObject?) {
                
                case let .success(value): _result.notes = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["phone"] as AnyObject?) {
                
                case let .success(value): _result.phone = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["username"] as AnyObject?) {
                
                case let .success(value): _result.username = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["vehicleId"] as AnyObject?) {
                
                case let .success(value): _result.vehicleId = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "DriverBase", actual: "\(source)"))
            }
        }
        // Decoder for [DriverDailyLogResponse]
        Decoders.addDecoder(clazz: [DriverDailyLogResponse].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[DriverDailyLogResponse]> in
            return Decoders.decode(clazz: [DriverDailyLogResponse].self, source: source)
        }

        // Decoder for DriverDailyLogResponse
        Decoders.addDecoder(clazz: DriverDailyLogResponse.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<DriverDailyLogResponse> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? DriverDailyLogResponse() : instance as! DriverDailyLogResponse
                switch Decoders.decodeOptional(clazz: [DriverDailyLogResponseDays].self, source: sourceDictionary["days"] as AnyObject?) {
                
                case let .success(value): _result.days = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "DriverDailyLogResponse", actual: "\(source)"))
            }
        }
        // Decoder for [DriverDailyLogResponseDays]
        Decoders.addDecoder(clazz: [DriverDailyLogResponseDays].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[DriverDailyLogResponseDays]> in
            return Decoders.decode(clazz: [DriverDailyLogResponseDays].self, source: source)
        }

        // Decoder for DriverDailyLogResponseDays
        Decoders.addDecoder(clazz: DriverDailyLogResponseDays.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<DriverDailyLogResponseDays> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? DriverDailyLogResponseDays() : instance as! DriverDailyLogResponseDays
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["certifiedAtMs"] as AnyObject?) {
                
                case let .success(value): _result.certifiedAtMs = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["endMs"] as AnyObject?) {
                
                case let .success(value): _result.endMs = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["startMs"] as AnyObject?) {
                
                case let .success(value): _result.startMs = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Any.self, source: sourceDictionary["trailerIds"] as AnyObject?) {
                
                case let .success(value): _result.trailerIds = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["activeHours"] as AnyObject?) {
                
                case let .success(value): _result.activeHours = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["distanceMiles"] as AnyObject?) {
                
                case let .success(value): _result.distanceMiles = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["activeMs"] as AnyObject?) {
                
                case let .success(value): _result.activeMs = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["certified"] as AnyObject?) {
                
                case let .success(value): _result.certified = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Any.self, source: sourceDictionary["vehicleIds"] as AnyObject?) {
                
                case let .success(value): _result.vehicleIds = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "DriverDailyLogResponseDays", actual: "\(source)"))
            }
        }
        // Decoder for [DriverForCreate]
        Decoders.addDecoder(clazz: [DriverForCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[DriverForCreate]> in
            return Decoders.decode(clazz: [DriverForCreate].self, source: source)
        }

        // Decoder for DriverForCreate
        Decoders.addDecoder(clazz: DriverForCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<DriverForCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? DriverForCreate() : instance as! DriverForCreate
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["password"] as AnyObject?) {
                
                case let .success(value): _result.password = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [Int64].self, source: sourceDictionary["tagIds"] as AnyObject?) {
                
                case let .success(value): _result.tagIds = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "DriverForCreate", actual: "\(source)"))
            }
        }
        // Decoder for [DriverSafetyScoreResponse]
        Decoders.addDecoder(clazz: [DriverSafetyScoreResponse].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[DriverSafetyScoreResponse]> in
            return Decoders.decode(clazz: [DriverSafetyScoreResponse].self, source: source)
        }

        // Decoder for DriverSafetyScoreResponse
        Decoders.addDecoder(clazz: DriverSafetyScoreResponse.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<DriverSafetyScoreResponse> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? DriverSafetyScoreResponse() : instance as! DriverSafetyScoreResponse
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["crashCount"] as AnyObject?) {
                
                case let .success(value): _result.crashCount = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["driverId"] as AnyObject?) {
                
                case let .success(value): _result.driverId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["harshAccelCount"] as AnyObject?) {
                
                case let .success(value): _result.harshAccelCount = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["harshBrakingCount"] as AnyObject?) {
                
                case let .success(value): _result.harshBrakingCount = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [SafetyReportHarshEvent].self, source: sourceDictionary["harshEvents"] as AnyObject?) {
                
                case let .success(value): _result.harshEvents = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["harshTurningCount"] as AnyObject?) {
                
                case let .success(value): _result.harshTurningCount = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["safetyScore"] as AnyObject?) {
                
                case let .success(value): _result.safetyScore = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["safetyScoreRank"] as AnyObject?) {
                
                case let .success(value): _result.safetyScoreRank = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["timeOverSpeedLimitMs"] as AnyObject?) {
                
                case let .success(value): _result.timeOverSpeedLimitMs = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["totalDistanceDrivenMeters"] as AnyObject?) {
                
                case let .success(value): _result.totalDistanceDrivenMeters = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["totalHarshEventCount"] as AnyObject?) {
                
                case let .success(value): _result.totalHarshEventCount = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["totalTimeDrivenMs"] as AnyObject?) {
                
                case let .success(value): _result.totalTimeDrivenMs = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "DriverSafetyScoreResponse", actual: "\(source)"))
            }
        }
        // Decoder for [DriversResponse]
        Decoders.addDecoder(clazz: [DriversResponse].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[DriversResponse]> in
            return Decoders.decode(clazz: [DriversResponse].self, source: source)
        }

        // Decoder for DriversResponse
        Decoders.addDecoder(clazz: DriversResponse.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<DriversResponse> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? DriversResponse() : instance as! DriversResponse
                switch Decoders.decodeOptional(clazz: [Driver].self, source: sourceDictionary["drivers"] as AnyObject?) {
                
                case let .success(value): _result.drivers = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "DriversResponse", actual: "\(source)"))
            }
        }
        // Decoder for [DriversSummaryResponse]
        Decoders.addDecoder(clazz: [DriversSummaryResponse].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[DriversSummaryResponse]> in
            return Decoders.decode(clazz: [DriversSummaryResponse].self, source: source)
        }

        // Decoder for DriversSummaryResponse
        Decoders.addDecoder(clazz: DriversSummaryResponse.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<DriversSummaryResponse> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? DriversSummaryResponse() : instance as! DriversSummaryResponse
                switch Decoders.decodeOptional(clazz: [DriversSummaryResponseSummaries].self, source: sourceDictionary["Summaries"] as AnyObject?) {
                
                case let .success(value): _result.summaries = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "DriversSummaryResponse", actual: "\(source)"))
            }
        }
        // Decoder for [DriversSummaryResponseSummaries]
        Decoders.addDecoder(clazz: [DriversSummaryResponseSummaries].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[DriversSummaryResponseSummaries]> in
            return Decoders.decode(clazz: [DriversSummaryResponseSummaries].self, source: source)
        }

        // Decoder for DriversSummaryResponseSummaries
        Decoders.addDecoder(clazz: DriversSummaryResponseSummaries.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<DriversSummaryResponseSummaries> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? DriversSummaryResponseSummaries() : instance as! DriversSummaryResponseSummaries
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["driverId"] as AnyObject?) {
                
                case let .success(value): _result.driverId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["distanceMiles"] as AnyObject?) {
                
                case let .success(value): _result.distanceMiles = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["driveMs"] as AnyObject?) {
                
                case let .success(value): _result.driveMs = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["activeMs"] as AnyObject?) {
                
                case let .success(value): _result.activeMs = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["driverUsername"] as AnyObject?) {
                
                case let .success(value): _result.driverUsername = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["groupId"] as AnyObject?) {
                
                case let .success(value): _result.groupId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["driverName"] as AnyObject?) {
                
                case let .success(value): _result.driverName = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["onDutyMs"] as AnyObject?) {
                
                case let .success(value): _result.onDutyMs = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "DriversSummaryResponseSummaries", actual: "\(source)"))
            }
        }
        // Decoder for [DvirBase]
        Decoders.addDecoder(clazz: [DvirBase].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[DvirBase]> in
            return Decoders.decode(clazz: [DvirBase].self, source: source)
        }

        // Decoder for DvirBase
        Decoders.addDecoder(clazz: DvirBase.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<DvirBase> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? DvirBase() : instance as! DvirBase
                switch Decoders.decodeOptional(clazz: DvirBaseAuthorSignature.self, source: sourceDictionary["authorSignature"] as AnyObject?) {
                
                case let .success(value): _result.authorSignature = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["defectsCorrected"] as AnyObject?) {
                
                case let .success(value): _result.defectsCorrected = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["defectsNeedNotBeCorrected"] as AnyObject?) {
                
                case let .success(value): _result.defectsNeedNotBeCorrected = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): _result.id = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["inspectionType"] as AnyObject?) {
                
                case let .success(value): _result.inspectionType = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["mechanicNotes"] as AnyObject?) {
                
                case let .success(value): _result.mechanicNotes = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: DvirBaseMechanicOrAgentSignature.self, source: sourceDictionary["mechanicOrAgentSignature"] as AnyObject?) {
                
                case let .success(value): _result.mechanicOrAgentSignature = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: DvirBaseNextDriverSignature.self, source: sourceDictionary["nextDriverSignature"] as AnyObject?) {
                
                case let .success(value): _result.nextDriverSignature = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["odometerMiles"] as AnyObject?) {
                
                case let .success(value): _result.odometerMiles = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["timeMs"] as AnyObject?) {
                
                case let .success(value): _result.timeMs = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [DvirBaseTrailerDefects].self, source: sourceDictionary["trailerDefects"] as AnyObject?) {
                
                case let .success(value): _result.trailerDefects = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["trailerId"] as AnyObject?) {
                
                case let .success(value): _result.trailerId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["trailerName"] as AnyObject?) {
                
                case let .success(value): _result.trailerName = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: DvirBaseVehicle.self, source: sourceDictionary["vehicle"] as AnyObject?) {
                
                case let .success(value): _result.vehicle = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["vehicleCondition"] as AnyObject?) {
                
                case let .success(value): _result.vehicleCondition = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [DvirBaseTrailerDefects].self, source: sourceDictionary["vehicleDefects"] as AnyObject?) {
                
                case let .success(value): _result.vehicleDefects = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "DvirBase", actual: "\(source)"))
            }
        }
        // Decoder for [DvirBaseAuthorSignature]
        Decoders.addDecoder(clazz: [DvirBaseAuthorSignature].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[DvirBaseAuthorSignature]> in
            return Decoders.decode(clazz: [DvirBaseAuthorSignature].self, source: source)
        }

        // Decoder for DvirBaseAuthorSignature
        Decoders.addDecoder(clazz: DvirBaseAuthorSignature.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<DvirBaseAuthorSignature> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? DvirBaseAuthorSignature() : instance as! DvirBaseAuthorSignature
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["mechanicUserId"] as AnyObject?) {
                
                case let .success(value): _result.mechanicUserId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["driverId"] as AnyObject?) {
                
                case let .success(value): _result.driverId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): _result.name = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["signedAt"] as AnyObject?) {
                
                case let .success(value): _result.signedAt = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["type"] as AnyObject?) {
                
                case let .success(value): _result.type = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["email"] as AnyObject?) {
                
                case let .success(value): _result.email = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["username"] as AnyObject?) {
                
                case let .success(value): _result.username = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "DvirBaseAuthorSignature", actual: "\(source)"))
            }
        }
        // Decoder for [DvirBaseMechanicOrAgentSignature]
        Decoders.addDecoder(clazz: [DvirBaseMechanicOrAgentSignature].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[DvirBaseMechanicOrAgentSignature]> in
            return Decoders.decode(clazz: [DvirBaseMechanicOrAgentSignature].self, source: source)
        }

        // Decoder for DvirBaseMechanicOrAgentSignature
        Decoders.addDecoder(clazz: DvirBaseMechanicOrAgentSignature.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<DvirBaseMechanicOrAgentSignature> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? DvirBaseMechanicOrAgentSignature() : instance as! DvirBaseMechanicOrAgentSignature
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["mechanicUserId"] as AnyObject?) {
                
                case let .success(value): _result.mechanicUserId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["driverId"] as AnyObject?) {
                
                case let .success(value): _result.driverId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): _result.name = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["signedAt"] as AnyObject?) {
                
                case let .success(value): _result.signedAt = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["type"] as AnyObject?) {
                
                case let .success(value): _result.type = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["email"] as AnyObject?) {
                
                case let .success(value): _result.email = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["username"] as AnyObject?) {
                
                case let .success(value): _result.username = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "DvirBaseMechanicOrAgentSignature", actual: "\(source)"))
            }
        }
        // Decoder for [DvirBaseNextDriverSignature]
        Decoders.addDecoder(clazz: [DvirBaseNextDriverSignature].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[DvirBaseNextDriverSignature]> in
            return Decoders.decode(clazz: [DvirBaseNextDriverSignature].self, source: source)
        }

        // Decoder for DvirBaseNextDriverSignature
        Decoders.addDecoder(clazz: DvirBaseNextDriverSignature.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<DvirBaseNextDriverSignature> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? DvirBaseNextDriverSignature() : instance as! DvirBaseNextDriverSignature
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["driverId"] as AnyObject?) {
                
                case let .success(value): _result.driverId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): _result.name = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["signedAt"] as AnyObject?) {
                
                case let .success(value): _result.signedAt = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["type"] as AnyObject?) {
                
                case let .success(value): _result.type = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["email"] as AnyObject?) {
                
                case let .success(value): _result.email = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["username"] as AnyObject?) {
                
                case let .success(value): _result.username = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "DvirBaseNextDriverSignature", actual: "\(source)"))
            }
        }
        // Decoder for [DvirBaseTrailerDefects]
        Decoders.addDecoder(clazz: [DvirBaseTrailerDefects].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[DvirBaseTrailerDefects]> in
            return Decoders.decode(clazz: [DvirBaseTrailerDefects].self, source: source)
        }

        // Decoder for DvirBaseTrailerDefects
        Decoders.addDecoder(clazz: DvirBaseTrailerDefects.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<DvirBaseTrailerDefects> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? DvirBaseTrailerDefects() : instance as! DvirBaseTrailerDefects
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["comment"] as AnyObject?) {
                
                case let .success(value): _result.comment = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["defectType"] as AnyObject?) {
                
                case let .success(value): _result.defectType = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "DvirBaseTrailerDefects", actual: "\(source)"))
            }
        }
        // Decoder for [DvirBaseVehicle]
        Decoders.addDecoder(clazz: [DvirBaseVehicle].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[DvirBaseVehicle]> in
            return Decoders.decode(clazz: [DvirBaseVehicle].self, source: source)
        }

        // Decoder for DvirBaseVehicle
        Decoders.addDecoder(clazz: DvirBaseVehicle.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<DvirBaseVehicle> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? DvirBaseVehicle() : instance as! DvirBaseVehicle
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): _result.name = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): _result.id = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "DvirBaseVehicle", actual: "\(source)"))
            }
        }
        // Decoder for [DvirListResponse]
        Decoders.addDecoder(clazz: [DvirListResponse].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[DvirListResponse]> in
            return Decoders.decode(clazz: [DvirListResponse].self, source: source)
        }

        // Decoder for DvirListResponse
        Decoders.addDecoder(clazz: DvirListResponse.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<DvirListResponse> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? DvirListResponse() : instance as! DvirListResponse
                switch Decoders.decodeOptional(clazz: [DvirBase].self, source: sourceDictionary["dvirs"] as AnyObject?) {
                
                case let .success(value): _result.dvirs = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "DvirListResponse", actual: "\(source)"))
            }
        }
        // Decoder for [EngineState]
        Decoders.addDecoder(clazz: [EngineState].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[EngineState]> in
            return Decoders.decode(clazz: [EngineState].self, source: source)
        }

        // Decoder for EngineState
        Decoders.addDecoder(clazz: EngineState.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<EngineState> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? EngineState() : instance as! EngineState
                switch Decoders.decodeOptional(clazz: Any.self, source: sourceDictionary["timeMs"] as AnyObject?) {
                
                case let .success(value): _result.timeMs = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: EngineState.Value.self, source: sourceDictionary["value"] as AnyObject?) {
                
                case let .success(value): _result.value = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "EngineState", actual: "\(source)"))
            }
        }
        // Decoder for [FleetVehicleLocation]
        Decoders.addDecoder(clazz: [FleetVehicleLocation].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[FleetVehicleLocation]> in
            return Decoders.decode(clazz: [FleetVehicleLocation].self, source: source)
        }

        // Decoder for FleetVehicleLocation
        Decoders.addDecoder(clazz: FleetVehicleLocation.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<FleetVehicleLocation> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? FleetVehicleLocation() : instance as! FleetVehicleLocation
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["latitude"] as AnyObject?) {
                
                case let .success(value): _result.latitude = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["location"] as AnyObject?) {
                
                case let .success(value): _result.location = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["longitude"] as AnyObject?) {
                
                case let .success(value): _result.longitude = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["speedMilesPerHour"] as AnyObject?) {
                
                case let .success(value): _result.speedMilesPerHour = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["timeMs"] as AnyObject?) {
                
                case let .success(value): _result.timeMs = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "FleetVehicleLocation", actual: "\(source)"))
            }
        }
        // Decoder for [FleetVehicleResponse]
        Decoders.addDecoder(clazz: [FleetVehicleResponse].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[FleetVehicleResponse]> in
            return Decoders.decode(clazz: [FleetVehicleResponse].self, source: source)
        }

        // Decoder for FleetVehicleResponse
        Decoders.addDecoder(clazz: FleetVehicleResponse.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<FleetVehicleResponse> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? FleetVehicleResponse() : instance as! FleetVehicleResponse
                switch Decoders.decodeOptional(clazz: [String:String].self, source: sourceDictionary["externalIds"] as AnyObject?) {
                
                case let .success(value): _result.externalIds = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["harshAccelSetting"] as AnyObject?) {
                
                case let .success(value): _result.harshAccelSetting = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): _result.id = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): _result.name = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: FleetVehicleResponseVehicleInfo.self, source: sourceDictionary["vehicleInfo"] as AnyObject?) {
                
                case let .success(value): _result.vehicleInfo = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "FleetVehicleResponse", actual: "\(source)"))
            }
        }
        // Decoder for [FleetVehicleResponseVehicleInfo]
        Decoders.addDecoder(clazz: [FleetVehicleResponseVehicleInfo].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[FleetVehicleResponseVehicleInfo]> in
            return Decoders.decode(clazz: [FleetVehicleResponseVehicleInfo].self, source: source)
        }

        // Decoder for FleetVehicleResponseVehicleInfo
        Decoders.addDecoder(clazz: FleetVehicleResponseVehicleInfo.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<FleetVehicleResponseVehicleInfo> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? FleetVehicleResponseVehicleInfo() : instance as! FleetVehicleResponseVehicleInfo
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["year"] as AnyObject?) {
                
                case let .success(value): _result.year = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["model"] as AnyObject?) {
                
                case let .success(value): _result.model = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["vin"] as AnyObject?) {
                
                case let .success(value): _result.vin = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["make"] as AnyObject?) {
                
                case let .success(value): _result.make = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "FleetVehicleResponseVehicleInfo", actual: "\(source)"))
            }
        }
        // Decoder for [HosAuthenticationLogsResponse]
        Decoders.addDecoder(clazz: [HosAuthenticationLogsResponse].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[HosAuthenticationLogsResponse]> in
            return Decoders.decode(clazz: [HosAuthenticationLogsResponse].self, source: source)
        }

        // Decoder for HosAuthenticationLogsResponse
        Decoders.addDecoder(clazz: HosAuthenticationLogsResponse.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<HosAuthenticationLogsResponse> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? HosAuthenticationLogsResponse() : instance as! HosAuthenticationLogsResponse
                switch Decoders.decodeOptional(clazz: [HosAuthenticationLogsResponseAuthenticationLogs].self, source: sourceDictionary["authenticationLogs"] as AnyObject?) {
                
                case let .success(value): _result.authenticationLogs = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "HosAuthenticationLogsResponse", actual: "\(source)"))
            }
        }
        // Decoder for [HosAuthenticationLogsResponseAuthenticationLogs]
        Decoders.addDecoder(clazz: [HosAuthenticationLogsResponseAuthenticationLogs].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[HosAuthenticationLogsResponseAuthenticationLogs]> in
            return Decoders.decode(clazz: [HosAuthenticationLogsResponseAuthenticationLogs].self, source: source)
        }

        // Decoder for HosAuthenticationLogsResponseAuthenticationLogs
        Decoders.addDecoder(clazz: HosAuthenticationLogsResponseAuthenticationLogs.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<HosAuthenticationLogsResponseAuthenticationLogs> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? HosAuthenticationLogsResponseAuthenticationLogs() : instance as! HosAuthenticationLogsResponseAuthenticationLogs
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["actionType"] as AnyObject?) {
                
                case let .success(value): _result.actionType = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address"] as AnyObject?) {
                
                case let .success(value): _result.address = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["city"] as AnyObject?) {
                
                case let .success(value): _result.city = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["happenedAtMs"] as AnyObject?) {
                
                case let .success(value): _result.happenedAtMs = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["addressName"] as AnyObject?) {
                
                case let .success(value): _result.addressName = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["state"] as AnyObject?) {
                
                case let .success(value): _result.state = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "HosAuthenticationLogsResponseAuthenticationLogs", actual: "\(source)"))
            }
        }
        // Decoder for [HosLogsResponse]
        Decoders.addDecoder(clazz: [HosLogsResponse].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[HosLogsResponse]> in
            return Decoders.decode(clazz: [HosLogsResponse].self, source: source)
        }

        // Decoder for HosLogsResponse
        Decoders.addDecoder(clazz: HosLogsResponse.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<HosLogsResponse> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? HosLogsResponse() : instance as! HosLogsResponse
                switch Decoders.decodeOptional(clazz: [HosLogsResponseLogs].self, source: sourceDictionary["logs"] as AnyObject?) {
                
                case let .success(value): _result.logs = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "HosLogsResponse", actual: "\(source)"))
            }
        }
        // Decoder for [HosLogsResponseLogs]
        Decoders.addDecoder(clazz: [HosLogsResponseLogs].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[HosLogsResponseLogs]> in
            return Decoders.decode(clazz: [HosLogsResponseLogs].self, source: source)
        }

        // Decoder for HosLogsResponseLogs
        Decoders.addDecoder(clazz: HosLogsResponseLogs.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<HosLogsResponseLogs> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? HosLogsResponseLogs() : instance as! HosLogsResponseLogs
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["locLng"] as AnyObject?) {
                
                case let .success(value): _result.locLng = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["logStartMs"] as AnyObject?) {
                
                case let .success(value): _result.logStartMs = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["driverId"] as AnyObject?) {
                
                case let .success(value): _result.driverId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["statusType"] as AnyObject?) {
                
                case let .success(value): _result.statusType = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["locCity"] as AnyObject?) {
                
                case let .success(value): _result.locCity = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["groupId"] as AnyObject?) {
                
                case let .success(value): _result.groupId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["locName"] as AnyObject?) {
                
                case let .success(value): _result.locName = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["locLat"] as AnyObject?) {
                
                case let .success(value): _result.locLat = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["remark"] as AnyObject?) {
                
                case let .success(value): _result.remark = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["locState"] as AnyObject?) {
                
                case let .success(value): _result.locState = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["vehicleId"] as AnyObject?) {
                
                case let .success(value): _result.vehicleId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [Int64].self, source: sourceDictionary["codriverIds"] as AnyObject?) {
                
                case let .success(value): _result.codriverIds = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "HosLogsResponseLogs", actual: "\(source)"))
            }
        }
        // Decoder for [HosLogsSummaryResponse]
        Decoders.addDecoder(clazz: [HosLogsSummaryResponse].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[HosLogsSummaryResponse]> in
            return Decoders.decode(clazz: [HosLogsSummaryResponse].self, source: source)
        }

        // Decoder for HosLogsSummaryResponse
        Decoders.addDecoder(clazz: HosLogsSummaryResponse.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<HosLogsSummaryResponse> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? HosLogsSummaryResponse() : instance as! HosLogsSummaryResponse
                switch Decoders.decodeOptional(clazz: [HosLogsSummaryResponseDrivers].self, source: sourceDictionary["drivers"] as AnyObject?) {
                
                case let .success(value): _result.drivers = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "HosLogsSummaryResponse", actual: "\(source)"))
            }
        }
        // Decoder for [HosLogsSummaryResponseDrivers]
        Decoders.addDecoder(clazz: [HosLogsSummaryResponseDrivers].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[HosLogsSummaryResponseDrivers]> in
            return Decoders.decode(clazz: [HosLogsSummaryResponseDrivers].self, source: source)
        }

        // Decoder for HosLogsSummaryResponseDrivers
        Decoders.addDecoder(clazz: HosLogsSummaryResponseDrivers.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<HosLogsSummaryResponseDrivers> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? HosLogsSummaryResponseDrivers() : instance as! HosLogsSummaryResponseDrivers
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["timeUntilBreak"] as AnyObject?) {
                
                case let .success(value): _result.timeUntilBreak = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["vehicleName"] as AnyObject?) {
                
                case let .success(value): _result.vehicleName = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["drivingInViolationToday"] as AnyObject?) {
                
                case let .success(value): _result.drivingInViolationToday = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["driverId"] as AnyObject?) {
                
                case let .success(value): _result.driverId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["cycleRemaining"] as AnyObject?) {
                
                case let .success(value): _result.cycleRemaining = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["driverName"] as AnyObject?) {
                
                case let .success(value): _result.driverName = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["dutyStatus"] as AnyObject?) {
                
                case let .success(value): _result.dutyStatus = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["cycleTomorrow"] as AnyObject?) {
                
                case let .success(value): _result.cycleTomorrow = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["shiftDriveRemaining"] as AnyObject?) {
                
                case let .success(value): _result.shiftDriveRemaining = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["timeInCurrentStatus"] as AnyObject?) {
                
                case let .success(value): _result.timeInCurrentStatus = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["drivingInViolationCycle"] as AnyObject?) {
                
                case let .success(value): _result.drivingInViolationCycle = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["shiftRemaining"] as AnyObject?) {
                
                case let .success(value): _result.shiftRemaining = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "HosLogsSummaryResponseDrivers", actual: "\(source)"))
            }
        }
        // Decoder for [HumidityResponse]
        Decoders.addDecoder(clazz: [HumidityResponse].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[HumidityResponse]> in
            return Decoders.decode(clazz: [HumidityResponse].self, source: source)
        }

        // Decoder for HumidityResponse
        Decoders.addDecoder(clazz: HumidityResponse.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<HumidityResponse> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? HumidityResponse() : instance as! HumidityResponse
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["groupId"] as AnyObject?) {
                
                case let .success(value): _result.groupId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [HumidityResponseSensors].self, source: sourceDictionary["sensors"] as AnyObject?) {
                
                case let .success(value): _result.sensors = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "HumidityResponse", actual: "\(source)"))
            }
        }
        // Decoder for [HumidityResponseSensors]
        Decoders.addDecoder(clazz: [HumidityResponseSensors].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[HumidityResponseSensors]> in
            return Decoders.decode(clazz: [HumidityResponseSensors].self, source: source)
        }

        // Decoder for HumidityResponseSensors
        Decoders.addDecoder(clazz: HumidityResponseSensors.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<HumidityResponseSensors> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? HumidityResponseSensors() : instance as! HumidityResponseSensors
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): _result.name = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["humidity"] as AnyObject?) {
                
                case let .success(value): _result.humidity = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): _result.id = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "HumidityResponseSensors", actual: "\(source)"))
            }
        }
        // Decoder for [InlineObject]
        Decoders.addDecoder(clazz: [InlineObject].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[InlineObject]> in
            return Decoders.decode(clazz: [InlineObject].self, source: source)
        }

        // Decoder for InlineObject
        Decoders.addDecoder(clazz: InlineObject.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<InlineObject> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? InlineObject() : instance as! InlineObject
                switch Decoders.decodeOptional(clazz: [AddressesAddresses].self, source: sourceDictionary["addresses"] as AnyObject?) {
                
                case let .success(value): _result.addresses = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "InlineObject", actual: "\(source)"))
            }
        }
        // Decoder for [InlineObject1]
        Decoders.addDecoder(clazz: [InlineObject1].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[InlineObject1]> in
            return Decoders.decode(clazz: [InlineObject1].self, source: source)
        }

        // Decoder for InlineObject1
        Decoders.addDecoder(clazz: InlineObject1.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<InlineObject1> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? InlineObject1() : instance as! InlineObject1
                switch Decoders.decodeOptional(clazz: [Int64].self, source: sourceDictionary["contactIds"] as AnyObject?) {
                
                case let .success(value): _result.contactIds = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["formattedAddress"] as AnyObject?) {
                
                case let .success(value): _result.formattedAddress = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: AddressGeofence.self, source: sourceDictionary["geofence"] as AnyObject?) {
                
                case let .success(value): _result.geofence = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): _result.name = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["notes"] as AnyObject?) {
                
                case let .success(value): _result.notes = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [Int64].self, source: sourceDictionary["tagIds"] as AnyObject?) {
                
                case let .success(value): _result.tagIds = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "InlineObject1", actual: "\(source)"))
            }
        }
        // Decoder for [InlineObject10]
        Decoders.addDecoder(clazz: [InlineObject10].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[InlineObject10]> in
            return Decoders.decode(clazz: [InlineObject10].self, source: source)
        }

        // Decoder for InlineObject10
        Decoders.addDecoder(clazz: InlineObject10.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<InlineObject10> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? InlineObject10() : instance as! InlineObject10
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["groupId"] as AnyObject?) {
                
                case let .success(value): _result.groupId = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "InlineObject10", actual: "\(source)"))
            }
        }
        // Decoder for [InlineObject11]
        Decoders.addDecoder(clazz: [InlineObject11].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[InlineObject11]> in
            return Decoders.decode(clazz: [InlineObject11].self, source: source)
        }

        // Decoder for InlineObject11
        Decoders.addDecoder(clazz: InlineObject11.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<InlineObject11> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? InlineObject11() : instance as! InlineObject11
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["groupId"] as AnyObject?) {
                
                case let .success(value): _result.groupId = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "InlineObject11", actual: "\(source)"))
            }
        }
        // Decoder for [InlineObject12]
        Decoders.addDecoder(clazz: [InlineObject12].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[InlineObject12]> in
            return Decoders.decode(clazz: [InlineObject12].self, source: source)
        }

        // Decoder for InlineObject12
        Decoders.addDecoder(clazz: InlineObject12.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<InlineObject12> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? InlineObject12() : instance as! InlineObject12
                switch Decoders.decodeOptional(clazz: InlineObject12.InspectionType.self, source: sourceDictionary["inspectionType"] as AnyObject?) {
                
                case let .success(value): _result.inspectionType = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["mechanicNotes"] as AnyObject?) {
                
                case let .success(value): _result.mechanicNotes = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["odometerMiles"] as AnyObject?) {
                
                case let .success(value): _result.odometerMiles = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["previousDefectsCorrected"] as AnyObject?) {
                
                case let .success(value): _result.previousDefectsCorrected = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["previousDefectsIgnored"] as AnyObject?) {
                
                case let .success(value): _result.previousDefectsIgnored = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: InlineObject12.Safe.self, source: sourceDictionary["safe"] as AnyObject?) {
                
                case let .success(value): _result.safe = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["trailerId"] as AnyObject?) {
                
                case let .success(value): _result.trailerId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["userEmail"] as AnyObject?) {
                
                case let .success(value): _result.userEmail = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["vehicleId"] as AnyObject?) {
                
                case let .success(value): _result.vehicleId = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "InlineObject12", actual: "\(source)"))
            }
        }
        // Decoder for [InlineObject13]
        Decoders.addDecoder(clazz: [InlineObject13].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[InlineObject13]> in
            return Decoders.decode(clazz: [InlineObject13].self, source: source)
        }

        // Decoder for InlineObject13
        Decoders.addDecoder(clazz: InlineObject13.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<InlineObject13> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? InlineObject13() : instance as! InlineObject13
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["groupId"] as AnyObject?) {
                
                case let .success(value): _result.groupId = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "InlineObject13", actual: "\(source)"))
            }
        }
        // Decoder for [InlineObject14]
        Decoders.addDecoder(clazz: [InlineObject14].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[InlineObject14]> in
            return Decoders.decode(clazz: [InlineObject14].self, source: source)
        }

        // Decoder for InlineObject14
        Decoders.addDecoder(clazz: InlineObject14.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<InlineObject14> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? InlineObject14() : instance as! InlineObject14
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["groupId"] as AnyObject?) {
                
                case let .success(value): _result.groupId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [Vehicle].self, source: sourceDictionary["vehicles"] as AnyObject?) {
                
                case let .success(value): _result.vehicles = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "InlineObject14", actual: "\(source)"))
            }
        }
        // Decoder for [InlineObject15]
        Decoders.addDecoder(clazz: [InlineObject15].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[InlineObject15]> in
            return Decoders.decode(clazz: [InlineObject15].self, source: source)
        }

        // Decoder for InlineObject15
        Decoders.addDecoder(clazz: InlineObject15.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<InlineObject15> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? InlineObject15() : instance as! InlineObject15
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["endMs"] as AnyObject?) {
                
                case let .success(value): _result.endMs = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["groupId"] as AnyObject?) {
                
                case let .success(value): _result.groupId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["startMs"] as AnyObject?) {
                
                case let .success(value): _result.startMs = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["vehicleId"] as AnyObject?) {
                
                case let .success(value): _result.vehicleId = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "InlineObject15", actual: "\(source)"))
            }
        }
        // Decoder for [InlineObject16]
        Decoders.addDecoder(clazz: [InlineObject16].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[InlineObject16]> in
            return Decoders.decode(clazz: [InlineObject16].self, source: source)
        }

        // Decoder for InlineObject16
        Decoders.addDecoder(clazz: InlineObject16.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<InlineObject16> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? InlineObject16() : instance as! InlineObject16
                switch Decoders.decodeOptional(clazz: [String:String].self, source: sourceDictionary["externalIds"] as AnyObject?) {
                
                case let .success(value): _result.externalIds = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["harsh_accel_setting"] as AnyObject?) {
                
                case let .success(value): _result.harshAccelSetting = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): _result.name = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "InlineObject16", actual: "\(source)"))
            }
        }
        // Decoder for [InlineObject17]
        Decoders.addDecoder(clazz: [InlineObject17].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[InlineObject17]> in
            return Decoders.decode(clazz: [InlineObject17].self, source: source)
        }

        // Decoder for InlineObject17
        Decoders.addDecoder(clazz: InlineObject17.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<InlineObject17> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? InlineObject17() : instance as! InlineObject17
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["endMs"] as AnyObject?) {
                
                case let .success(value): _result.endMs = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["groupId"] as AnyObject?) {
                
                case let .success(value): _result.groupId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["startMs"] as AnyObject?) {
                
                case let .success(value): _result.startMs = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "InlineObject17", actual: "\(source)"))
            }
        }
        // Decoder for [InlineObject18]
        Decoders.addDecoder(clazz: [InlineObject18].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[InlineObject18]> in
            return Decoders.decode(clazz: [InlineObject18].self, source: source)
        }

        // Decoder for InlineObject18
        Decoders.addDecoder(clazz: InlineObject18.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<InlineObject18> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? InlineObject18() : instance as! InlineObject18
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["groupId"] as AnyObject?) {
                
                case let .success(value): _result.groupId = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "InlineObject18", actual: "\(source)"))
            }
        }
        // Decoder for [InlineObject19]
        Decoders.addDecoder(clazz: [InlineObject19].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[InlineObject19]> in
            return Decoders.decode(clazz: [InlineObject19].self, source: source)
        }

        // Decoder for InlineObject19
        Decoders.addDecoder(clazz: InlineObject19.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<InlineObject19> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? InlineObject19() : instance as! InlineObject19
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["groupId"] as AnyObject?) {
                
                case let .success(value): _result.groupId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [Int64].self, source: sourceDictionary["sensors"] as AnyObject?) {
                
                case let .success(value): _result.sensors = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "InlineObject19", actual: "\(source)"))
            }
        }
        // Decoder for [InlineObject2]
        Decoders.addDecoder(clazz: [InlineObject2].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[InlineObject2]> in
            return Decoders.decode(clazz: [InlineObject2].self, source: source)
        }

        // Decoder for InlineObject2
        Decoders.addDecoder(clazz: InlineObject2.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<InlineObject2> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? InlineObject2() : instance as! InlineObject2
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address"] as AnyObject?) {
                
                case let .success(value): _result.address = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["groupId"] as AnyObject?) {
                
                case let .success(value): _result.groupId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): _result.name = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["radius"] as AnyObject?) {
                
                case let .success(value): _result.radius = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "InlineObject2", actual: "\(source)"))
            }
        }
        // Decoder for [InlineObject20]
        Decoders.addDecoder(clazz: [InlineObject20].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[InlineObject20]> in
            return Decoders.decode(clazz: [InlineObject20].self, source: source)
        }

        // Decoder for InlineObject20
        Decoders.addDecoder(clazz: InlineObject20.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<InlineObject20> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? InlineObject20() : instance as! InlineObject20
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["groupId"] as AnyObject?) {
                
                case let .success(value): _result.groupId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [Int64].self, source: sourceDictionary["sensors"] as AnyObject?) {
                
                case let .success(value): _result.sensors = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "InlineObject20", actual: "\(source)"))
            }
        }
        // Decoder for [InlineObject21]
        Decoders.addDecoder(clazz: [InlineObject21].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[InlineObject21]> in
            return Decoders.decode(clazz: [InlineObject21].self, source: source)
        }

        // Decoder for InlineObject21
        Decoders.addDecoder(clazz: InlineObject21.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<InlineObject21> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? InlineObject21() : instance as! InlineObject21
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["endMs"] as AnyObject?) {
                
                case let .success(value): _result.endMs = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: InlineObject21.FillMissing.self, source: sourceDictionary["fillMissing"] as AnyObject?) {
                
                case let .success(value): _result.fillMissing = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["groupId"] as AnyObject?) {
                
                case let .success(value): _result.groupId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [SensorsHistorySeries].self, source: sourceDictionary["series"] as AnyObject?) {
                
                case let .success(value): _result.series = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["startMs"] as AnyObject?) {
                
                case let .success(value): _result.startMs = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["stepMs"] as AnyObject?) {
                
                case let .success(value): _result.stepMs = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "InlineObject21", actual: "\(source)"))
            }
        }
        // Decoder for [InlineObject22]
        Decoders.addDecoder(clazz: [InlineObject22].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[InlineObject22]> in
            return Decoders.decode(clazz: [InlineObject22].self, source: source)
        }

        // Decoder for InlineObject22
        Decoders.addDecoder(clazz: InlineObject22.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<InlineObject22> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? InlineObject22() : instance as! InlineObject22
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["groupId"] as AnyObject?) {
                
                case let .success(value): _result.groupId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [Int64].self, source: sourceDictionary["sensors"] as AnyObject?) {
                
                case let .success(value): _result.sensors = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "InlineObject22", actual: "\(source)"))
            }
        }
        // Decoder for [InlineObject23]
        Decoders.addDecoder(clazz: [InlineObject23].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[InlineObject23]> in
            return Decoders.decode(clazz: [InlineObject23].self, source: source)
        }

        // Decoder for InlineObject23
        Decoders.addDecoder(clazz: InlineObject23.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<InlineObject23> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? InlineObject23() : instance as! InlineObject23
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["groupId"] as AnyObject?) {
                
                case let .success(value): _result.groupId = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "InlineObject23", actual: "\(source)"))
            }
        }
        // Decoder for [InlineObject24]
        Decoders.addDecoder(clazz: [InlineObject24].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[InlineObject24]> in
            return Decoders.decode(clazz: [InlineObject24].self, source: source)
        }

        // Decoder for InlineObject24
        Decoders.addDecoder(clazz: InlineObject24.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<InlineObject24> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? InlineObject24() : instance as! InlineObject24
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["groupId"] as AnyObject?) {
                
                case let .success(value): _result.groupId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [Int64].self, source: sourceDictionary["sensors"] as AnyObject?) {
                
                case let .success(value): _result.sensors = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "InlineObject24", actual: "\(source)"))
            }
        }
        // Decoder for [InlineObject3]
        Decoders.addDecoder(clazz: [InlineObject3].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[InlineObject3]> in
            return Decoders.decode(clazz: [InlineObject3].self, source: source)
        }

        // Decoder for InlineObject3
        Decoders.addDecoder(clazz: InlineObject3.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<InlineObject3> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? InlineObject3() : instance as! InlineObject3
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["groupId"] as AnyObject?) {
                
                case let .success(value): _result.groupId = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "InlineObject3", actual: "\(source)"))
            }
        }
        // Decoder for [InlineObject4]
        Decoders.addDecoder(clazz: [InlineObject4].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[InlineObject4]> in
            return Decoders.decode(clazz: [InlineObject4].self, source: source)
        }

        // Decoder for InlineObject4
        Decoders.addDecoder(clazz: InlineObject4.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<InlineObject4> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? InlineObject4() : instance as! InlineObject4
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["reactivate"] as AnyObject?) {
                
                case let .success(value): _result.reactivate = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "InlineObject4", actual: "\(source)"))
            }
        }
        // Decoder for [InlineObject5]
        Decoders.addDecoder(clazz: [InlineObject5].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[InlineObject5]> in
            return Decoders.decode(clazz: [InlineObject5].self, source: source)
        }

        // Decoder for InlineObject5
        Decoders.addDecoder(clazz: InlineObject5.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<InlineObject5> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? InlineObject5() : instance as! InlineObject5
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["endMs"] as AnyObject?) {
                
                case let .success(value): _result.endMs = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["orgId"] as AnyObject?) {
                
                case let .success(value): _result.orgId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["startMs"] as AnyObject?) {
                
                case let .success(value): _result.startMs = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "InlineObject5", actual: "\(source)"))
            }
        }
        // Decoder for [InlineObject6]
        Decoders.addDecoder(clazz: [InlineObject6].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[InlineObject6]> in
            return Decoders.decode(clazz: [InlineObject6].self, source: source)
        }

        // Decoder for InlineObject6
        Decoders.addDecoder(clazz: InlineObject6.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<InlineObject6> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? InlineObject6() : instance as! InlineObject6
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["driverId"] as AnyObject?) {
                
                case let .success(value): _result.driverId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["endMs"] as AnyObject?) {
                
                case let .success(value): _result.endMs = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["groupId"] as AnyObject?) {
                
                case let .success(value): _result.groupId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["startMs"] as AnyObject?) {
                
                case let .success(value): _result.startMs = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "InlineObject6", actual: "\(source)"))
            }
        }
        // Decoder for [InlineObject7]
        Decoders.addDecoder(clazz: [InlineObject7].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[InlineObject7]> in
            return Decoders.decode(clazz: [InlineObject7].self, source: source)
        }

        // Decoder for InlineObject7
        Decoders.addDecoder(clazz: InlineObject7.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<InlineObject7> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? InlineObject7() : instance as! InlineObject7
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["driverId"] as AnyObject?) {
                
                case let .success(value): _result.driverId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["endMs"] as AnyObject?) {
                
                case let .success(value): _result.endMs = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["groupId"] as AnyObject?) {
                
                case let .success(value): _result.groupId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["startMs"] as AnyObject?) {
                
                case let .success(value): _result.startMs = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "InlineObject7", actual: "\(source)"))
            }
        }
        // Decoder for [InlineObject8]
        Decoders.addDecoder(clazz: [InlineObject8].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[InlineObject8]> in
            return Decoders.decode(clazz: [InlineObject8].self, source: source)
        }

        // Decoder for InlineObject8
        Decoders.addDecoder(clazz: InlineObject8.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<InlineObject8> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? InlineObject8() : instance as! InlineObject8
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["driverId"] as AnyObject?) {
                
                case let .success(value): _result.driverId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["endMs"] as AnyObject?) {
                
                case let .success(value): _result.endMs = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["groupId"] as AnyObject?) {
                
                case let .success(value): _result.groupId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["startMs"] as AnyObject?) {
                
                case let .success(value): _result.startMs = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "InlineObject8", actual: "\(source)"))
            }
        }
        // Decoder for [InlineObject9]
        Decoders.addDecoder(clazz: [InlineObject9].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[InlineObject9]> in
            return Decoders.decode(clazz: [InlineObject9].self, source: source)
        }

        // Decoder for InlineObject9
        Decoders.addDecoder(clazz: InlineObject9.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<InlineObject9> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? InlineObject9() : instance as! InlineObject9
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["groupId"] as AnyObject?) {
                
                case let .success(value): _result.groupId = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "InlineObject9", actual: "\(source)"))
            }
        }
        // Decoder for [InlineResponse200]
        Decoders.addDecoder(clazz: [InlineResponse200].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[InlineResponse200]> in
            return Decoders.decode(clazz: [InlineResponse200].self, source: source)
        }

        // Decoder for InlineResponse200
        Decoders.addDecoder(clazz: InlineResponse200.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<InlineResponse200> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? InlineResponse200() : instance as! InlineResponse200
                switch Decoders.decodeOptional(clazz: [Asset].self, source: sourceDictionary["assets"] as AnyObject?) {
                
                case let .success(value): _result.assets = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "InlineResponse200", actual: "\(source)"))
            }
        }
        // Decoder for [InlineResponse2001]
        Decoders.addDecoder(clazz: [InlineResponse2001].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[InlineResponse2001]> in
            return Decoders.decode(clazz: [InlineResponse2001].self, source: source)
        }

        // Decoder for InlineResponse2001
        Decoders.addDecoder(clazz: InlineResponse2001.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<InlineResponse2001> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? InlineResponse2001() : instance as! InlineResponse2001
                switch Decoders.decodeOptional(clazz: [AssetCurrentLocationsResponse].self, source: sourceDictionary["assets"] as AnyObject?) {
                
                case let .success(value): _result.assets = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "InlineResponse2001", actual: "\(source)"))
            }
        }
        // Decoder for [InlineResponse2002]
        Decoders.addDecoder(clazz: [InlineResponse2002].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[InlineResponse2002]> in
            return Decoders.decode(clazz: [InlineResponse2002].self, source: source)
        }

        // Decoder for InlineResponse2002
        Decoders.addDecoder(clazz: InlineResponse2002.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<InlineResponse2002> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? InlineResponse2002() : instance as! InlineResponse2002
                switch Decoders.decodeOptional(clazz: Pagination.self, source: sourceDictionary["pagination"] as AnyObject?) {
                
                case let .success(value): _result.pagination = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["groupId"] as AnyObject?) {
                
                case let .success(value): _result.groupId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [Vehicle].self, source: sourceDictionary["vehicles"] as AnyObject?) {
                
                case let .success(value): _result.vehicles = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "InlineResponse2002", actual: "\(source)"))
            }
        }
        // Decoder for [InlineResponse2003]
        Decoders.addDecoder(clazz: [InlineResponse2003].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[InlineResponse2003]> in
            return Decoders.decode(clazz: [InlineResponse2003].self, source: source)
        }

        // Decoder for InlineResponse2003
        Decoders.addDecoder(clazz: InlineResponse2003.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<InlineResponse2003> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? InlineResponse2003() : instance as! InlineResponse2003
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["groupId"] as AnyObject?) {
                
                case let .success(value): _result.groupId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [VehicleLocation].self, source: sourceDictionary["vehicles"] as AnyObject?) {
                
                case let .success(value): _result.vehicles = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "InlineResponse2003", actual: "\(source)"))
            }
        }
        // Decoder for [InlineResponse2004]
        Decoders.addDecoder(clazz: [InlineResponse2004].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[InlineResponse2004]> in
            return Decoders.decode(clazz: [InlineResponse2004].self, source: source)
        }

        // Decoder for InlineResponse2004
        Decoders.addDecoder(clazz: InlineResponse2004.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<InlineResponse2004> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? InlineResponse2004() : instance as! InlineResponse2004
                switch Decoders.decodeOptional(clazz: [VehicleMaintenance].self, source: sourceDictionary["vehicles"] as AnyObject?) {
                
                case let .success(value): _result.vehicles = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "InlineResponse2004", actual: "\(source)"))
            }
        }
        // Decoder for [InlineResponse2005]
        Decoders.addDecoder(clazz: [InlineResponse2005].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[InlineResponse2005]> in
            return Decoders.decode(clazz: [InlineResponse2005].self, source: source)
        }

        // Decoder for InlineResponse2005
        Decoders.addDecoder(clazz: InlineResponse2005.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<InlineResponse2005> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? InlineResponse2005() : instance as! InlineResponse2005
                switch Decoders.decodeOptional(clazz: Pagination.self, source: sourceDictionary["pagination"] as AnyObject?) {
                
                case let .success(value): _result.pagination = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [InlineResponse2005VehicleStats].self, source: sourceDictionary["vehicleStats"] as AnyObject?) {
                
                case let .success(value): _result.vehicleStats = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "InlineResponse2005", actual: "\(source)"))
            }
        }
        // Decoder for [InlineResponse2005VehicleStats]
        Decoders.addDecoder(clazz: [InlineResponse2005VehicleStats].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[InlineResponse2005VehicleStats]> in
            return Decoders.decode(clazz: [InlineResponse2005VehicleStats].self, source: source)
        }

        // Decoder for InlineResponse2005VehicleStats
        Decoders.addDecoder(clazz: InlineResponse2005VehicleStats.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<InlineResponse2005VehicleStats> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? InlineResponse2005VehicleStats() : instance as! InlineResponse2005VehicleStats
                switch Decoders.decodeOptional(clazz: [EngineState].self, source: sourceDictionary["engineState"] as AnyObject?) {
                
                case let .success(value): _result.engineState = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: AuxInputSeries.self, source: sourceDictionary["auxInput2"] as AnyObject?) {
                
                case let .success(value): _result.auxInput2 = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["vehicleId"] as AnyObject?) {
                
                case let .success(value): _result.vehicleId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: AuxInputSeries.self, source: sourceDictionary["auxInput1"] as AnyObject?) {
                
                case let .success(value): _result.auxInput1 = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "InlineResponse2005VehicleStats", actual: "\(source)"))
            }
        }
        // Decoder for [InlineResponse2006]
        Decoders.addDecoder(clazz: [InlineResponse2006].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[InlineResponse2006]> in
            return Decoders.decode(clazz: [InlineResponse2006].self, source: source)
        }

        // Decoder for InlineResponse2006
        Decoders.addDecoder(clazz: InlineResponse2006.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<InlineResponse2006> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? InlineResponse2006() : instance as! InlineResponse2006
                switch Decoders.decodeOptional(clazz: [DataInputHistoryResponse].self, source: sourceDictionary["dataInputs"] as AnyObject?) {
                
                case let .success(value): _result.dataInputs = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "InlineResponse2006", actual: "\(source)"))
            }
        }
        // Decoder for [InlineResponse2007]
        Decoders.addDecoder(clazz: [InlineResponse2007].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[InlineResponse2007]> in
            return Decoders.decode(clazz: [InlineResponse2007].self, source: source)
        }

        // Decoder for InlineResponse2007
        Decoders.addDecoder(clazz: InlineResponse2007.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<InlineResponse2007> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? InlineResponse2007() : instance as! InlineResponse2007
                switch Decoders.decodeOptional(clazz: [Machine].self, source: sourceDictionary["machines"] as AnyObject?) {
                
                case let .success(value): _result.machines = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "InlineResponse2007", actual: "\(source)"))
            }
        }
        // Decoder for [InlineResponse2008]
        Decoders.addDecoder(clazz: [InlineResponse2008].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[InlineResponse2008]> in
            return Decoders.decode(clazz: [InlineResponse2008].self, source: source)
        }

        // Decoder for InlineResponse2008
        Decoders.addDecoder(clazz: InlineResponse2008.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<InlineResponse2008> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? InlineResponse2008() : instance as! InlineResponse2008
                switch Decoders.decodeOptional(clazz: [Sensor].self, source: sourceDictionary["sensors"] as AnyObject?) {
                
                case let .success(value): _result.sensors = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "InlineResponse2008", actual: "\(source)"))
            }
        }
        // Decoder for [InlineResponse2009]
        Decoders.addDecoder(clazz: [InlineResponse2009].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[InlineResponse2009]> in
            return Decoders.decode(clazz: [InlineResponse2009].self, source: source)
        }

        // Decoder for InlineResponse2009
        Decoders.addDecoder(clazz: InlineResponse2009.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<InlineResponse2009> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? InlineResponse2009() : instance as! InlineResponse2009
                switch Decoders.decodeOptional(clazz: [Tag].self, source: sourceDictionary["tags"] as AnyObject?) {
                
                case let .success(value): _result.tags = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "InlineResponse2009", actual: "\(source)"))
            }
        }
        // Decoder for [JobStatus]
        Decoders.addDecoder(clazz: [JobStatus].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[JobStatus]> in
            return Decoders.decode(clazz: [JobStatus].self, source: source)
        }

        // Decoder for JobStatus
        Decoders.addDecoder(clazz: JobStatus.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<JobStatus> in
            //TODO: I don't think we need this anymore
            return Decoders.decode(clazz: JobStatus.self, source: source, instance: instance)
        }
        // Decoder for [JobUpdateObject]
        Decoders.addDecoder(clazz: [JobUpdateObject].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[JobUpdateObject]> in
            return Decoders.decode(clazz: [JobUpdateObject].self, source: source)
        }

        // Decoder for JobUpdateObject
        Decoders.addDecoder(clazz: JobUpdateObject.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<JobUpdateObject> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? JobUpdateObject() : instance as! JobUpdateObject
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["changed_at_ms"] as AnyObject?) {
                
                case let .success(value): _result.changedAtMs = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["job_id"] as AnyObject?) {
                
                case let .success(value): _result.jobId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: JobStatus.self, source: sourceDictionary["job_state"] as AnyObject?) {
                
                case let .success(value): _result.jobState = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: PrevJobStatus.self, source: sourceDictionary["prev_job_state"] as AnyObject?) {
                
                case let .success(value): _result.prevJobState = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: DispatchRoute.self, source: sourceDictionary["route"] as AnyObject?) {
                
                case let .success(value): _result.route = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["route_id"] as AnyObject?) {
                
                case let .success(value): _result.routeId = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "JobUpdateObject", actual: "\(source)"))
            }
        }
        // Decoder for [Machine]
        Decoders.addDecoder(clazz: [Machine].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[Machine]> in
            return Decoders.decode(clazz: [Machine].self, source: source)
        }

        // Decoder for Machine
        Decoders.addDecoder(clazz: Machine.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<Machine> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? Machine() : instance as! Machine
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): _result.id = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): _result.name = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["notes"] as AnyObject?) {
                
                case let .success(value): _result.notes = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "Machine", actual: "\(source)"))
            }
        }
        // Decoder for [MachineHistoryResponse]
        Decoders.addDecoder(clazz: [MachineHistoryResponse].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[MachineHistoryResponse]> in
            return Decoders.decode(clazz: [MachineHistoryResponse].self, source: source)
        }

        // Decoder for MachineHistoryResponse
        Decoders.addDecoder(clazz: MachineHistoryResponse.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<MachineHistoryResponse> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? MachineHistoryResponse() : instance as! MachineHistoryResponse
                switch Decoders.decodeOptional(clazz: [MachineHistoryResponseMachines].self, source: sourceDictionary["machines"] as AnyObject?) {
                
                case let .success(value): _result.machines = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "MachineHistoryResponse", actual: "\(source)"))
            }
        }
        // Decoder for [MachineHistoryResponseMachines]
        Decoders.addDecoder(clazz: [MachineHistoryResponseMachines].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[MachineHistoryResponseMachines]> in
            return Decoders.decode(clazz: [MachineHistoryResponseMachines].self, source: source)
        }

        // Decoder for MachineHistoryResponseMachines
        Decoders.addDecoder(clazz: MachineHistoryResponseMachines.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<MachineHistoryResponseMachines> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? MachineHistoryResponseMachines() : instance as! MachineHistoryResponseMachines
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): _result.name = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): _result.id = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [MachineHistoryResponseVibrations].self, source: sourceDictionary["vibrations"] as AnyObject?) {
                
                case let .success(value): _result.vibrations = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "MachineHistoryResponseMachines", actual: "\(source)"))
            }
        }
        // Decoder for [MachineHistoryResponseVibrations]
        Decoders.addDecoder(clazz: [MachineHistoryResponseVibrations].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[MachineHistoryResponseVibrations]> in
            return Decoders.decode(clazz: [MachineHistoryResponseVibrations].self, source: source)
        }

        // Decoder for MachineHistoryResponseVibrations
        Decoders.addDecoder(clazz: MachineHistoryResponseVibrations.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<MachineHistoryResponseVibrations> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? MachineHistoryResponseVibrations() : instance as! MachineHistoryResponseVibrations
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["X"] as AnyObject?) {
                
                case let .success(value): _result.X = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["Y"] as AnyObject?) {
                
                case let .success(value): _result.Y = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["Z"] as AnyObject?) {
                
                case let .success(value): _result.Z = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["time"] as AnyObject?) {
                
                case let .success(value): _result.time = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "MachineHistoryResponseVibrations", actual: "\(source)"))
            }
        }
        // Decoder for [Pagination]
        Decoders.addDecoder(clazz: [Pagination].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[Pagination]> in
            return Decoders.decode(clazz: [Pagination].self, source: source)
        }

        // Decoder for Pagination
        Decoders.addDecoder(clazz: Pagination.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<Pagination> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? Pagination() : instance as! Pagination
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["endCursor"] as AnyObject?) {
                
                case let .success(value): _result.endCursor = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["hasNextPage"] as AnyObject?) {
                
                case let .success(value): _result.hasNextPage = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["hasPrevPage"] as AnyObject?) {
                
                case let .success(value): _result.hasPrevPage = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["startCursor"] as AnyObject?) {
                
                case let .success(value): _result.startCursor = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "Pagination", actual: "\(source)"))
            }
        }
        // Decoder for [PrevJobStatus]
        Decoders.addDecoder(clazz: [PrevJobStatus].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[PrevJobStatus]> in
            return Decoders.decode(clazz: [PrevJobStatus].self, source: source)
        }

        // Decoder for PrevJobStatus
        Decoders.addDecoder(clazz: PrevJobStatus.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PrevJobStatus> in
            //TODO: I don't think we need this anymore
            return Decoders.decode(clazz: PrevJobStatus.self, source: source, instance: instance)
        }
        // Decoder for [SafetyReportHarshEvent]
        Decoders.addDecoder(clazz: [SafetyReportHarshEvent].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[SafetyReportHarshEvent]> in
            return Decoders.decode(clazz: [SafetyReportHarshEvent].self, source: source)
        }

        // Decoder for SafetyReportHarshEvent
        Decoders.addDecoder(clazz: SafetyReportHarshEvent.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<SafetyReportHarshEvent> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? SafetyReportHarshEvent() : instance as! SafetyReportHarshEvent
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["harshEventType"] as AnyObject?) {
                
                case let .success(value): _result.harshEventType = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["timestampMs"] as AnyObject?) {
                
                case let .success(value): _result.timestampMs = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["vehicleId"] as AnyObject?) {
                
                case let .success(value): _result.vehicleId = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "SafetyReportHarshEvent", actual: "\(source)"))
            }
        }
        // Decoder for [Sensor]
        Decoders.addDecoder(clazz: [Sensor].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[Sensor]> in
            return Decoders.decode(clazz: [Sensor].self, source: source)
        }

        // Decoder for Sensor
        Decoders.addDecoder(clazz: Sensor.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<Sensor> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? Sensor() : instance as! Sensor
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): _result.id = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["macAddress"] as AnyObject?) {
                
                case let .success(value): _result.macAddress = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): _result.name = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "Sensor", actual: "\(source)"))
            }
        }
        // Decoder for [SensorHistoryResponse]
        Decoders.addDecoder(clazz: [SensorHistoryResponse].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[SensorHistoryResponse]> in
            return Decoders.decode(clazz: [SensorHistoryResponse].self, source: source)
        }

        // Decoder for SensorHistoryResponse
        Decoders.addDecoder(clazz: SensorHistoryResponse.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<SensorHistoryResponse> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? SensorHistoryResponse() : instance as! SensorHistoryResponse
                switch Decoders.decodeOptional(clazz: [SensorHistoryResponseResults].self, source: sourceDictionary["results"] as AnyObject?) {
                
                case let .success(value): _result.results = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "SensorHistoryResponse", actual: "\(source)"))
            }
        }
        // Decoder for [SensorHistoryResponseResults]
        Decoders.addDecoder(clazz: [SensorHistoryResponseResults].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[SensorHistoryResponseResults]> in
            return Decoders.decode(clazz: [SensorHistoryResponseResults].self, source: source)
        }

        // Decoder for SensorHistoryResponseResults
        Decoders.addDecoder(clazz: SensorHistoryResponseResults.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<SensorHistoryResponseResults> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? SensorHistoryResponseResults() : instance as! SensorHistoryResponseResults
                switch Decoders.decodeOptional(clazz: [Int64].self, source: sourceDictionary["series"] as AnyObject?) {
                
                case let .success(value): _result.series = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["timeMs"] as AnyObject?) {
                
                case let .success(value): _result.timeMs = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "SensorHistoryResponseResults", actual: "\(source)"))
            }
        }
        // Decoder for [SensorsHistorySeries]
        Decoders.addDecoder(clazz: [SensorsHistorySeries].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[SensorsHistorySeries]> in
            return Decoders.decode(clazz: [SensorsHistorySeries].self, source: source)
        }

        // Decoder for SensorsHistorySeries
        Decoders.addDecoder(clazz: SensorsHistorySeries.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<SensorsHistorySeries> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? SensorsHistorySeries() : instance as! SensorsHistorySeries
                switch Decoders.decodeOptional(clazz: SensorsHistorySeries.Field.self, source: sourceDictionary["field"] as AnyObject?) {
                
                case let .success(value): _result.field = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["widgetId"] as AnyObject?) {
                
                case let .success(value): _result.widgetId = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "SensorsHistorySeries", actual: "\(source)"))
            }
        }
        // Decoder for [Tag]
        Decoders.addDecoder(clazz: [Tag].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[Tag]> in
            return Decoders.decode(clazz: [Tag].self, source: source)
        }

        // Decoder for Tag
        Decoders.addDecoder(clazz: Tag.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<Tag> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? Tag() : instance as! Tag
                switch Decoders.decodeOptional(clazz: [TaggedAddress].self, source: sourceDictionary["addresses"] as AnyObject?) {
                
                case let .success(value): _result.addresses = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [TaggedAsset].self, source: sourceDictionary["assets"] as AnyObject?) {
                
                case let .success(value): _result.assets = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [TaggedDriver].self, source: sourceDictionary["drivers"] as AnyObject?) {
                
                case let .success(value): _result.drivers = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["groupId"] as AnyObject?) {
                
                case let .success(value): _result.groupId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): _result.id = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [TaggedMachine].self, source: sourceDictionary["machines"] as AnyObject?) {
                
                case let .success(value): _result.machines = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): _result.name = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["parentTagId"] as AnyObject?) {
                
                case let .success(value): _result.parentTagId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [TaggedSensor].self, source: sourceDictionary["sensors"] as AnyObject?) {
                
                case let .success(value): _result.sensors = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [TaggedVehicle].self, source: sourceDictionary["vehicles"] as AnyObject?) {
                
                case let .success(value): _result.vehicles = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "Tag", actual: "\(source)"))
            }
        }
        // Decoder for [TagCreate]
        Decoders.addDecoder(clazz: [TagCreate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[TagCreate]> in
            return Decoders.decode(clazz: [TagCreate].self, source: source)
        }

        // Decoder for TagCreate
        Decoders.addDecoder(clazz: TagCreate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<TagCreate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? TagCreate() : instance as! TagCreate
                switch Decoders.decodeOptional(clazz: [TaggedAssetBase].self, source: sourceDictionary["assets"] as AnyObject?) {
                
                case let .success(value): _result.assets = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [TaggedDriverBase].self, source: sourceDictionary["drivers"] as AnyObject?) {
                
                case let .success(value): _result.drivers = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [TaggedMachineBase].self, source: sourceDictionary["machines"] as AnyObject?) {
                
                case let .success(value): _result.machines = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): _result.name = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["parentTagId"] as AnyObject?) {
                
                case let .success(value): _result.parentTagId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [TaggedSensorBase].self, source: sourceDictionary["sensors"] as AnyObject?) {
                
                case let .success(value): _result.sensors = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [TaggedVehicleBase].self, source: sourceDictionary["vehicles"] as AnyObject?) {
                
                case let .success(value): _result.vehicles = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "TagCreate", actual: "\(source)"))
            }
        }
        // Decoder for [TagMetadata]
        Decoders.addDecoder(clazz: [TagMetadata].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[TagMetadata]> in
            return Decoders.decode(clazz: [TagMetadata].self, source: source)
        }

        // Decoder for TagMetadata
        Decoders.addDecoder(clazz: TagMetadata.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<TagMetadata> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? TagMetadata() : instance as! TagMetadata
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): _result.id = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): _result.name = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "TagMetadata", actual: "\(source)"))
            }
        }
        // Decoder for [TagModify]
        Decoders.addDecoder(clazz: [TagModify].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[TagModify]> in
            return Decoders.decode(clazz: [TagModify].self, source: source)
        }

        // Decoder for TagModify
        Decoders.addDecoder(clazz: TagModify.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<TagModify> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? TagModify() : instance as! TagModify
                switch Decoders.decodeOptional(clazz: TagModifyAdd.self, source: sourceDictionary["add"] as AnyObject?) {
                
                case let .success(value): _result.add = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: TagModifyDelete.self, source: sourceDictionary["delete"] as AnyObject?) {
                
                case let .success(value): _result.delete = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): _result.name = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["parentTagId"] as AnyObject?) {
                
                case let .success(value): _result.parentTagId = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "TagModify", actual: "\(source)"))
            }
        }
        // Decoder for [TagModifyAdd]
        Decoders.addDecoder(clazz: [TagModifyAdd].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[TagModifyAdd]> in
            return Decoders.decode(clazz: [TagModifyAdd].self, source: source)
        }

        // Decoder for TagModifyAdd
        Decoders.addDecoder(clazz: TagModifyAdd.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<TagModifyAdd> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? TagModifyAdd() : instance as! TagModifyAdd
                switch Decoders.decodeOptional(clazz: [TaggedAssetBase].self, source: sourceDictionary["assets"] as AnyObject?) {
                
                case let .success(value): _result.assets = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [TaggedSensorBase].self, source: sourceDictionary["sensors"] as AnyObject?) {
                
                case let .success(value): _result.sensors = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [TaggedVehicleBase].self, source: sourceDictionary["vehicles"] as AnyObject?) {
                
                case let .success(value): _result.vehicles = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [TaggedMachineBase].self, source: sourceDictionary["machines"] as AnyObject?) {
                
                case let .success(value): _result.machines = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [TaggedDriverBase].self, source: sourceDictionary["drivers"] as AnyObject?) {
                
                case let .success(value): _result.drivers = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "TagModifyAdd", actual: "\(source)"))
            }
        }
        // Decoder for [TagModifyDelete]
        Decoders.addDecoder(clazz: [TagModifyDelete].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[TagModifyDelete]> in
            return Decoders.decode(clazz: [TagModifyDelete].self, source: source)
        }

        // Decoder for TagModifyDelete
        Decoders.addDecoder(clazz: TagModifyDelete.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<TagModifyDelete> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? TagModifyDelete() : instance as! TagModifyDelete
                switch Decoders.decodeOptional(clazz: [TaggedAssetBase].self, source: sourceDictionary["assets"] as AnyObject?) {
                
                case let .success(value): _result.assets = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [TaggedSensorBase].self, source: sourceDictionary["sensors"] as AnyObject?) {
                
                case let .success(value): _result.sensors = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [TaggedVehicleBase].self, source: sourceDictionary["vehicles"] as AnyObject?) {
                
                case let .success(value): _result.vehicles = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [TaggedMachineBase].self, source: sourceDictionary["machines"] as AnyObject?) {
                
                case let .success(value): _result.machines = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [TaggedDriverBase].self, source: sourceDictionary["drivers"] as AnyObject?) {
                
                case let .success(value): _result.drivers = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "TagModifyDelete", actual: "\(source)"))
            }
        }
        // Decoder for [TagUpdate]
        Decoders.addDecoder(clazz: [TagUpdate].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[TagUpdate]> in
            return Decoders.decode(clazz: [TagUpdate].self, source: source)
        }

        // Decoder for TagUpdate
        Decoders.addDecoder(clazz: TagUpdate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<TagUpdate> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? TagUpdate() : instance as! TagUpdate
                switch Decoders.decodeOptional(clazz: [TaggedAssetBase].self, source: sourceDictionary["assets"] as AnyObject?) {
                
                case let .success(value): _result.assets = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [TaggedDriverBase].self, source: sourceDictionary["drivers"] as AnyObject?) {
                
                case let .success(value): _result.drivers = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [TaggedMachineBase].self, source: sourceDictionary["machines"] as AnyObject?) {
                
                case let .success(value): _result.machines = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): _result.name = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["parentTagId"] as AnyObject?) {
                
                case let .success(value): _result.parentTagId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [TaggedSensorBase].self, source: sourceDictionary["sensors"] as AnyObject?) {
                
                case let .success(value): _result.sensors = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [TaggedVehicleBase].self, source: sourceDictionary["vehicles"] as AnyObject?) {
                
                case let .success(value): _result.vehicles = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "TagUpdate", actual: "\(source)"))
            }
        }
        // Decoder for [TaggedAddress]
        Decoders.addDecoder(clazz: [TaggedAddress].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[TaggedAddress]> in
            return Decoders.decode(clazz: [TaggedAddress].self, source: source)
        }

        // Decoder for TaggedAddress
        Decoders.addDecoder(clazz: TaggedAddress.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<TaggedAddress> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? TaggedAddress() : instance as! TaggedAddress
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): _result.name = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "TaggedAddress", actual: "\(source)"))
            }
        }
        // Decoder for [TaggedAddressBase]
        Decoders.addDecoder(clazz: [TaggedAddressBase].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[TaggedAddressBase]> in
            return Decoders.decode(clazz: [TaggedAddressBase].self, source: source)
        }

        // Decoder for TaggedAddressBase
        Decoders.addDecoder(clazz: TaggedAddressBase.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<TaggedAddressBase> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? TaggedAddressBase() : instance as! TaggedAddressBase
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): _result.id = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "TaggedAddressBase", actual: "\(source)"))
            }
        }
        // Decoder for [TaggedAsset]
        Decoders.addDecoder(clazz: [TaggedAsset].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[TaggedAsset]> in
            return Decoders.decode(clazz: [TaggedAsset].self, source: source)
        }

        // Decoder for TaggedAsset
        Decoders.addDecoder(clazz: TaggedAsset.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<TaggedAsset> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? TaggedAsset() : instance as! TaggedAsset
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): _result.name = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "TaggedAsset", actual: "\(source)"))
            }
        }
        // Decoder for [TaggedAssetBase]
        Decoders.addDecoder(clazz: [TaggedAssetBase].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[TaggedAssetBase]> in
            return Decoders.decode(clazz: [TaggedAssetBase].self, source: source)
        }

        // Decoder for TaggedAssetBase
        Decoders.addDecoder(clazz: TaggedAssetBase.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<TaggedAssetBase> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? TaggedAssetBase() : instance as! TaggedAssetBase
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): _result.id = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "TaggedAssetBase", actual: "\(source)"))
            }
        }
        // Decoder for [TaggedDriver]
        Decoders.addDecoder(clazz: [TaggedDriver].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[TaggedDriver]> in
            return Decoders.decode(clazz: [TaggedDriver].self, source: source)
        }

        // Decoder for TaggedDriver
        Decoders.addDecoder(clazz: TaggedDriver.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<TaggedDriver> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? TaggedDriver() : instance as! TaggedDriver
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): _result.name = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "TaggedDriver", actual: "\(source)"))
            }
        }
        // Decoder for [TaggedDriverBase]
        Decoders.addDecoder(clazz: [TaggedDriverBase].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[TaggedDriverBase]> in
            return Decoders.decode(clazz: [TaggedDriverBase].self, source: source)
        }

        // Decoder for TaggedDriverBase
        Decoders.addDecoder(clazz: TaggedDriverBase.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<TaggedDriverBase> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? TaggedDriverBase() : instance as! TaggedDriverBase
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): _result.id = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "TaggedDriverBase", actual: "\(source)"))
            }
        }
        // Decoder for [TaggedMachine]
        Decoders.addDecoder(clazz: [TaggedMachine].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[TaggedMachine]> in
            return Decoders.decode(clazz: [TaggedMachine].self, source: source)
        }

        // Decoder for TaggedMachine
        Decoders.addDecoder(clazz: TaggedMachine.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<TaggedMachine> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? TaggedMachine() : instance as! TaggedMachine
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): _result.name = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "TaggedMachine", actual: "\(source)"))
            }
        }
        // Decoder for [TaggedMachineBase]
        Decoders.addDecoder(clazz: [TaggedMachineBase].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[TaggedMachineBase]> in
            return Decoders.decode(clazz: [TaggedMachineBase].self, source: source)
        }

        // Decoder for TaggedMachineBase
        Decoders.addDecoder(clazz: TaggedMachineBase.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<TaggedMachineBase> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? TaggedMachineBase() : instance as! TaggedMachineBase
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): _result.id = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "TaggedMachineBase", actual: "\(source)"))
            }
        }
        // Decoder for [TaggedSensor]
        Decoders.addDecoder(clazz: [TaggedSensor].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[TaggedSensor]> in
            return Decoders.decode(clazz: [TaggedSensor].self, source: source)
        }

        // Decoder for TaggedSensor
        Decoders.addDecoder(clazz: TaggedSensor.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<TaggedSensor> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? TaggedSensor() : instance as! TaggedSensor
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): _result.name = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "TaggedSensor", actual: "\(source)"))
            }
        }
        // Decoder for [TaggedSensorBase]
        Decoders.addDecoder(clazz: [TaggedSensorBase].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[TaggedSensorBase]> in
            return Decoders.decode(clazz: [TaggedSensorBase].self, source: source)
        }

        // Decoder for TaggedSensorBase
        Decoders.addDecoder(clazz: TaggedSensorBase.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<TaggedSensorBase> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? TaggedSensorBase() : instance as! TaggedSensorBase
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): _result.id = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "TaggedSensorBase", actual: "\(source)"))
            }
        }
        // Decoder for [TaggedVehicle]
        Decoders.addDecoder(clazz: [TaggedVehicle].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[TaggedVehicle]> in
            return Decoders.decode(clazz: [TaggedVehicle].self, source: source)
        }

        // Decoder for TaggedVehicle
        Decoders.addDecoder(clazz: TaggedVehicle.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<TaggedVehicle> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? TaggedVehicle() : instance as! TaggedVehicle
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): _result.name = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "TaggedVehicle", actual: "\(source)"))
            }
        }
        // Decoder for [TaggedVehicleBase]
        Decoders.addDecoder(clazz: [TaggedVehicleBase].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[TaggedVehicleBase]> in
            return Decoders.decode(clazz: [TaggedVehicleBase].self, source: source)
        }

        // Decoder for TaggedVehicleBase
        Decoders.addDecoder(clazz: TaggedVehicleBase.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<TaggedVehicleBase> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? TaggedVehicleBase() : instance as! TaggedVehicleBase
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): _result.id = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "TaggedVehicleBase", actual: "\(source)"))
            }
        }
        // Decoder for [TemperatureResponse]
        Decoders.addDecoder(clazz: [TemperatureResponse].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[TemperatureResponse]> in
            return Decoders.decode(clazz: [TemperatureResponse].self, source: source)
        }

        // Decoder for TemperatureResponse
        Decoders.addDecoder(clazz: TemperatureResponse.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<TemperatureResponse> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? TemperatureResponse() : instance as! TemperatureResponse
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["groupId"] as AnyObject?) {
                
                case let .success(value): _result.groupId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [TemperatureResponseSensors].self, source: sourceDictionary["sensors"] as AnyObject?) {
                
                case let .success(value): _result.sensors = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "TemperatureResponse", actual: "\(source)"))
            }
        }
        // Decoder for [TemperatureResponseSensors]
        Decoders.addDecoder(clazz: [TemperatureResponseSensors].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[TemperatureResponseSensors]> in
            return Decoders.decode(clazz: [TemperatureResponseSensors].self, source: source)
        }

        // Decoder for TemperatureResponseSensors
        Decoders.addDecoder(clazz: TemperatureResponseSensors.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<TemperatureResponseSensors> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? TemperatureResponseSensors() : instance as! TemperatureResponseSensors
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["probeTemperature"] as AnyObject?) {
                
                case let .success(value): _result.probeTemperature = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): _result.name = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): _result.id = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["ambientTemperature"] as AnyObject?) {
                
                case let .success(value): _result.ambientTemperature = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "TemperatureResponseSensors", actual: "\(source)"))
            }
        }
        // Decoder for [TripResponse]
        Decoders.addDecoder(clazz: [TripResponse].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[TripResponse]> in
            return Decoders.decode(clazz: [TripResponse].self, source: source)
        }

        // Decoder for TripResponse
        Decoders.addDecoder(clazz: TripResponse.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<TripResponse> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? TripResponse() : instance as! TripResponse
                switch Decoders.decodeOptional(clazz: [TripResponseTrips].self, source: sourceDictionary["trips"] as AnyObject?) {
                
                case let .success(value): _result.trips = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "TripResponse", actual: "\(source)"))
            }
        }
        // Decoder for [TripResponseEndCoordinates]
        Decoders.addDecoder(clazz: [TripResponseEndCoordinates].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[TripResponseEndCoordinates]> in
            return Decoders.decode(clazz: [TripResponseEndCoordinates].self, source: source)
        }

        // Decoder for TripResponseEndCoordinates
        Decoders.addDecoder(clazz: TripResponseEndCoordinates.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<TripResponseEndCoordinates> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? TripResponseEndCoordinates() : instance as! TripResponseEndCoordinates
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["latitude"] as AnyObject?) {
                
                case let .success(value): _result.latitude = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["longitude"] as AnyObject?) {
                
                case let .success(value): _result.longitude = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "TripResponseEndCoordinates", actual: "\(source)"))
            }
        }
        // Decoder for [TripResponseStartCoordinates]
        Decoders.addDecoder(clazz: [TripResponseStartCoordinates].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[TripResponseStartCoordinates]> in
            return Decoders.decode(clazz: [TripResponseStartCoordinates].self, source: source)
        }

        // Decoder for TripResponseStartCoordinates
        Decoders.addDecoder(clazz: TripResponseStartCoordinates.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<TripResponseStartCoordinates> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? TripResponseStartCoordinates() : instance as! TripResponseStartCoordinates
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["latitude"] as AnyObject?) {
                
                case let .success(value): _result.latitude = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["longitude"] as AnyObject?) {
                
                case let .success(value): _result.longitude = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "TripResponseStartCoordinates", actual: "\(source)"))
            }
        }
        // Decoder for [TripResponseTrips]
        Decoders.addDecoder(clazz: [TripResponseTrips].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[TripResponseTrips]> in
            return Decoders.decode(clazz: [TripResponseTrips].self, source: source)
        }

        // Decoder for TripResponseTrips
        Decoders.addDecoder(clazz: TripResponseTrips.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<TripResponseTrips> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? TripResponseTrips() : instance as! TripResponseTrips
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["endOdometer"] as AnyObject?) {
                
                case let .success(value): _result.endOdometer = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["distanceMeters"] as AnyObject?) {
                
                case let .success(value): _result.distanceMeters = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["endMs"] as AnyObject?) {
                
                case let .success(value): _result.endMs = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["startMs"] as AnyObject?) {
                
                case let .success(value): _result.startMs = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["fuelConsumedMl"] as AnyObject?) {
                
                case let .success(value): _result.fuelConsumedMl = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["startAddress"] as AnyObject?) {
                
                case let .success(value): _result.startAddress = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: TripResponseStartCoordinates.self, source: sourceDictionary["startCoordinates"] as AnyObject?) {
                
                case let .success(value): _result.startCoordinates = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: TripResponseEndCoordinates.self, source: sourceDictionary["endCoordinates"] as AnyObject?) {
                
                case let .success(value): _result.endCoordinates = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["startOdometer"] as AnyObject?) {
                
                case let .success(value): _result.startOdometer = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["driverId"] as AnyObject?) {
                
                case let .success(value): _result.driverId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["startLocation"] as AnyObject?) {
                
                case let .success(value): _result.startLocation = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["tollMeters"] as AnyObject?) {
                
                case let .success(value): _result.tollMeters = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["endAddress"] as AnyObject?) {
                
                case let .success(value): _result.endAddress = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["endLocation"] as AnyObject?) {
                
                case let .success(value): _result.endLocation = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "TripResponseTrips", actual: "\(source)"))
            }
        }
        // Decoder for [User]
        Decoders.addDecoder(clazz: [User].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[User]> in
            return Decoders.decode(clazz: [User].self, source: source)
        }

        // Decoder for User
        Decoders.addDecoder(clazz: User.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<User> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? User() : instance as! User
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): _result.id = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["organizationRole"] as AnyObject?) {
                
                case let .success(value): _result.organizationRole = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [UserTagRole].self, source: sourceDictionary["tagRoles"] as AnyObject?) {
                
                case let .success(value): _result.tagRoles = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "User", actual: "\(source)"))
            }
        }
        // Decoder for [UserBase]
        Decoders.addDecoder(clazz: [UserBase].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[UserBase]> in
            return Decoders.decode(clazz: [UserBase].self, source: source)
        }

        // Decoder for UserBase
        Decoders.addDecoder(clazz: UserBase.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<UserBase> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? UserBase() : instance as! UserBase
                switch Decoders.decodeOptional(clazz: UserBase.AuthType.self, source: sourceDictionary["authType"] as AnyObject?) {
                
                case let .success(value): _result.authType = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["email"] as AnyObject?) {
                
                case let .success(value): _result.email = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): _result.name = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["organizationRoleId"] as AnyObject?) {
                
                case let .success(value): _result.organizationRoleId = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "UserBase", actual: "\(source)"))
            }
        }
        // Decoder for [UserRole]
        Decoders.addDecoder(clazz: [UserRole].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[UserRole]> in
            return Decoders.decode(clazz: [UserRole].self, source: source)
        }

        // Decoder for UserRole
        Decoders.addDecoder(clazz: UserRole.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<UserRole> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? UserRole() : instance as! UserRole
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): _result.id = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): _result.name = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "UserRole", actual: "\(source)"))
            }
        }
        // Decoder for [UserTagRole]
        Decoders.addDecoder(clazz: [UserTagRole].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[UserTagRole]> in
            return Decoders.decode(clazz: [UserTagRole].self, source: source)
        }

        // Decoder for UserTagRole
        Decoders.addDecoder(clazz: UserTagRole.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<UserTagRole> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? UserTagRole() : instance as! UserTagRole
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["role"] as AnyObject?) {
                
                case let .success(value): _result.role = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["roleId"] as AnyObject?) {
                
                case let .success(value): _result.roleId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: UserTagRoleTag.self, source: sourceDictionary["tag"] as AnyObject?) {
                
                case let .success(value): _result.tag = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "UserTagRole", actual: "\(source)"))
            }
        }
        // Decoder for [UserTagRoleTag]
        Decoders.addDecoder(clazz: [UserTagRoleTag].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[UserTagRoleTag]> in
            return Decoders.decode(clazz: [UserTagRoleTag].self, source: source)
        }

        // Decoder for UserTagRoleTag
        Decoders.addDecoder(clazz: UserTagRoleTag.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<UserTagRoleTag> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? UserTagRoleTag() : instance as! UserTagRoleTag
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["parentTagId"] as AnyObject?) {
                
                case let .success(value): _result.parentTagId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): _result.name = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): _result.id = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "UserTagRoleTag", actual: "\(source)"))
            }
        }
        // Decoder for [Vehicle]
        Decoders.addDecoder(clazz: [Vehicle].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[Vehicle]> in
            return Decoders.decode(clazz: [Vehicle].self, source: source)
        }

        // Decoder for Vehicle
        Decoders.addDecoder(clazz: Vehicle.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<Vehicle> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? Vehicle() : instance as! Vehicle
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["engineHours"] as AnyObject?) {
                
                case let .success(value): _result.engineHours = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["fuelLevelPercent"] as AnyObject?) {
                
                case let .success(value): _result.fuelLevelPercent = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): _result.id = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): _result.name = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["note"] as AnyObject?) {
                
                case let .success(value): _result.note = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["odometerMeters"] as AnyObject?) {
                
                case let .success(value): _result.odometerMeters = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["vin"] as AnyObject?) {
                
                case let .success(value): _result.vin = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "Vehicle", actual: "\(source)"))
            }
        }
        // Decoder for [VehicleHarshEventResponse]
        Decoders.addDecoder(clazz: [VehicleHarshEventResponse].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[VehicleHarshEventResponse]> in
            return Decoders.decode(clazz: [VehicleHarshEventResponse].self, source: source)
        }

        // Decoder for VehicleHarshEventResponse
        Decoders.addDecoder(clazz: VehicleHarshEventResponse.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<VehicleHarshEventResponse> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? VehicleHarshEventResponse() : instance as! VehicleHarshEventResponse
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["downloadForwardVideoUrl"] as AnyObject?) {
                
                case let .success(value): _result.downloadForwardVideoUrl = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["downloadInwardVideoUrl"] as AnyObject?) {
                
                case let .success(value): _result.downloadInwardVideoUrl = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["downloadTrackedInwardVideoUrl"] as AnyObject?) {
                
                case let .success(value): _result.downloadTrackedInwardVideoUrl = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["harshEventType"] as AnyObject?) {
                
                case let .success(value): _result.harshEventType = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["incidentReportUrl"] as AnyObject?) {
                
                case let .success(value): _result.incidentReportUrl = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["isDistracted"] as AnyObject?) {
                
                case let .success(value): _result.isDistracted = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: VehicleHarshEventResponseLocation.self, source: sourceDictionary["location"] as AnyObject?) {
                
                case let .success(value): _result.location = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "VehicleHarshEventResponse", actual: "\(source)"))
            }
        }
        // Decoder for [VehicleHarshEventResponseLocation]
        Decoders.addDecoder(clazz: [VehicleHarshEventResponseLocation].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[VehicleHarshEventResponseLocation]> in
            return Decoders.decode(clazz: [VehicleHarshEventResponseLocation].self, source: source)
        }

        // Decoder for VehicleHarshEventResponseLocation
        Decoders.addDecoder(clazz: VehicleHarshEventResponseLocation.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<VehicleHarshEventResponseLocation> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? VehicleHarshEventResponseLocation() : instance as! VehicleHarshEventResponseLocation
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address"] as AnyObject?) {
                
                case let .success(value): _result.address = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["latitude"] as AnyObject?) {
                
                case let .success(value): _result.latitude = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["longitude"] as AnyObject?) {
                
                case let .success(value): _result.longitude = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "VehicleHarshEventResponseLocation", actual: "\(source)"))
            }
        }
        // Decoder for [VehicleLocation]
        Decoders.addDecoder(clazz: [VehicleLocation].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[VehicleLocation]> in
            return Decoders.decode(clazz: [VehicleLocation].self, source: source)
        }

        // Decoder for VehicleLocation
        Decoders.addDecoder(clazz: VehicleLocation.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<VehicleLocation> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? VehicleLocation() : instance as! VehicleLocation
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["heading"] as AnyObject?) {
                
                case let .success(value): _result.heading = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): _result.id = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["latitude"] as AnyObject?) {
                
                case let .success(value): _result.latitude = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["location"] as AnyObject?) {
                
                case let .success(value): _result.location = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["longitude"] as AnyObject?) {
                
                case let .success(value): _result.longitude = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): _result.name = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["odometerMeters"] as AnyObject?) {
                
                case let .success(value): _result.odometerMeters = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["onTrip"] as AnyObject?) {
                
                case let .success(value): _result.onTrip = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["speed"] as AnyObject?) {
                
                case let .success(value): _result.speed = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["time"] as AnyObject?) {
                
                case let .success(value): _result.time = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["vin"] as AnyObject?) {
                
                case let .success(value): _result.vin = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "VehicleLocation", actual: "\(source)"))
            }
        }
        // Decoder for [VehicleMaintenance]
        Decoders.addDecoder(clazz: [VehicleMaintenance].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[VehicleMaintenance]> in
            return Decoders.decode(clazz: [VehicleMaintenance].self, source: source)
        }

        // Decoder for VehicleMaintenance
        Decoders.addDecoder(clazz: VehicleMaintenance.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<VehicleMaintenance> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? VehicleMaintenance() : instance as! VehicleMaintenance
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): _result.id = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: VehicleMaintenanceJ1939.self, source: sourceDictionary["j1939"] as AnyObject?) {
                
                case let .success(value): _result.j1939 = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: VehicleMaintenancePassenger.self, source: sourceDictionary["passenger"] as AnyObject?) {
                
                case let .success(value): _result.passenger = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "VehicleMaintenance", actual: "\(source)"))
            }
        }
        // Decoder for [VehicleMaintenanceJ1939]
        Decoders.addDecoder(clazz: [VehicleMaintenanceJ1939].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[VehicleMaintenanceJ1939]> in
            return Decoders.decode(clazz: [VehicleMaintenanceJ1939].self, source: source)
        }

        // Decoder for VehicleMaintenanceJ1939
        Decoders.addDecoder(clazz: VehicleMaintenanceJ1939.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<VehicleMaintenanceJ1939> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? VehicleMaintenanceJ1939() : instance as! VehicleMaintenanceJ1939
                switch Decoders.decodeOptional(clazz: VehicleMaintenanceJ1939CheckEngineLight.self, source: sourceDictionary["checkEngineLight"] as AnyObject?) {
                
                case let .success(value): _result.checkEngineLight = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [VehicleMaintenanceJ1939DiagnosticTroubleCodes].self, source: sourceDictionary["diagnosticTroubleCodes"] as AnyObject?) {
                
                case let .success(value): _result.diagnosticTroubleCodes = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "VehicleMaintenanceJ1939", actual: "\(source)"))
            }
        }
        // Decoder for [VehicleMaintenanceJ1939CheckEngineLight]
        Decoders.addDecoder(clazz: [VehicleMaintenanceJ1939CheckEngineLight].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[VehicleMaintenanceJ1939CheckEngineLight]> in
            return Decoders.decode(clazz: [VehicleMaintenanceJ1939CheckEngineLight].self, source: source)
        }

        // Decoder for VehicleMaintenanceJ1939CheckEngineLight
        Decoders.addDecoder(clazz: VehicleMaintenanceJ1939CheckEngineLight.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<VehicleMaintenanceJ1939CheckEngineLight> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? VehicleMaintenanceJ1939CheckEngineLight() : instance as! VehicleMaintenanceJ1939CheckEngineLight
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["protectIsOn"] as AnyObject?) {
                
                case let .success(value): _result.protectIsOn = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["stopIsOn"] as AnyObject?) {
                
                case let .success(value): _result.stopIsOn = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["warningIsOn"] as AnyObject?) {
                
                case let .success(value): _result.warningIsOn = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["emissionsIsOn"] as AnyObject?) {
                
                case let .success(value): _result.emissionsIsOn = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "VehicleMaintenanceJ1939CheckEngineLight", actual: "\(source)"))
            }
        }
        // Decoder for [VehicleMaintenanceJ1939DiagnosticTroubleCodes]
        Decoders.addDecoder(clazz: [VehicleMaintenanceJ1939DiagnosticTroubleCodes].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[VehicleMaintenanceJ1939DiagnosticTroubleCodes]> in
            return Decoders.decode(clazz: [VehicleMaintenanceJ1939DiagnosticTroubleCodes].self, source: source)
        }

        // Decoder for VehicleMaintenanceJ1939DiagnosticTroubleCodes
        Decoders.addDecoder(clazz: VehicleMaintenanceJ1939DiagnosticTroubleCodes.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<VehicleMaintenanceJ1939DiagnosticTroubleCodes> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? VehicleMaintenanceJ1939DiagnosticTroubleCodes() : instance as! VehicleMaintenanceJ1939DiagnosticTroubleCodes
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["spnDescription"] as AnyObject?) {
                
                case let .success(value): _result.spnDescription = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["fmiText"] as AnyObject?) {
                
                case let .success(value): _result.fmiText = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["spnId"] as AnyObject?) {
                
                case let .success(value): _result.spnId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["occurrenceCount"] as AnyObject?) {
                
                case let .success(value): _result.occurrenceCount = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["txId"] as AnyObject?) {
                
                case let .success(value): _result.txId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["fmiId"] as AnyObject?) {
                
                case let .success(value): _result.fmiId = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "VehicleMaintenanceJ1939DiagnosticTroubleCodes", actual: "\(source)"))
            }
        }
        // Decoder for [VehicleMaintenancePassenger]
        Decoders.addDecoder(clazz: [VehicleMaintenancePassenger].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[VehicleMaintenancePassenger]> in
            return Decoders.decode(clazz: [VehicleMaintenancePassenger].self, source: source)
        }

        // Decoder for VehicleMaintenancePassenger
        Decoders.addDecoder(clazz: VehicleMaintenancePassenger.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<VehicleMaintenancePassenger> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? VehicleMaintenancePassenger() : instance as! VehicleMaintenancePassenger
                switch Decoders.decodeOptional(clazz: VehicleMaintenancePassengerCheckEngineLight.self, source: sourceDictionary["checkEngineLight"] as AnyObject?) {
                
                case let .success(value): _result.checkEngineLight = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [VehicleMaintenancePassengerDiagnosticTroubleCodes].self, source: sourceDictionary["diagnosticTroubleCodes"] as AnyObject?) {
                
                case let .success(value): _result.diagnosticTroubleCodes = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "VehicleMaintenancePassenger", actual: "\(source)"))
            }
        }
        // Decoder for [VehicleMaintenancePassengerCheckEngineLight]
        Decoders.addDecoder(clazz: [VehicleMaintenancePassengerCheckEngineLight].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[VehicleMaintenancePassengerCheckEngineLight]> in
            return Decoders.decode(clazz: [VehicleMaintenancePassengerCheckEngineLight].self, source: source)
        }

        // Decoder for VehicleMaintenancePassengerCheckEngineLight
        Decoders.addDecoder(clazz: VehicleMaintenancePassengerCheckEngineLight.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<VehicleMaintenancePassengerCheckEngineLight> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? VehicleMaintenancePassengerCheckEngineLight() : instance as! VehicleMaintenancePassengerCheckEngineLight
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["isOn"] as AnyObject?) {
                
                case let .success(value): _result.isOn = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "VehicleMaintenancePassengerCheckEngineLight", actual: "\(source)"))
            }
        }
        // Decoder for [VehicleMaintenancePassengerDiagnosticTroubleCodes]
        Decoders.addDecoder(clazz: [VehicleMaintenancePassengerDiagnosticTroubleCodes].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[VehicleMaintenancePassengerDiagnosticTroubleCodes]> in
            return Decoders.decode(clazz: [VehicleMaintenancePassengerDiagnosticTroubleCodes].self, source: source)
        }

        // Decoder for VehicleMaintenancePassengerDiagnosticTroubleCodes
        Decoders.addDecoder(clazz: VehicleMaintenancePassengerDiagnosticTroubleCodes.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<VehicleMaintenancePassengerDiagnosticTroubleCodes> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? VehicleMaintenancePassengerDiagnosticTroubleCodes() : instance as! VehicleMaintenancePassengerDiagnosticTroubleCodes
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["dtcShortCode"] as AnyObject?) {
                
                case let .success(value): _result.dtcShortCode = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["dtcId"] as AnyObject?) {
                
                case let .success(value): _result.dtcId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["dtcDescription"] as AnyObject?) {
                
                case let .success(value): _result.dtcDescription = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "VehicleMaintenancePassengerDiagnosticTroubleCodes", actual: "\(source)"))
            }
        }
        // Decoder for [VehicleSafetyScoreResponse]
        Decoders.addDecoder(clazz: [VehicleSafetyScoreResponse].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[VehicleSafetyScoreResponse]> in
            return Decoders.decode(clazz: [VehicleSafetyScoreResponse].self, source: source)
        }

        // Decoder for VehicleSafetyScoreResponse
        Decoders.addDecoder(clazz: VehicleSafetyScoreResponse.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<VehicleSafetyScoreResponse> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? VehicleSafetyScoreResponse() : instance as! VehicleSafetyScoreResponse
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["crashCount"] as AnyObject?) {
                
                case let .success(value): _result.crashCount = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["harshAccelCount"] as AnyObject?) {
                
                case let .success(value): _result.harshAccelCount = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["harshBrakingCount"] as AnyObject?) {
                
                case let .success(value): _result.harshBrakingCount = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [SafetyReportHarshEvent].self, source: sourceDictionary["harshEvents"] as AnyObject?) {
                
                case let .success(value): _result.harshEvents = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["harshTurningCount"] as AnyObject?) {
                
                case let .success(value): _result.harshTurningCount = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["safetyScore"] as AnyObject?) {
                
                case let .success(value): _result.safetyScore = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["safetyScoreRank"] as AnyObject?) {
                
                case let .success(value): _result.safetyScoreRank = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["timeOverSpeedLimitMs"] as AnyObject?) {
                
                case let .success(value): _result.timeOverSpeedLimitMs = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["totalDistanceDrivenMeters"] as AnyObject?) {
                
                case let .success(value): _result.totalDistanceDrivenMeters = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["totalHarshEventCount"] as AnyObject?) {
                
                case let .success(value): _result.totalHarshEventCount = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["totalTimeDrivenMs"] as AnyObject?) {
                
                case let .success(value): _result.totalTimeDrivenMs = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["vehicleId"] as AnyObject?) {
                
                case let .success(value): _result.vehicleId = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "VehicleSafetyScoreResponse", actual: "\(source)"))
            }
        }
    }()

    static fileprivate func initialize() {
        _ = Decoders.__once
    }
}
